"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/meilisearch";
exports.ids = ["vendor-chunks/meilisearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/meilisearch/dist/bundles/meilisearch.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpRequests: () => (/* binding */ HttpRequests),\n/* harmony export */   Index: () => (/* binding */ Index),\n/* harmony export */   MeiliSearch: () => (/* binding */ MeiliSearch),\n/* harmony export */   MeiliSearchApiError: () => (/* binding */ MeiliSearchApiError),\n/* harmony export */   MeiliSearchCommunicationError: () => (/* binding */ MeiliSearchCommunicationError),\n/* harmony export */   MeiliSearchError: () => (/* binding */ MeiliSearchError),\n/* harmony export */   MeiliSearchTimeOutError: () => (/* binding */ MeiliSearchTimeOutError),\n/* harmony export */   addProtocolIfNotPresent: () => (/* binding */ addProtocolIfNotPresent),\n/* harmony export */   addTrailingSlash: () => (/* binding */ addTrailingSlash),\n/* harmony export */   \"default\": () => (/* binding */ MeiliSearch),\n/* harmony export */   httpErrorHandler: () => (/* binding */ httpErrorHandler),\n/* harmony export */   httpResponseErrorHandler: () => (/* binding */ httpResponseErrorHandler),\n/* harmony export */   removeUndefinedFromObject: () => (/* binding */ removeUndefinedFromObject),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch/polyfill */ \"(ssr)/./node_modules/cross-fetch/dist/node-polyfill.js\");\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar MeiliSearchCommunicationError = /** @class */ function(_super) {\n    __extends(MeiliSearchCommunicationError, _super);\n    function MeiliSearchCommunicationError(message, body, url, stack) {\n        var _this = this;\n        var _a, _b, _c;\n        _this = _super.call(this, message) || this;\n        _this.name = \"MeiliSearchCommunicationError\";\n        _this.type = \"MeiliSearchCommunicationError\";\n        if (body instanceof Response) {\n            _this.message = body.statusText;\n            _this.statusCode = body.status;\n        }\n        if (body instanceof Error) {\n            _this.errno = body.errno;\n            _this.code = body.code;\n        }\n        if (stack) {\n            _this.stack = stack;\n            _this.stack = (_a = _this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, _this.name);\n            _this.stack = (_b = _this.stack) === null || _b === void 0 ? void 0 : _b.replace(\"Failed to fetch\", \"request to \".concat(url, \" failed, reason: connect ECONNREFUSED\"));\n            _this.stack = (_c = _this.stack) === null || _c === void 0 ? void 0 : _c.replace(\"Not Found\", \"Not Found: \".concat(url));\n        } else {\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(_this, MeiliSearchCommunicationError);\n            }\n        }\n        return _this;\n    }\n    return MeiliSearchCommunicationError;\n}(Error);\nvar MeiliSearchApiError = /** @class */ function(_super) {\n    __extends(class_1, _super);\n    function class_1(error, status) {\n        var _this = _super.call(this, error.message) || this;\n        _this.name = \"MeiliSearchApiError\";\n        _this.code = error.code;\n        _this.type = error.type;\n        _this.link = error.link;\n        _this.message = error.message;\n        _this.httpStatus = status;\n        // Make errors comparison possible. ex: error instanceof MeiliSearchApiError.\n        Object.setPrototypeOf(_this, MeiliSearchApiError.prototype);\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, MeiliSearchApiError);\n        }\n        return _this;\n    }\n    return class_1;\n}(Error);\nfunction httpResponseErrorHandler(response) {\n    return __awaiter(this, void 0, void 0, function() {\n        var err;\n        return __generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    if (!!response.ok) return [\n                        3 /*break*/ ,\n                        5\n                    ];\n                    err = void 0;\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([\n                        1,\n                        3,\n                        ,\n                        4\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        response.json()\n                    ];\n                case 2:\n                    err = _a.sent();\n                    return [\n                        3 /*break*/ ,\n                        4\n                    ];\n                case 3:\n                    _a.sent();\n                    throw new MeiliSearchCommunicationError(response.statusText, response, response.url);\n                case 4:\n                    throw new MeiliSearchApiError(err, response.status);\n                case 5:\n                    return [\n                        2 /*return*/ ,\n                        response\n                    ];\n            }\n        });\n    });\n}\nfunction httpErrorHandler(response, stack, url) {\n    if (response.type !== \"MeiliSearchApiError\") {\n        throw new MeiliSearchCommunicationError(response.message, response, url, stack);\n    }\n    throw response;\n}\nvar MeiliSearchError = /** @class */ function(_super) {\n    __extends(MeiliSearchError, _super);\n    function MeiliSearchError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \"MeiliSearchError\";\n        _this.type = \"MeiliSearchError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, MeiliSearchError);\n        }\n        return _this;\n    }\n    return MeiliSearchError;\n}(Error);\nvar MeiliSearchTimeOutError = /** @class */ function(_super) {\n    __extends(MeiliSearchTimeOutError, _super);\n    function MeiliSearchTimeOutError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \"MeiliSearchTimeOutError\";\n        _this.type = _this.constructor.name;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, MeiliSearchTimeOutError);\n        }\n        return _this;\n    }\n    return MeiliSearchTimeOutError;\n}(Error);\n/**\r\n * Removes undefined entries from object\r\n */ function removeUndefinedFromObject(obj) {\n    return Object.entries(obj).reduce(function(acc, curEntry) {\n        var key = curEntry[0], val = curEntry[1];\n        if (val !== undefined) acc[key] = val;\n        return acc;\n    }, {});\n}\nfunction sleep(ms) {\n    return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n            switch(_a.label){\n                case 0:\n                    return [\n                        4 /*yield*/ ,\n                        new Promise(function(resolve) {\n                            return setTimeout(resolve, ms);\n                        })\n                    ];\n                case 1:\n                    return [\n                        2 /*return*/ ,\n                        _a.sent()\n                    ];\n            }\n        });\n    });\n}\nfunction addProtocolIfNotPresent(host) {\n    if (!(host.startsWith(\"https://\") || host.startsWith(\"http://\"))) {\n        return \"http://\".concat(host);\n    }\n    return host;\n}\nfunction addTrailingSlash(url) {\n    if (!url.endsWith(\"/\")) {\n        url += \"/\";\n    }\n    return url;\n}\nfunction constructHostURL(host) {\n    try {\n        host = addProtocolIfNotPresent(host);\n        host = addTrailingSlash(host);\n        return host;\n    } catch (e) {\n        throw new MeiliSearchError(\"The provided host is not valid.\");\n    }\n}\nvar HttpRequests = /** @class */ function() {\n    function HttpRequests(config) {\n        this.headers = Object.assign({}, config.headers || {}); // assign to avoid referencing\n        this.headers[\"Content-Type\"] = \"application/json\";\n        if (config.apiKey) {\n            this.headers[\"Authorization\"] = \"Bearer \".concat(config.apiKey);\n        }\n        try {\n            var host = constructHostURL(config.host);\n            this.url = new URL(host);\n        } catch (e) {\n            throw new MeiliSearchError(\"The provided host is not valid.\");\n        }\n    }\n    HttpRequests.prototype.request = function(_a) {\n        var method = _a.method, url = _a.url, params = _a.params, body = _a.body, config = _a.config;\n        return __awaiter(this, void 0, void 0, function() {\n            var constructURL, queryParams_1, response, parsedBody, parsedJson, e_1, stack;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        constructURL = new URL(url, this.url);\n                        if (params) {\n                            queryParams_1 = new URLSearchParams();\n                            Object.keys(params).filter(function(x) {\n                                return params[x] !== null;\n                            }).map(function(x) {\n                                return queryParams_1.set(x, params[x]);\n                            });\n                            constructURL.search = queryParams_1.toString();\n                        }\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([\n                            1,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            fetch(constructURL.toString(), __assign(__assign({}, config), {\n                                method: method,\n                                body: JSON.stringify(body),\n                                headers: this.headers\n                            })).then(function(res) {\n                                return httpResponseErrorHandler(res);\n                            })\n                        ];\n                    case 2:\n                        response = _b.sent();\n                        return [\n                            4 /*yield*/ ,\n                            response.text()\n                        ];\n                    case 3:\n                        parsedBody = _b.sent();\n                        try {\n                            parsedJson = JSON.parse(parsedBody);\n                            return [\n                                2 /*return*/ ,\n                                parsedJson\n                            ];\n                        } catch (_) {\n                            return [\n                                2 /*return*/ \n                            ];\n                        }\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 4:\n                        e_1 = _b.sent();\n                        stack = e_1.stack;\n                        httpErrorHandler(e_1, stack, constructURL.toString());\n                        return [\n                            3 /*break*/ ,\n                            5\n                        ];\n                    case 5:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    HttpRequests.prototype.get = function(url, params, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.request({\n                                method: \"GET\",\n                                url: url,\n                                params: params,\n                                config: config\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    HttpRequests.prototype.post = function(url, data, params, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.request({\n                                method: \"POST\",\n                                url: url,\n                                body: data,\n                                params: params,\n                                config: config\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    HttpRequests.prototype.put = function(url, data, params, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.request({\n                                method: \"PUT\",\n                                url: url,\n                                body: data,\n                                params: params,\n                                config: config\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    HttpRequests.prototype.patch = function(url, data, params, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.request({\n                                method: \"PATCH\",\n                                url: url,\n                                body: data,\n                                params: params,\n                                config: config\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    HttpRequests.prototype[\"delete\"] = function(url, data, params, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.request({\n                                method: \"DELETE\",\n                                url: url,\n                                body: data,\n                                params: params,\n                                config: config\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    return HttpRequests;\n}();\nvar TaskClient = /** @class */ function() {\n    function TaskClient(config) {\n        this.httpRequest = new HttpRequests(config);\n    }\n    TaskClient.prototype.getClientTask = function(uid) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"tasks/\".concat(uid);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    TaskClient.prototype.getClientTasks = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"tasks\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    TaskClient.prototype.getIndexTask = function(indexUid, taskId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(indexUid, \"/tasks/\").concat(taskId);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    TaskClient.prototype.getIndexTasks = function(indexUid) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(indexUid, \"/tasks\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @param {number} uid Task identifier\r\n     * @param {WaitOptions} options Additional configuration options\r\n     * @returns {Promise<Task>} Promise returning a task after it has been processed\r\n     */ TaskClient.prototype.waitForClientTask = function(taskId, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            var startingTime, response;\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        startingTime = Date.now();\n                        _e.label = 1;\n                    case 1:\n                        if (!(Date.now() - startingTime < timeOutMs)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.getClientTask(taskId)\n                        ];\n                    case 2:\n                        response = _e.sent();\n                        if (![\n                            \"enqueued\" /* TASK_ENQUEUED */ ,\n                            \"processing\" /* TASK_PROCESSING */ \n                        ].includes(response.status)) return [\n                            2 /*return*/ ,\n                            response\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            sleep(intervalMs)\n                        ];\n                    case 3:\n                        _e.sent();\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 4:\n                        throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskId, \" when waiting a task to be resolved.\"));\n                }\n            });\n        });\n    };\n    /**\r\n     * Waits for multiple tasks to be processed\r\n     *\r\n     * @param {number} taskIds Tasks identifier list\r\n     * @param {WaitOptions} options Wait options\r\n     * @returns {Promise<Result<Task[]>>} Promise returning a list of tasks after they have been processed\r\n     */ TaskClient.prototype.waitForClientTasks = function(taskIds, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            var tasks, _i, taskIds_1, taskId, task;\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        tasks = [];\n                        _i = 0, taskIds_1 = taskIds;\n                        _e.label = 1;\n                    case 1:\n                        if (!(_i < taskIds_1.length)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        taskId = taskIds_1[_i];\n                        return [\n                            4 /*yield*/ ,\n                            this.waitForClientTask(taskId, {\n                                timeOutMs: timeOutMs,\n                                intervalMs: intervalMs\n                            })\n                        ];\n                    case 2:\n                        task = _e.sent();\n                        tasks.push(task);\n                        _e.label = 3;\n                    case 3:\n                        _i++;\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ ,\n                            {\n                                results: tasks\n                            }\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Waits for a task to be processed\r\n     *\r\n     * @param {number} taskId Task identifier\r\n     * @param {WaitOptions} options Wait options\r\n     * @returns {Promise<Task>} Promise returning a task after it has been processed\r\n     */ TaskClient.prototype.waitForIndexTask = function(indexUid, taskId, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            var startingTime, response;\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        startingTime = Date.now();\n                        _e.label = 1;\n                    case 1:\n                        if (!(Date.now() - startingTime < timeOutMs)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            this.getIndexTask(indexUid, taskId)\n                        ];\n                    case 2:\n                        response = _e.sent();\n                        if (![\n                            \"enqueued\" /* TASK_ENQUEUED */ ,\n                            \"processing\" /* TASK_PROCESSING */ \n                        ].includes(response.status)) return [\n                            2 /*return*/ ,\n                            response\n                        ];\n                        return [\n                            4 /*yield*/ ,\n                            sleep(intervalMs)\n                        ];\n                    case 3:\n                        _e.sent();\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 4:\n                        throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskId, \" when waiting for pending update to resolve.\"));\n                }\n            });\n        });\n    };\n    return TaskClient;\n}();\n/*\r\n * Bundle: MeiliSearch / Indexes\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */ var Index = /** @class */ function() {\n    /**\r\n     * @param {Config} config Request configuration options\r\n     * @param {string} uid UID of the index\r\n     * @param {string} primaryKey? Primary Key of the index\r\n     */ function Index(config, uid, primaryKey) {\n        this.uid = uid;\n        this.primaryKey = primaryKey;\n        this.httpRequest = new HttpRequests(config);\n        this.tasks = new TaskClient(config);\n    }\n    ///\n    /// SEARCH\n    ///\n    /**\r\n     * Search for documents into an index\r\n     * @memberof Index\r\n     * @method search\r\n     * @template T\r\n     * @param {string | null} query? Query string\r\n     * @param {SearchParams} options? Search options\r\n     * @param {Partial<Request>} config? Additional request configuration options\r\n     * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n     */ Index.prototype.search = function(query, options, config) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/search\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, removeUndefinedFromObject(__assign(__assign({}, options), {\n                                q: query\n                            })), undefined, config)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Search for documents into an index using the GET method\r\n     * @memberof Index\r\n     * @method search\r\n     * @template T\r\n     * @param {string | null} query? Query string\r\n     * @param {SearchParams} options? Search options\r\n     * @param {Partial<Request>} config? Additional request configuration options\r\n     * @returns {Promise<SearchResponse<T>>} Promise containing the search response\r\n     */ Index.prototype.searchGet = function(query, options, config) {\n        var _a, _b, _c, _d, _e;\n        return __awaiter(this, void 0, void 0, function() {\n            var url, parseFilter, getParams;\n            return __generator(this, function(_f) {\n                switch(_f.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/search\");\n                        parseFilter = function(filter) {\n                            if (typeof filter === \"string\") return filter;\n                            else if (Array.isArray(filter)) throw new MeiliSearchError(\"The filter query parameter should be in string format when using searchGet\");\n                            else return undefined;\n                        };\n                        getParams = __assign(__assign({\n                            q: query\n                        }, options), {\n                            filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter),\n                            sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(\",\"),\n                            facetsDistribution: (_b = options === null || options === void 0 ? void 0 : options.facetsDistribution) === null || _b === void 0 ? void 0 : _b.join(\",\"),\n                            attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(\",\"),\n                            attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(\",\"),\n                            attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(\",\")\n                        });\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url, removeUndefinedFromObject(getParams), config)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _f.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// INDEX\n    ///\n    /**\r\n     * Get index information.\r\n     * @memberof Index\r\n     * @method getRawInfo\r\n     * @returns {Promise<IndexResponse>} Promise containing index information\r\n     */ Index.prototype.getRawInfo = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url, res;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        res = _a.sent();\n                        this.primaryKey = res.primaryKey;\n                        return [\n                            2 /*return*/ ,\n                            res\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Fetch and update Index information.\r\n     * @memberof Index\r\n     * @method fetchInfo\r\n     * @returns {Promise<this>} Promise to the current Index object with updated information\r\n     */ Index.prototype.fetchInfo = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.getRawInfo()\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            this\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get Primary Key.\r\n     * @memberof Index\r\n     * @method fetchPrimaryKey\r\n     * @returns {Promise<string | undefined>} Promise containing the Primary Key of the index\r\n     */ Index.prototype.fetchPrimaryKey = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var _a;\n            return __generator(this, function(_b) {\n                switch(_b.label){\n                    case 0:\n                        _a = this;\n                        return [\n                            4 /*yield*/ ,\n                            this.getRawInfo()\n                        ];\n                    case 1:\n                        _a.primaryKey = _b.sent().primaryKey;\n                        return [\n                            2 /*return*/ ,\n                            this.primaryKey\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Create an index.\r\n     * @memberof Index\r\n     * @method create\r\n     * @template T\r\n     * @param {string} uid Unique identifier of the Index\r\n     * @param {IndexOptions} options Index options\r\n     * @param {Config} config Request configuration options\r\n     * @returns {Promise<Index<T>>} Newly created Index object\r\n     */ Index.create = function(uid, options, config) {\n        if (options === void 0) {\n            options = {};\n        }\n        return __awaiter(this, void 0, void 0, function() {\n            var url, req;\n            return __generator(this, function(_a) {\n                url = \"indexes\";\n                req = new HttpRequests(config);\n                return [\n                    2 /*return*/ ,\n                    req.post(url, __assign(__assign({}, options), {\n                        uid: uid\n                    }))\n                ];\n            });\n        });\n    };\n    /**\r\n     * Update an index.\r\n     * @memberof Index\r\n     * @method update\r\n     * @param {IndexOptions} data Data to update\r\n     * @returns {Promise<this>} Promise to the current Index object with updated information\r\n     */ Index.prototype.update = function(data) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.put(url, data)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete an index.\r\n     * @memberof Index\r\n     * @method delete\r\n     * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n     */ Index.prototype[\"delete\"] = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// TASKS\n    ///\n    /**\r\n     * Get the list of all the index tasks.\r\n     *\r\n     * @memberof Indexes\r\n     * @method getTasks\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise containing all tasks\r\n     */ Index.prototype.getTasks = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.getIndexTasks(this.uid)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get one task of the index.\r\n     *\r\n     * @memberof Indexes\r\n     * @method getTask\r\n     * @param {number} taskId - Task identifier\r\n     *\r\n     * @returns {Promise<Task>} - Promise containing a task\r\n     */ Index.prototype.getTask = function(taskId) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.getIndexTask(this.uid, taskId)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Wait for a batch of an index tasks to be processed.\r\n     *\r\n     * @memberof Indexes\r\n     * @method waitForTasks\r\n     * @param {number[]} taskIds - Tasks identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise containing an array of tasks\r\n     */ Index.prototype.waitForTasks = function(taskIds, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.waitForClientTasks(taskIds, {\n                                timeOutMs: timeOutMs,\n                                intervalMs: intervalMs\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _e.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Wait for an index task to be processed.\r\n     *\r\n     * @memberof Indexes\r\n     * @method waitForTask\r\n     * @param {number} taskId - Task identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Task>} - Promise containing an array of tasks\r\n     */ Index.prototype.waitForTask = function(taskId, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.waitForClientTask(taskId, {\n                                timeOutMs: timeOutMs,\n                                intervalMs: intervalMs\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _e.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// STATS\n    ///\n    /**\r\n     * get stats of an index\r\n     * @memberof Index\r\n     * @method getStats\r\n     * @returns {Promise<IndexStats>} Promise containing object with stats of the index\r\n     */ Index.prototype.getStats = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/stats\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// DOCUMENTS\n    ///\n    /**\r\n     * get documents of an index\r\n     * @memberof Index\r\n     * @method getDocuments\r\n     * @template T\r\n     * @param {GetDocumentsParams<T>} options? Options to browse the documents\r\n     * @returns {Promise<GetDocumentsResponse<T>>} Promise containing Document responses\r\n     */ Index.prototype.getDocuments = function(options) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url, attr;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\n                        if (options !== undefined && Array.isArray(options.attributesToRetrieve)) {\n                            attr = options.attributesToRetrieve.join(\",\");\n                        }\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url, __assign(__assign({}, options), attr !== undefined ? {\n                                attributesToRetrieve: attr\n                            } : {}))\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get one document\r\n     * @memberof Index\r\n     * @method getDocument\r\n     * @template T\r\n     * @param {string | number} documentId Document ID\r\n     * @returns {Promise<Document<T>>} Promise containing Document response\r\n     */ Index.prototype.getDocument = function(documentId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Add or replace multiples documents to an index\r\n     * @memberof Index\r\n     * @method addDocuments\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.addDocuments = function(documents, options) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, documents, options)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Add or replace multiples documents to an index in batches\r\n     * @memberof Index\r\n     * @method addDocumentsInBatches\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/replace\r\n     * @param {number} batchSize Size of the batch\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued update objects for each batch\r\n     */ Index.prototype.addDocumentsInBatches = function(documents, batchSize, options) {\n        if (batchSize === void 0) {\n            batchSize = 1000;\n        }\n        return __awaiter(this, void 0, void 0, function() {\n            var updates, i, _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        updates = [];\n                        i = 0;\n                        _c.label = 1;\n                    case 1:\n                        if (!(i < documents.length)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        _b = (_a = updates).push;\n                        return [\n                            4 /*yield*/ ,\n                            this.addDocuments(documents.slice(i, i + batchSize), options)\n                        ];\n                    case 2:\n                        _b.apply(_a, [\n                            _c.sent()\n                        ]);\n                        _c.label = 3;\n                    case 3:\n                        i += batchSize;\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ ,\n                            updates\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Add or update multiples documents to an index\r\n     * @memberof Index\r\n     * @method updateDocuments\r\n     * @param {Array<Document<Partial<T>>>} documents Array of Document objects to add/update\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateDocuments = function(documents, options) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.put(url, documents, options)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Add or update multiples documents to an index in batches\r\n     * @memberof Index\r\n     * @method updateDocuments\r\n     * @template T\r\n     * @param {Array<Document<T>>} documents Array of Document objects to add/update\r\n     * @param {number} batchSize Size of the batch\r\n     * @param {AddDocumentParams} options? Query parameters\r\n     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued update objects for each batch\r\n     */ Index.prototype.updateDocumentsInBatches = function(documents, batchSize, options) {\n        if (batchSize === void 0) {\n            batchSize = 1000;\n        }\n        return __awaiter(this, void 0, void 0, function() {\n            var updates, i, _a, _b;\n            return __generator(this, function(_c) {\n                switch(_c.label){\n                    case 0:\n                        updates = [];\n                        i = 0;\n                        _c.label = 1;\n                    case 1:\n                        if (!(i < documents.length)) return [\n                            3 /*break*/ ,\n                            4\n                        ];\n                        _b = (_a = updates).push;\n                        return [\n                            4 /*yield*/ ,\n                            this.updateDocuments(documents.slice(i, i + batchSize), options)\n                        ];\n                    case 2:\n                        _b.apply(_a, [\n                            _c.sent()\n                        ]);\n                        _c.label = 3;\n                    case 3:\n                        i += batchSize;\n                        return [\n                            3 /*break*/ ,\n                            1\n                        ];\n                    case 4:\n                        return [\n                            2 /*return*/ ,\n                            updates\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete one document\r\n     * @memberof Index\r\n     * @method deleteDocument\r\n     * @param {string | number} documentId Id of Document to delete\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.deleteDocument = function(documentId) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete multiples documents of an index\r\n     * @memberof Index\r\n     * @method deleteDocuments\r\n     * @param {string[] | number[]} documentsIds Array of Document Ids to delete\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.deleteDocuments = function(documentsIds) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents/delete-batch\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, documentsIds)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete all documents of an index\r\n     * @memberof Index\r\n     * @method deleteAllDocuments\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.deleteAllDocuments = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// SETTINGS\n    ///\n    /**\r\n     * Retrieve all settings\r\n     * @memberof Index\r\n     * @method getSettings\r\n     * @returns {Promise<Settings>} Promise containing Settings object\r\n     */ Index.prototype.getSettings = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update all settings\r\n     * Any parameters not provided will be left unchanged.\r\n     * @memberof Index\r\n     * @method updateSettings\r\n     * @param {Settings} settings Object containing parameters with their updated values\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.updateSettings = function(settings) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, settings)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset settings.\r\n     * @memberof Index\r\n     * @method resetSettings\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.resetSettings = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// SYNONYMS\n    ///\n    /**\r\n     * Get the list of all synonyms\r\n     * @memberof Index\r\n     * @method getSynonyms\r\n     * @returns {Promise<object>} Promise containing object of synonym mappings\r\n     */ Index.prototype.getSynonyms = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the list of synonyms. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateSynonyms\r\n     * @param {Synonyms} synonyms Mapping of synonyms with their associated words\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.updateSynonyms = function(synonyms) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, synonyms)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the synonym list to be empty again\r\n     * @memberof Index\r\n     * @method resetSynonyms\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.resetSynonyms = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// STOP WORDS\n    ///\n    /**\r\n     * Get the list of all stop-words\r\n     * @memberof Index\r\n     * @method getStopWords\r\n     * @returns {Promise<string[]>} Promise containing array of stop-words\r\n     */ Index.prototype.getStopWords = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the list of stop-words. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateStopWords\r\n     * @param {StopWords} stopWords Array of strings that contains the stop-words.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateStopWords = function(stopWords) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, stopWords)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the stop-words list to be empty again\r\n     * @memberof Index\r\n     * @method resetStopWords\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetStopWords = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// RANKING RULES\n    ///\n    /**\r\n     * Get the list of all ranking-rules\r\n     * @memberof Index\r\n     * @method getRankingRules\r\n     * @returns {Promise<string[]} Promise containing array of ranking-rules\r\n     */ Index.prototype.getRankingRules = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the list of ranking-rules. Overwrite the old list.\r\n     * @memberof Index\r\n     * @method updateRankingRules\r\n     * @param {RankingRules} rankingRules Array that contain ranking rules sorted by order of importance.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateRankingRules = function(rankingRules) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, rankingRules)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the ranking rules list to its default value\r\n     * @memberof Index\r\n     * @method resetRankingRules\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetRankingRules = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// DISTINCT ATTRIBUTE\n    ///\n    /**\r\n     * Get the distinct-attribute\r\n     * @memberof Index\r\n     * @method getDistinctAttribute\r\n     * @returns {Promise<string | null>} Promise containing the distinct-attribute of the index\r\n     */ Index.prototype.getDistinctAttribute = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the distinct-attribute.\r\n     * @memberof Index\r\n     * @method updateDistinctAttribute\r\n     * @param {DistinctAttribute} distinctAttribute Field name of the distinct-attribute\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateDistinctAttribute = function(distinctAttribute) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, distinctAttribute)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the distinct-attribute.\r\n     * @memberof Index\r\n     * @method resetDistinctAttribute\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetDistinctAttribute = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// FILTERABLE ATTRIBUTES\n    ///\n    /**\r\n     * Get the filterable-attributes\r\n     * @memberof Index\r\n     * @method getFilterableAttributes\r\n     * @returns {Promise<string[]>} Promise containing an array of filterable-attributes\r\n     */ Index.prototype.getFilterableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the filterable-attributes.\r\n     * @memberof Index\r\n     * @method updateFilterableAttributes\r\n     * @param {FilterableAttributes} filterableAttributes Array of strings containing the attributes that can be used as filters at query time\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateFilterableAttributes = function(filterableAttributes) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, filterableAttributes)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the filterable-attributes.\r\n     * @memberof Index\r\n     * @method resetFilterableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetFilterableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// SORTABLE ATTRIBUTES\n    ///\n    /**\r\n     * Get the sortable-attributes\r\n     * @memberof Index\r\n     * @method getSortableAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of sortable-attributes\r\n     */ Index.prototype.getSortableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the sortable-attributes.\r\n     * @memberof Index\r\n     * @method updateSortableAttributes\r\n     * @param {SortableAttributes} sortableAttributes Array of strings containing the attributes that can be used to sort search results at query time\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.updateSortableAttributes = function(sortableAttributes) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, sortableAttributes)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the sortable-attributes.\r\n     * @memberof Index\r\n     * @method resetSortableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.resetSortableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// SEARCHABLE ATTRIBUTE\n    ///\n    /**\r\n     * Get the searchable-attributes\r\n     * @memberof Index\r\n     * @method getSearchableAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of searchable-attributes\r\n     */ Index.prototype.getSearchableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the searchable-attributes.\r\n     * @memberof Index\r\n     * @method updateSearchableAttributes\r\n     * @param {SearchableAttributes} searchableAttributes Array of strings that contains searchable attributes sorted by order of importance(most to least important)\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.updateSearchableAttributes = function(searchableAttributes) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, searchableAttributes)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the searchable-attributes.\r\n     * @memberof Index\r\n     * @method resetSearchableAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task\r\n     */ Index.prototype.resetSearchableAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// DISPLAYED ATTRIBUTE\n    ///\n    /**\r\n     * Get the displayed-attributes\r\n     * @memberof Index\r\n     * @method getDisplayedAttributes\r\n     * @returns {Promise<string[]>} Promise containing array of displayed-attributes\r\n     */ Index.prototype.getDisplayedAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the displayed-attributes.\r\n     * @memberof Index\r\n     * @method updateDisplayedAttributes\r\n     * @param {DisplayedAttributes} displayedAttributes Array of strings that contains attributes of an index to display\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateDisplayedAttributes = function(displayedAttributes) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, displayedAttributes)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the displayed-attributes.\r\n     * @memberof Index\r\n     * @method resetDisplayedAttributes\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetDisplayedAttributes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// TYPO TOLERANCE\n    ///\n    /**\r\n     * Get the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method getTypoTolerance\r\n     * @returns {Promise<string[]>} Promise containing the typo tolerance settings.\r\n     */ Index.prototype.getTypoTolerance = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method updateTypoTolerance\r\n     * @param {TypoTolerance} typoTolerance Object containing the custom typo tolerance settings.\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.updateTypoTolerance = function(typoTolerance) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, typoTolerance)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Reset the typo tolerance settings.\r\n     * @memberof Index\r\n     * @method resetTypoTolerance\r\n     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update\r\n     */ Index.prototype.resetTypoTolerance = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    return Index;\n}();\n/*\r\n * Bundle: MeiliSearch\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */ var Client = /** @class */ function() {\n    /**\r\n     * Creates new MeiliSearch instance\r\n     * @param {Config} config Configuration object\r\n     */ function Client(config) {\n        this.config = config;\n        this.httpRequest = new HttpRequests(config);\n        this.tasks = new TaskClient(config);\n    }\n    /**\r\n     * Return an Index instance\r\n     * @memberof MeiliSearch\r\n     * @method index\r\n     * @template T\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Index<T>} Instance of Index\r\n     */ Client.prototype.index = function(indexUid) {\n        return new Index(this.config, indexUid);\n    };\n    /**\r\n     * Gather information about an index by calling MeiliSearch and\r\n     * return an Index instance with the gathered information\r\n     * @memberof MeiliSearch\r\n     * @method getIndex\r\n     * @template T\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance\r\n     */ Client.prototype.getIndex = function(indexUid) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                return [\n                    2 /*return*/ ,\n                    new Index(this.config, indexUid).fetchInfo()\n                ];\n            });\n        });\n    };\n    /**\r\n     * Gather information about an index by calling MeiliSearch and\r\n     * return the raw JSON response\r\n     * @memberof MeiliSearch\r\n     * @method getRawIndex\r\n     * @param {string} indexUid The index UID\r\n     * @returns {Promise<IndexResponse>} Promise returning index information\r\n     */ Client.prototype.getRawIndex = function(indexUid) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                return [\n                    2 /*return*/ ,\n                    new Index(this.config, indexUid).getRawInfo()\n                ];\n            });\n        });\n    };\n    /**\r\n     * Get all the indexes as Index instances.\r\n     * @memberof MeiliSearch\r\n     * @method getIndexes\r\n     * @returns {Promise<Index[]>} Promise returning array of raw index information\r\n     */ Client.prototype.getIndexes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var response, indexes;\n            var _this = this;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.getRawIndexes()\n                        ];\n                    case 1:\n                        response = _a.sent();\n                        indexes = response.map(function(index) {\n                            return new Index(_this.config, index.uid, index.primaryKey);\n                        });\n                        return [\n                            2 /*return*/ ,\n                            indexes\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get all the indexes in their raw value (no Index instances).\r\n     * @memberof MeiliSearch\r\n     * @method getRawIndexes\r\n     * @returns {Promise<IndexResponse[]>} Promise returning array of raw index information\r\n     */ Client.prototype.getRawIndexes = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"indexes\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Create a new index\r\n     * @memberof MeiliSearch\r\n     * @method createIndex\r\n     * @template T\r\n     * @param {string} uid The index UID\r\n     * @param {IndexOptions} options Index options\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance\r\n     */ Client.prototype.createIndex = function(uid, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            Index.create(uid, options, this.config)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update an index\r\n     * @memberof MeiliSearch\r\n     * @method updateIndex\r\n     * @template T\r\n     * @param {string} uid The index UID\r\n     * @param {IndexOptions} options Index options to update\r\n     * @returns {Promise<Index<T>>} Promise returning Index instance after updating\r\n     */ Client.prototype.updateIndex = function(uid, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            new Index(this.config, uid).update(options)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete an index\r\n     * @memberof MeiliSearch\r\n     * @method deleteIndex\r\n     * @param {string} uid The index UID\r\n     * @returns {Promise<void>} Promise which resolves when index is deleted successfully\r\n     */ Client.prototype.deleteIndex = function(uid) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            new Index(this.config, uid)[\"delete\"]()\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Deletes an index if it already exists.\r\n     * @memberof MeiliSearch\r\n     * @method deleteIndexIfExists\r\n     * @param {string} uid The index UID\r\n     * @returns {Promise<boolean>} Promise which resolves to true when index exists and is deleted successfully, otherwise false if it does not exist\r\n     */ Client.prototype.deleteIndexIfExists = function(uid) {\n        return __awaiter(this, void 0, void 0, function() {\n            var e_1;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        _a.trys.push([\n                            0,\n                            2,\n                            ,\n                            3\n                        ]);\n                        return [\n                            4 /*yield*/ ,\n                            this.deleteIndex(uid)\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                    case 2:\n                        e_1 = _a.sent();\n                        if (e_1.code === \"index_not_found\" /* INDEX_NOT_FOUND */ ) {\n                            return [\n                                2 /*return*/ ,\n                                false\n                            ];\n                        }\n                        throw e_1;\n                    case 3:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// TASKS\n    ///\n    /**\r\n     * Get the list of all client tasks\r\n     * @memberof MeiliSearch\r\n     * @method getTasks\r\n     * @returns {Promise<Result<Task[]>>} - Promise returning all tasks\r\n     */ Client.prototype.getTasks = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.getClientTasks()\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get one task on the client scope\r\n     * @memberof MeiliSearch\r\n     * @method getTask\r\n     * @param {number} taskId - Task identifier\r\n     * @returns {Promise<Task>} - Promise returning a task\r\n     */ Client.prototype.getTask = function(taskId) {\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.getClientTask(taskId)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Wait for a batch of tasks to be processed.\r\n     * @memberof MeiliSearch\r\n     * @method waitForTasks\r\n     * @param {number[]} taskIds - Tasks identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Result<Task[]>>} - Promise returning an array of tasks\r\n     */ Client.prototype.waitForTasks = function(taskIds, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.waitForClientTasks(taskIds, {\n                                timeOutMs: timeOutMs,\n                                intervalMs: intervalMs\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _e.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method waitForTask\r\n     * @param {number} taskId - Task identifier\r\n     * @param {WaitOptions} waitOptions - Options on timeout and interval\r\n     *\r\n     * @returns {Promise<Task>} - Promise returning an array of tasks\r\n     */ Client.prototype.waitForTask = function(taskId, _a) {\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\n        return __awaiter(this, void 0, void 0, function() {\n            return __generator(this, function(_e) {\n                switch(_e.label){\n                    case 0:\n                        return [\n                            4 /*yield*/ ,\n                            this.tasks.waitForClientTask(taskId, {\n                                timeOutMs: timeOutMs,\n                                intervalMs: intervalMs\n                            })\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _e.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// KEYS\n    ///\n    /**\r\n     * Get all API keys\r\n     * @memberof MeiliSearch\r\n     * @method getKeys\r\n     * @returns {Promise<Keys>} Promise returning an object with keys\r\n     */ Client.prototype.getKeys = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"keys\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get one API key\r\n     * @memberof MeiliSearch\r\n     * @method getKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @returns {Promise<Keys>} Promise returning a key\r\n     */ Client.prototype.getKey = function(key) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"keys/\".concat(key);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Create one API key\r\n     * @memberof MeiliSearch\r\n     * @method createKey\r\n     *\r\n     * @param {KeyPayload} options - Key options\r\n     * @returns {Promise<Key>} Promise returning an object with keys\r\n     */ Client.prototype.createKey = function(options) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"keys\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url, options)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Update one API key\r\n     * @memberof MeiliSearch\r\n     * @method updateKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @param {KeyPayload} options - Key options\r\n     * @returns {Promise<Key>} Promise returning an object with keys\r\n     */ Client.prototype.updateKey = function(key, options) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"keys/\".concat(key);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.patch(url, options)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Delete one API key\r\n     * @memberof MeiliSearch\r\n     * @method deleteKey\r\n     *\r\n     * @param {string} key - Key\r\n     * @returns {Promise<Void>}\r\n     */ Client.prototype.deleteKey = function(key) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"keys/\".concat(key);\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest[\"delete\"](url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// HEALTH\n    ///\n    /**\r\n     * Checks if the server is healthy, otherwise an error will be thrown.\r\n     * @memberof MeiliSearch\r\n     * @method health\r\n     * @returns {Promise<Health>} Promise returning an object with health details\r\n     */ Client.prototype.health = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"health\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Checks if the server is healthy, return true or false.\r\n     * @memberof MeiliSearch\r\n     * @method isHealthy\r\n     * @returns {Promise<boolean>} Promise returning a boolean\r\n     */ Client.prototype.isHealthy = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        _a.trys.push([\n                            0,\n                            2,\n                            ,\n                            3\n                        ]);\n                        url = \"health\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            true\n                        ];\n                    case 2:\n                        _a.sent();\n                        return [\n                            2 /*return*/ ,\n                            false\n                        ];\n                    case 3:\n                        return [\n                            2 /*return*/ \n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// STATS\n    ///\n    /**\r\n     * Get the stats of all the database\r\n     * @memberof MeiliSearch\r\n     * @method getStats\r\n     * @returns {Promise<Stats>} Promise returning object of all the stats\r\n     */ Client.prototype.getStats = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"stats\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// VERSION\n    ///\n    /**\r\n     * Get the version of MeiliSearch\r\n     * @memberof MeiliSearch\r\n     * @method getVersion\r\n     * @returns {Promise<Version>} Promise returning object with version details\r\n     */ Client.prototype.getVersion = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"version\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    ///\n    /// DUMPS\n    ///\n    /**\r\n     * Triggers a dump creation process\r\n     * @memberof MeiliSearch\r\n     * @method createDump\r\n     * @returns {Promise<EnqueuedDump>} Promise returning object of the enqueued update\r\n     */ Client.prototype.createDump = function() {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"dumps\";\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.post(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Get the status of a dump creation process\r\n     * @memberof MeiliSearch\r\n     * @method getDumpStatus\r\n     * @param {string} dumpUid Dump UID\r\n     * @returns {Promise<EnqueuedDump>} Promise returning object of the enqueued update\r\n     */ Client.prototype.getDumpStatus = function(dumpUid) {\n        return __awaiter(this, void 0, void 0, function() {\n            var url;\n            return __generator(this, function(_a) {\n                switch(_a.label){\n                    case 0:\n                        url = \"dumps/\".concat(dumpUid, \"/status\");\n                        return [\n                            4 /*yield*/ ,\n                            this.httpRequest.get(url)\n                        ];\n                    case 1:\n                        return [\n                            2 /*return*/ ,\n                            _a.sent()\n                        ];\n                }\n            });\n        });\n    };\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */ Client.prototype.generateTenantToken = function(_searchRules, _options) {\n        var error = new Error();\n        throw new Error(\"Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \\n \".concat(error.stack, \".\"));\n    };\n    return Client;\n}();\nfunction encode64(data) {\n    return Buffer.from(JSON.stringify(data)).toString(\"base64\");\n}\n/**\r\n * Create the header of the token.\r\n *\r\n * @param {String} apiKey API key used to sign the token.\r\n * @param {String} encodedHeader Header of the token in base64.\r\n * @param {String} encodedPayload Payload of the token in base64.\r\n * @returns {String} The signature of the token in base64.\r\n */ function sign(apiKey, encodedHeader, encodedPayload) {\n    return crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac(\"sha256\", apiKey).update(\"\".concat(encodedHeader, \".\").concat(encodedPayload)).digest(\"base64\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n/**\r\n * Create the header of the token.\r\n *\r\n * @returns {String} The header encoded in base64.\r\n */ function createHeader() {\n    var header = {\n        alg: \"HS256\",\n        typ: \"JWT\"\n    };\n    return encode64(header).replace(/=/g, \"\");\n}\n/**\r\n * Validate the parameter used for the payload of the token.\r\n *\r\n * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n * @param {String} apiKey Api key used as issuer of the token.\r\n * @param {Date | undefined} expiresAt Date at which the token expires.\r\n */ function validatePayload(payloadParams) {\n    var searchRules = payloadParams.searchRules, apiKey = payloadParams.apiKey, expiresAt = payloadParams.expiresAt;\n    var error = new Error();\n    if (expiresAt) {\n        if (!(expiresAt instanceof Date) || expiresAt.getTime() < Date.now()) {\n            throw new Error(\"Meilisearch: When the expiresAt field in the token generation has a value, it must be a date set in the future and not in the past. \\n \".concat(error.stack, \".\"));\n        }\n    }\n    if (searchRules) {\n        if (!(typeof searchRules === \"object\" || Array.isArray(searchRules))) {\n            throw new Error(\"Meilisearch: The search rules added in the token generation must be of type array or object. \\n \".concat(error.stack, \".\"));\n        }\n    }\n    if (!apiKey || typeof apiKey !== \"string\") {\n        throw new Error(\"Meilisearch: The API key used for the token generation must exist and be of type string. \\n \".concat(error.stack, \".\"));\n    }\n}\n/**\r\n * Create the payload of the token.\r\n *\r\n * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n * @param {String} apiKey Api key used as issuer of the token.\r\n * @param {Date | undefined} expiresAt Date at which the token expires.\r\n * @returns {String} The payload encoded in base64.\r\n */ function createPayload(payloadParams) {\n    var searchRules = payloadParams.searchRules, apiKey = payloadParams.apiKey, expiresAt = payloadParams.expiresAt;\n    validatePayload(payloadParams);\n    var payload = {\n        searchRules: searchRules,\n        apiKeyPrefix: apiKey.substring(0, 8),\n        exp: expiresAt === null || expiresAt === void 0 ? void 0 : expiresAt.getTime()\n    };\n    return encode64(payload).replace(/=/g, \"\");\n}\nvar Token = /** @class */ function() {\n    function Token(config) {\n        this.config = config;\n    }\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */ Token.prototype.generateTenantToken = function(searchRules, options) {\n        var apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || this.config.apiKey || \"\";\n        var expiresAt = options === null || options === void 0 ? void 0 : options.expiresAt;\n        var encodedHeader = createHeader();\n        var encodedPayload = createPayload({\n            searchRules: searchRules,\n            apiKey: apiKey,\n            expiresAt: expiresAt\n        });\n        var signature = sign(apiKey, encodedHeader, encodedPayload);\n        return \"\".concat(encodedHeader, \".\").concat(encodedPayload, \".\").concat(signature);\n    };\n    return Token;\n}();\nvar MeiliSearch = /** @class */ function(_super) {\n    __extends(MeiliSearch, _super);\n    function MeiliSearch(config) {\n        var _this = _super.call(this, config) || this;\n        _this.tokens = new Token(config);\n        return _this;\n    }\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @memberof MeiliSearch\r\n     * @method generateTenantToken\r\n     * @param {SearchRules} searchRules Search rules that are applied to every search.\r\n     * @param {TokenOptions} options Token options to customize some aspect of the token.\r\n     * @returns {String} The token in JWT format.\r\n     */ MeiliSearch.prototype.generateTenantToken = function(searchRules, options) {\n        if (true) {\n            return this.tokens.generateTenantToken(searchRules, options);\n        }\n        return _super.prototype.generateTenantToken.call(this, searchRules, options);\n    };\n    return MeiliSearch;\n}(Client);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVpbGlzZWFyY2gvZGlzdC9idW5kbGVzL21laWxpc2VhcmNoLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEI7QUFDRjtBQUU1Qjs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsMkJBQTJCLEdBRTNCLElBQUlDLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFBRTtJQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztBQUM1QjtBQUVBLFNBQVNTLFVBQVVWLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlVLFVBQVUseUJBQXlCQyxPQUFPWCxLQUFLO0lBQzdERixjQUFjQyxHQUFHQztJQUNqQixTQUFTWTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHZDtJQUFHO0lBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT2EsTUFBTSxDQUFDZCxLQUFNWSxDQUFBQSxHQUFHTixTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJTSxJQUFHO0FBQ3RGO0FBRUEsSUFBSUcsV0FBVztJQUNYQSxXQUFXZCxPQUFPZSxNQUFNLElBQUksU0FBU0QsU0FBU0UsQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJZCxLQUFLYSxFQUFHLElBQUlqQixPQUFPSyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDVSxHQUFHYixJQUFJWSxDQUFDLENBQUNaLEVBQUUsR0FBR2EsQ0FBQyxDQUFDYixFQUFFO1FBQ2hGO1FBQ0EsT0FBT1k7SUFDWDtJQUNBLE9BQU9GLFNBQVNRLEtBQUssQ0FBQyxJQUFJLEVBQUVGO0FBQ2hDO0FBRUEsU0FBU0csVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVTCxLQUFLLENBQUNFLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFFQSxTQUFTTSxZQUFZakIsT0FBTyxFQUFFa0IsSUFBSTtJQUM5QixJQUFJQyxJQUFJO1FBQUVDLE9BQU87UUFBR0MsTUFBTTtZQUFhLElBQUk3QixDQUFDLENBQUMsRUFBRSxHQUFHLEdBQUcsTUFBTUEsQ0FBQyxDQUFDLEVBQUU7WUFBRSxPQUFPQSxDQUFDLENBQUMsRUFBRTtRQUFFO1FBQUc4QixNQUFNLEVBQUU7UUFBRUMsS0FBSyxFQUFFO0lBQUMsR0FBR0MsR0FBR0MsR0FBR2pDLEdBQUdrQztJQUMvRyxPQUFPQSxJQUFJO1FBQUVmLE1BQU1nQixLQUFLO1FBQUksU0FBU0EsS0FBSztRQUFJLFVBQVVBLEtBQUs7SUFBRyxHQUFHLE9BQU9DLFdBQVcsY0FBZUYsQ0FBQUEsQ0FBQyxDQUFDRSxPQUFPQyxRQUFRLENBQUMsR0FBRztRQUFhLE9BQU8sSUFBSTtJQUFFLElBQUlIO0lBQ3ZKLFNBQVNDLEtBQUtoQyxDQUFDO1FBQUksT0FBTyxTQUFVbUMsQ0FBQztZQUFJLE9BQU9wQixLQUFLO2dCQUFDZjtnQkFBR21DO2FBQUU7UUFBRztJQUFHO0lBQ2pFLFNBQVNwQixLQUFLcUIsRUFBRTtRQUNaLElBQUlQLEdBQUcsTUFBTSxJQUFJdkMsVUFBVTtRQUMzQixNQUFPa0MsRUFBRyxJQUFJO1lBQ1YsSUFBSUssSUFBSSxHQUFHQyxLQUFNakMsQ0FBQUEsSUFBSXVDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSU4sQ0FBQyxDQUFDLFNBQVMsR0FBR00sRUFBRSxDQUFDLEVBQUUsR0FBR04sQ0FBQyxDQUFDLFFBQVEsSUFBSyxFQUFDakMsSUFBSWlDLENBQUMsQ0FBQyxTQUFTLEtBQUtqQyxFQUFFVCxJQUFJLENBQUMwQyxJQUFJLEtBQUtBLEVBQUVkLElBQUksS0FBSyxDQUFDLENBQUNuQixJQUFJQSxFQUFFVCxJQUFJLENBQUMwQyxHQUFHTSxFQUFFLENBQUMsRUFBRSxHQUFHaEIsSUFBSSxFQUFFLE9BQU92QjtZQUMzSixJQUFJaUMsSUFBSSxHQUFHakMsR0FBR3VDLEtBQUs7Z0JBQUNBLEVBQUUsQ0FBQyxFQUFFLEdBQUc7Z0JBQUd2QyxFQUFFYSxLQUFLO2FBQUM7WUFDdkMsT0FBUTBCLEVBQUUsQ0FBQyxFQUFFO2dCQUNULEtBQUs7Z0JBQUcsS0FBSztvQkFBR3ZDLElBQUl1QztvQkFBSTtnQkFDeEIsS0FBSztvQkFBR1osRUFBRUMsS0FBSztvQkFBSSxPQUFPO3dCQUFFZixPQUFPMEIsRUFBRSxDQUFDLEVBQUU7d0JBQUVoQixNQUFNO29CQUFNO2dCQUN0RCxLQUFLO29CQUFHSSxFQUFFQyxLQUFLO29CQUFJSyxJQUFJTSxFQUFFLENBQUMsRUFBRTtvQkFBRUEsS0FBSzt3QkFBQztxQkFBRTtvQkFBRTtnQkFDeEMsS0FBSztvQkFBR0EsS0FBS1osRUFBRUksR0FBRyxDQUFDUyxHQUFHO29CQUFJYixFQUFFRyxJQUFJLENBQUNVLEdBQUc7b0JBQUk7Z0JBQ3hDO29CQUNJLElBQUksQ0FBRXhDLENBQUFBLElBQUkyQixFQUFFRyxJQUFJLEVBQUU5QixJQUFJQSxFQUFFSyxNQUFNLEdBQUcsS0FBS0wsQ0FBQyxDQUFDQSxFQUFFSyxNQUFNLEdBQUcsRUFBRSxLQUFNa0MsQ0FBQUEsRUFBRSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxFQUFFLENBQUMsRUFBRSxLQUFLLElBQUk7d0JBQUVaLElBQUk7d0JBQUc7b0JBQVU7b0JBQzNHLElBQUlZLEVBQUUsQ0FBQyxFQUFFLEtBQUssS0FBTSxFQUFDdkMsS0FBTXVDLEVBQUUsQ0FBQyxFQUFFLEdBQUd2QyxDQUFDLENBQUMsRUFBRSxJQUFJdUMsRUFBRSxDQUFDLEVBQUUsR0FBR3ZDLENBQUMsQ0FBQyxFQUFFLEdBQUk7d0JBQUUyQixFQUFFQyxLQUFLLEdBQUdXLEVBQUUsQ0FBQyxFQUFFO3dCQUFFO29CQUFPO29CQUNyRixJQUFJQSxFQUFFLENBQUMsRUFBRSxLQUFLLEtBQUtaLEVBQUVDLEtBQUssR0FBRzVCLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQUUyQixFQUFFQyxLQUFLLEdBQUc1QixDQUFDLENBQUMsRUFBRTt3QkFBRUEsSUFBSXVDO3dCQUFJO29CQUFPO29CQUNwRSxJQUFJdkMsS0FBSzJCLEVBQUVDLEtBQUssR0FBRzVCLENBQUMsQ0FBQyxFQUFFLEVBQUU7d0JBQUUyQixFQUFFQyxLQUFLLEdBQUc1QixDQUFDLENBQUMsRUFBRTt3QkFBRTJCLEVBQUVJLEdBQUcsQ0FBQ1UsSUFBSSxDQUFDRjt3QkFBSztvQkFBTztvQkFDbEUsSUFBSXZDLENBQUMsQ0FBQyxFQUFFLEVBQUUyQixFQUFFSSxHQUFHLENBQUNTLEdBQUc7b0JBQ25CYixFQUFFRyxJQUFJLENBQUNVLEdBQUc7b0JBQUk7WUFDdEI7WUFDQUQsS0FBS2IsS0FBS25DLElBQUksQ0FBQ2lCLFNBQVNtQjtRQUM1QixFQUFFLE9BQU9QLEdBQUc7WUFBRW1CLEtBQUs7Z0JBQUM7Z0JBQUduQjthQUFFO1lBQUVhLElBQUk7UUFBRyxTQUFVO1lBQUVELElBQUloQyxJQUFJO1FBQUc7UUFDekQsSUFBSXVDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsR0FBRyxNQUFNQSxFQUFFLENBQUMsRUFBRTtRQUFFLE9BQU87WUFBRTFCLE9BQU8wQixFQUFFLENBQUMsRUFBRSxHQUFHQSxFQUFFLENBQUMsRUFBRSxHQUFHLEtBQUs7WUFBR2hCLE1BQU07UUFBSztJQUNuRjtBQUNKO0FBRUEsSUFBSW1CLGdDQUFnQyxXQUFXLEdBQUksU0FBVUMsTUFBTTtJQUMvRG5ELFVBQVVrRCwrQkFBK0JDO0lBQ3pDLFNBQVNELDhCQUE4QkUsT0FBTyxFQUFFbEIsSUFBSSxFQUFFbUIsR0FBRyxFQUFFQyxLQUFLO1FBQzVELElBQUlDLFFBQVEsSUFBSTtRQUNoQixJQUFJQyxJQUFJQyxJQUFJQztRQUNaSCxRQUFRSixPQUFPcEQsSUFBSSxDQUFDLElBQUksRUFBRXFELFlBQVksSUFBSTtRQUMxQ0csTUFBTUksSUFBSSxHQUFHO1FBQ2JKLE1BQU1LLElBQUksR0FBRztRQUNiLElBQUkxQixnQkFBZ0IyQixVQUFVO1lBQzFCTixNQUFNSCxPQUFPLEdBQUdsQixLQUFLNEIsVUFBVTtZQUMvQlAsTUFBTVEsVUFBVSxHQUFHN0IsS0FBSzhCLE1BQU07UUFDbEM7UUFDQSxJQUFJOUIsZ0JBQWdCK0IsT0FBTztZQUN2QlYsTUFBTVcsS0FBSyxHQUFHaEMsS0FBS2dDLEtBQUs7WUFDeEJYLE1BQU1ZLElBQUksR0FBR2pDLEtBQUtpQyxJQUFJO1FBQzFCO1FBQ0EsSUFBSWIsT0FBTztZQUNQQyxNQUFNRCxLQUFLLEdBQUdBO1lBQ2RDLE1BQU1ELEtBQUssR0FBRyxDQUFDRSxLQUFLRCxNQUFNRCxLQUFLLE1BQU0sUUFBUUUsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHWSxPQUFPLENBQUMsMEJBQTBCYixNQUFNSSxJQUFJO1lBQ3JISixNQUFNRCxLQUFLLEdBQUcsQ0FBQ0csS0FBS0YsTUFBTUQsS0FBSyxNQUFNLFFBQVFHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1csT0FBTyxDQUFDLG1CQUFtQixjQUFjQyxNQUFNLENBQUNoQixLQUFLO1lBQzlIRSxNQUFNRCxLQUFLLEdBQUcsQ0FBQ0ksS0FBS0gsTUFBTUQsS0FBSyxNQUFNLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1UsT0FBTyxDQUFDLGFBQWEsY0FBY0MsTUFBTSxDQUFDaEI7UUFDdkgsT0FDSztZQUNELElBQUlZLE1BQU1LLGlCQUFpQixFQUFFO2dCQUN6QkwsTUFBTUssaUJBQWlCLENBQUNmLE9BQU9MO1lBQ25DO1FBQ0o7UUFDQSxPQUFPSztJQUNYO0lBQ0EsT0FBT0w7QUFDWCxFQUFFZTtBQUVGLElBQUlNLHNCQUFzQixXQUFXLEdBQUksU0FBVXBCLE1BQU07SUFDckRuRCxVQUFVd0UsU0FBU3JCO0lBQ25CLFNBQVNxQixRQUFRQyxLQUFLLEVBQUVULE1BQU07UUFDMUIsSUFBSVQsUUFBUUosT0FBT3BELElBQUksQ0FBQyxJQUFJLEVBQUUwRSxNQUFNckIsT0FBTyxLQUFLLElBQUk7UUFDcERHLE1BQU1JLElBQUksR0FBRztRQUNiSixNQUFNWSxJQUFJLEdBQUdNLE1BQU1OLElBQUk7UUFDdkJaLE1BQU1LLElBQUksR0FBR2EsTUFBTWIsSUFBSTtRQUN2QkwsTUFBTW1CLElBQUksR0FBR0QsTUFBTUMsSUFBSTtRQUN2Qm5CLE1BQU1ILE9BQU8sR0FBR3FCLE1BQU1yQixPQUFPO1FBQzdCRyxNQUFNb0IsVUFBVSxHQUFHWDtRQUNuQiw2RUFBNkU7UUFDN0V4RSxPQUFPQyxjQUFjLENBQUM4RCxPQUFPZ0Isb0JBQW9CMUUsU0FBUztRQUMxRCxJQUFJb0UsTUFBTUssaUJBQWlCLEVBQUU7WUFDekJMLE1BQU1LLGlCQUFpQixDQUFDZixPQUFPZ0I7UUFDbkM7UUFDQSxPQUFPaEI7SUFDWDtJQUNBLE9BQU9pQjtBQUNYLEVBQUVQO0FBRUYsU0FBU1cseUJBQXlCQyxRQUFRO0lBQ3RDLE9BQU85RCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLElBQUkrRDtRQUNKLE9BQU83QyxZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtZQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztnQkFDWixLQUFLO29CQUNELElBQUksQ0FBQyxDQUFDeUMsU0FBU0UsRUFBRSxFQUFFLE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFJO3FCQUFFO29CQUMxQ0QsTUFBTSxLQUFLO29CQUNYdEIsR0FBR3BCLEtBQUssR0FBRztnQkFDZixLQUFLO29CQUNEb0IsR0FBR2xCLElBQUksQ0FBQ1csSUFBSSxDQUFDO3dCQUFDO3dCQUFHOzt3QkFBSztxQkFBRTtvQkFDeEIsT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUk0QixTQUFTRyxJQUFJO3FCQUFHO2dCQUN6QyxLQUFLO29CQUNERixNQUFNdEIsR0FBR25CLElBQUk7b0JBQ2IsT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUk7cUJBQUU7Z0JBQzNCLEtBQUs7b0JBQ0RtQixHQUFHbkIsSUFBSTtvQkFDUCxNQUFNLElBQUlhLDhCQUE4QjJCLFNBQVNmLFVBQVUsRUFBRWUsVUFBVUEsU0FBU3hCLEdBQUc7Z0JBQ3ZGLEtBQUs7b0JBQUcsTUFBTSxJQUFJa0Isb0JBQW9CTyxLQUFLRCxTQUFTYixNQUFNO2dCQUMxRCxLQUFLO29CQUFHLE9BQU87d0JBQUMsRUFBRSxRQUFRO3dCQUFJYTtxQkFBUztZQUMzQztRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVNJLGlCQUFpQkosUUFBUSxFQUFFdkIsS0FBSyxFQUFFRCxHQUFHO0lBQzFDLElBQUl3QixTQUFTakIsSUFBSSxLQUFLLHVCQUF1QjtRQUN6QyxNQUFNLElBQUlWLDhCQUE4QjJCLFNBQVN6QixPQUFPLEVBQUV5QixVQUFVeEIsS0FBS0M7SUFDN0U7SUFDQSxNQUFNdUI7QUFDVjtBQUVBLElBQUlLLG1CQUFtQixXQUFXLEdBQUksU0FBVS9CLE1BQU07SUFDbERuRCxVQUFVa0Ysa0JBQWtCL0I7SUFDNUIsU0FBUytCLGlCQUFpQjlCLE9BQU87UUFDN0IsSUFBSUcsUUFBUUosT0FBT3BELElBQUksQ0FBQyxJQUFJLEVBQUVxRCxZQUFZLElBQUk7UUFDOUNHLE1BQU1JLElBQUksR0FBRztRQUNiSixNQUFNSyxJQUFJLEdBQUc7UUFDYixJQUFJSyxNQUFNSyxpQkFBaUIsRUFBRTtZQUN6QkwsTUFBTUssaUJBQWlCLENBQUNmLE9BQU8yQjtRQUNuQztRQUNBLE9BQU8zQjtJQUNYO0lBQ0EsT0FBTzJCO0FBQ1gsRUFBRWpCO0FBRUYsSUFBSWtCLDBCQUEwQixXQUFXLEdBQUksU0FBVWhDLE1BQU07SUFDekRuRCxVQUFVbUYseUJBQXlCaEM7SUFDbkMsU0FBU2dDLHdCQUF3Qi9CLE9BQU87UUFDcEMsSUFBSUcsUUFBUUosT0FBT3BELElBQUksQ0FBQyxJQUFJLEVBQUVxRCxZQUFZLElBQUk7UUFDOUNHLE1BQU1JLElBQUksR0FBRztRQUNiSixNQUFNSyxJQUFJLEdBQUdMLE1BQU1uRCxXQUFXLENBQUN1RCxJQUFJO1FBQ25DLElBQUlNLE1BQU1LLGlCQUFpQixFQUFFO1lBQ3pCTCxNQUFNSyxpQkFBaUIsQ0FBQ2YsT0FBTzRCO1FBQ25DO1FBQ0EsT0FBTzVCO0lBQ1g7SUFDQSxPQUFPNEI7QUFDWCxFQUFFbEI7QUFFRjs7Q0FFQyxHQUNELFNBQVNtQiwwQkFBMEJDLEdBQUc7SUFDbEMsT0FBTzdGLE9BQU84RixPQUFPLENBQUNELEtBQUtFLE1BQU0sQ0FBQyxTQUFVQyxHQUFHLEVBQUVDLFFBQVE7UUFDckQsSUFBSUMsTUFBTUQsUUFBUSxDQUFDLEVBQUUsRUFBRUUsTUFBTUYsUUFBUSxDQUFDLEVBQUU7UUFDeEMsSUFBSUUsUUFBUUMsV0FDUkosR0FBRyxDQUFDRSxJQUFJLEdBQUdDO1FBQ2YsT0FBT0g7SUFDWCxHQUFHLENBQUM7QUFDUjtBQUNBLFNBQVNLLE1BQU1DLEVBQUU7SUFDYixPQUFPL0UsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPa0IsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7WUFDakMsT0FBUUEsR0FBR3BCLEtBQUs7Z0JBQ1osS0FBSztvQkFBRyxPQUFPO3dCQUFDLEVBQUUsT0FBTzt3QkFBSSxJQUFJYixRQUFRLFNBQVVELE9BQU87NEJBQUksT0FBT3lFLFdBQVd6RSxTQUFTd0U7d0JBQUs7cUJBQUc7Z0JBQ2pHLEtBQUs7b0JBQUcsT0FBTzt3QkFBQyxFQUFFLFFBQVE7d0JBQUl0QyxHQUFHbkIsSUFBSTtxQkFBRztZQUM1QztRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVMyRCx3QkFBd0JDLElBQUk7SUFDakMsSUFBSSxDQUFFQSxDQUFBQSxLQUFLQyxVQUFVLENBQUMsZUFBZUQsS0FBS0MsVUFBVSxDQUFDLFVBQVMsR0FBSTtRQUM5RCxPQUFPLFVBQVU3QixNQUFNLENBQUM0QjtJQUM1QjtJQUNBLE9BQU9BO0FBQ1g7QUFDQSxTQUFTRSxpQkFBaUI5QyxHQUFHO0lBQ3pCLElBQUksQ0FBQ0EsSUFBSStDLFFBQVEsQ0FBQyxNQUFNO1FBQ3BCL0MsT0FBTztJQUNYO0lBQ0EsT0FBT0E7QUFDWDtBQUVBLFNBQVNnRCxpQkFBaUJKLElBQUk7SUFDMUIsSUFBSTtRQUNBQSxPQUFPRCx3QkFBd0JDO1FBQy9CQSxPQUFPRSxpQkFBaUJGO1FBQ3hCLE9BQU9BO0lBQ1gsRUFDQSxPQUFPckUsR0FBRztRQUNOLE1BQU0sSUFBSXNELGlCQUFpQjtJQUMvQjtBQUNKO0FBQ0EsSUFBSW9CLGVBQWUsV0FBVyxHQUFJO0lBQzlCLFNBQVNBLGFBQWFDLE1BQU07UUFDeEIsSUFBSSxDQUFDQyxPQUFPLEdBQUdoSCxPQUFPZSxNQUFNLENBQUMsQ0FBQyxHQUFHZ0csT0FBT0MsT0FBTyxJQUFJLENBQUMsSUFBSSw4QkFBOEI7UUFDdEYsSUFBSSxDQUFDQSxPQUFPLENBQUMsZUFBZSxHQUFHO1FBQy9CLElBQUlELE9BQU9FLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQ0QsT0FBTyxDQUFDLGdCQUFnQixHQUFHLFVBQVVuQyxNQUFNLENBQUNrQyxPQUFPRSxNQUFNO1FBQ2xFO1FBQ0EsSUFBSTtZQUNBLElBQUlSLE9BQU9JLGlCQUFpQkUsT0FBT04sSUFBSTtZQUN2QyxJQUFJLENBQUM1QyxHQUFHLEdBQUcsSUFBSXFELElBQUlUO1FBQ3ZCLEVBQ0EsT0FBT3JFLEdBQUc7WUFDTixNQUFNLElBQUlzRCxpQkFBaUI7UUFDL0I7SUFDSjtJQUNBb0IsYUFBYXpHLFNBQVMsQ0FBQzhHLE9BQU8sR0FBRyxTQUFVbkQsRUFBRTtRQUN6QyxJQUFJb0QsU0FBU3BELEdBQUdvRCxNQUFNLEVBQUV2RCxNQUFNRyxHQUFHSCxHQUFHLEVBQUV3RCxTQUFTckQsR0FBR3FELE1BQU0sRUFBRTNFLE9BQU9zQixHQUFHdEIsSUFBSSxFQUFFcUUsU0FBUy9DLEdBQUcrQyxNQUFNO1FBQzVGLE9BQU94RixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUkrRixjQUFjQyxlQUFlbEMsVUFBVW1DLFlBQVlDLFlBQVlDLEtBQUs1RDtZQUN4RSxPQUFPckIsWUFBWSxJQUFJLEVBQUUsU0FBVXdCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdyQixLQUFLO29CQUNaLEtBQUs7d0JBQ0QwRSxlQUFlLElBQUlKLElBQUlyRCxLQUFLLElBQUksQ0FBQ0EsR0FBRzt3QkFDcEMsSUFBSXdELFFBQVE7NEJBQ1JFLGdCQUFnQixJQUFJSTs0QkFDcEIzSCxPQUFPNEgsSUFBSSxDQUFDUCxRQUNQUSxNQUFNLENBQUMsU0FBVUMsQ0FBQztnQ0FBSSxPQUFPVCxNQUFNLENBQUNTLEVBQUUsS0FBSzs0QkFBTSxHQUNqREMsR0FBRyxDQUFDLFNBQVVELENBQUM7Z0NBQUksT0FBT1AsY0FBY1MsR0FBRyxDQUFDRixHQUFHVCxNQUFNLENBQUNTLEVBQUU7NEJBQUc7NEJBQ2hFUixhQUFhVyxNQUFNLEdBQUdWLGNBQWNXLFFBQVE7d0JBQ2hEO3dCQUNBakUsR0FBR3JCLEtBQUssR0FBRztvQkFDZixLQUFLO3dCQUNEcUIsR0FBR25CLElBQUksQ0FBQ1csSUFBSSxDQUFDOzRCQUFDOzRCQUFHOzs0QkFBSzt5QkFBRTt3QkFDeEIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUkwRSxNQUFNYixhQUFhWSxRQUFRLElBQUlwSCxTQUFTQSxTQUFTLENBQUMsR0FBR2lHLFNBQVM7Z0NBQUVLLFFBQVFBO2dDQUFRMUUsTUFBTTBGLEtBQUtDLFNBQVMsQ0FBQzNGO2dDQUFPc0UsU0FBUyxJQUFJLENBQUNBLE9BQU87NEJBQUMsSUFBSXhFLElBQUksQ0FBQyxTQUFVOEYsR0FBRztnQ0FBSSxPQUFPbEQseUJBQXlCa0Q7NEJBQU07eUJBQUc7b0JBQzlOLEtBQUs7d0JBQ0RqRCxXQUFXcEIsR0FBR3BCLElBQUk7d0JBQ2xCLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJd0MsU0FBU2tELElBQUk7eUJBQUc7b0JBQ3pDLEtBQUs7d0JBQ0RmLGFBQWF2RCxHQUFHcEIsSUFBSTt3QkFDcEIsSUFBSTs0QkFDQTRFLGFBQWFXLEtBQUtJLEtBQUssQ0FBQ2hCOzRCQUN4QixPQUFPO2dDQUFDLEVBQUUsUUFBUTtnQ0FBSUM7NkJBQVc7d0JBQ3JDLEVBQ0EsT0FBTzlFLEdBQUc7NEJBQ04sT0FBTztnQ0FBQyxFQUFFLFFBQVE7NkJBQUc7d0JBQ3pCO3dCQUNBLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFFO29CQUMzQixLQUFLO3dCQUNEK0UsTUFBTXpELEdBQUdwQixJQUFJO3dCQUNiaUIsUUFBUTRELElBQUk1RCxLQUFLO3dCQUNqQjJCLGlCQUFpQmlDLEtBQUs1RCxPQUFPd0QsYUFBYVksUUFBUTt3QkFDbEQsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQzNCLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7eUJBQUc7Z0JBQ2pDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FwQixhQUFhekcsU0FBUyxDQUFDb0ksR0FBRyxHQUFHLFNBQVU1RSxHQUFHLEVBQUV3RCxNQUFNLEVBQUVOLE1BQU07UUFDdEQsT0FBT3hGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3VFLE9BQU8sQ0FBQztnQ0FDbENDLFFBQVE7Z0NBQ1J2RCxLQUFLQTtnQ0FDTHdELFFBQVFBO2dDQUNSTixRQUFRQTs0QkFDWjt5QkFBRztvQkFDUCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJL0MsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FpRSxhQUFhekcsU0FBUyxDQUFDcUksSUFBSSxHQUFHLFNBQVU3RSxHQUFHLEVBQUU4RSxJQUFJLEVBQUV0QixNQUFNLEVBQUVOLE1BQU07UUFDN0QsT0FBT3hGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3VFLE9BQU8sQ0FBQztnQ0FDbENDLFFBQVE7Z0NBQ1J2RCxLQUFLQTtnQ0FDTG5CLE1BQU1pRztnQ0FDTnRCLFFBQVFBO2dDQUNSTixRQUFRQTs0QkFDWjt5QkFBRztvQkFDUCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJL0MsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FpRSxhQUFhekcsU0FBUyxDQUFDdUksR0FBRyxHQUFHLFNBQVUvRSxHQUFHLEVBQUU4RSxJQUFJLEVBQUV0QixNQUFNLEVBQUVOLE1BQU07UUFDNUQsT0FBT3hGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3VFLE9BQU8sQ0FBQztnQ0FDbENDLFFBQVE7Z0NBQ1J2RCxLQUFLQTtnQ0FDTG5CLE1BQU1pRztnQ0FDTnRCLFFBQVFBO2dDQUNSTixRQUFRQTs0QkFDWjt5QkFBRztvQkFDUCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJL0MsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FpRSxhQUFhekcsU0FBUyxDQUFDd0ksS0FBSyxHQUFHLFNBQVVoRixHQUFHLEVBQUU4RSxJQUFJLEVBQUV0QixNQUFNLEVBQUVOLE1BQU07UUFDOUQsT0FBT3hGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3VFLE9BQU8sQ0FBQztnQ0FDbENDLFFBQVE7Z0NBQ1J2RCxLQUFLQTtnQ0FDTG5CLE1BQU1pRztnQ0FDTnRCLFFBQVFBO2dDQUNSTixRQUFRQTs0QkFDWjt5QkFBRztvQkFDUCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJL0MsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0FpRSxhQUFhekcsU0FBUyxDQUFDLFNBQVMsR0FBRyxTQUFVd0QsR0FBRyxFQUFFOEUsSUFBSSxFQUFFdEIsTUFBTSxFQUFFTixNQUFNO1FBQ2xFLE9BQU94RixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUN1RSxPQUFPLENBQUM7Z0NBQ2xDQyxRQUFRO2dDQUNSdkQsS0FBS0E7Z0NBQ0xuQixNQUFNaUc7Z0NBQ050QixRQUFRQTtnQ0FDUk4sUUFBUUE7NEJBQ1o7eUJBQUc7b0JBQ1AsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSS9DLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9pRTtBQUNYO0FBRUEsSUFBSWdDLGFBQWEsV0FBVyxHQUFJO0lBQzVCLFNBQVNBLFdBQVcvQixNQUFNO1FBQ3RCLElBQUksQ0FBQ2dDLFdBQVcsR0FBRyxJQUFJakMsYUFBYUM7SUFDeEM7SUFDQStCLFdBQVd6SSxTQUFTLENBQUMySSxhQUFhLEdBQUcsU0FBVUMsR0FBRztRQUM5QyxPQUFPMUgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFNBQVNnQixNQUFNLENBQUNvRTt3QkFDdEIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQWlHLFdBQVd6SSxTQUFTLENBQUM2SSxjQUFjLEdBQUc7UUFDbEMsT0FBTzNILFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTTt3QkFDTixPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNrRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQWlHLFdBQVd6SSxTQUFTLENBQUM4SSxZQUFZLEdBQUcsU0FBVUMsUUFBUSxFQUFFQyxNQUFNO1FBQzFELE9BQU85SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQ3VFLFVBQVUsV0FBV3ZFLE1BQU0sQ0FBQ3dFO3dCQUNwRCxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNOLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBaUcsV0FBV3pJLFNBQVMsQ0FBQ2lKLGFBQWEsR0FBRyxTQUFVRixRQUFRO1FBQ25ELE9BQU83SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQ3VFLFVBQVU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0wsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0RpRyxXQUFXekksU0FBUyxDQUFDa0osaUJBQWlCLEdBQUcsU0FBVUYsTUFBTSxFQUFFckYsRUFBRTtRQUN6RCxJQUFJQyxLQUFLRCxPQUFPLEtBQUssSUFBSSxDQUFDLElBQUlBLElBQUlFLEtBQUtELEdBQUd1RixTQUFTLEVBQUVBLFlBQVl0RixPQUFPLEtBQUssSUFBSSxPQUFPQSxJQUFJdUYsS0FBS3hGLEdBQUd5RixVQUFVLEVBQUVBLGFBQWFELE9BQU8sS0FBSyxJQUFJLEtBQUtBO1FBQ2xKLE9BQU9sSSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlvSSxjQUFjdEU7WUFDbEIsT0FBTzVDLFlBQVksSUFBSSxFQUFFLFNBQVVtSCxFQUFFO2dCQUNqQyxPQUFRQSxHQUFHaEgsS0FBSztvQkFDWixLQUFLO3dCQUNEK0csZUFBZUUsS0FBS0MsR0FBRzt3QkFDdkJGLEdBQUdoSCxLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRCxJQUFJLENBQUVpSCxDQUFBQSxLQUFLQyxHQUFHLEtBQUtILGVBQWVILFNBQVEsR0FBSSxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTt3QkFDckUsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDUixhQUFhLENBQUNLO3lCQUFRO29CQUNwRCxLQUFLO3dCQUNEaEUsV0FBV3VFLEdBQUcvRyxJQUFJO3dCQUNsQixJQUFJLENBQUM7NEJBQUMsV0FBVyxpQkFBaUI7NEJBQUksYUFBYSxtQkFBbUI7eUJBQUcsQ0FBQ2tILFFBQVEsQ0FBQzFFLFNBQVNiLE1BQU0sR0FDOUYsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlhO3lCQUFTO3dCQUNuQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSWdCLE1BQU1xRDt5QkFBWTtvQkFDM0MsS0FBSzt3QkFDREUsR0FBRy9HLElBQUk7d0JBQ1AsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7b0JBQzNCLEtBQUs7d0JBQUcsTUFBTSxJQUFJOEMsd0JBQXdCLGNBQWNkLE1BQU0sQ0FBQzJFLFdBQVcsK0JBQStCM0UsTUFBTSxDQUFDd0UsUUFBUTtnQkFDNUg7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRFAsV0FBV3pJLFNBQVMsQ0FBQzJKLGtCQUFrQixHQUFHLFNBQVVDLE9BQU8sRUFBRWpHLEVBQUU7UUFDM0QsSUFBSUMsS0FBS0QsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFJQSxJQUFJRSxLQUFLRCxHQUFHdUYsU0FBUyxFQUFFQSxZQUFZdEYsT0FBTyxLQUFLLElBQUksT0FBT0EsSUFBSXVGLEtBQUt4RixHQUFHeUYsVUFBVSxFQUFFQSxhQUFhRCxPQUFPLEtBQUssSUFBSSxLQUFLQTtRQUNsSixPQUFPbEksVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJMkksT0FBT0MsSUFBSUMsV0FBV2YsUUFBUWdCO1lBQ2xDLE9BQU81SCxZQUFZLElBQUksRUFBRSxTQUFVbUgsRUFBRTtnQkFDakMsT0FBUUEsR0FBR2hILEtBQUs7b0JBQ1osS0FBSzt3QkFDRHNILFFBQVEsRUFBRTt3QkFDVkMsS0FBSyxHQUFHQyxZQUFZSDt3QkFDcEJMLEdBQUdoSCxLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRCxJQUFJLENBQUV1SCxDQUFBQSxLQUFLQyxVQUFVL0ksTUFBTSxHQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFFO3dCQUNyRGdJLFNBQVNlLFNBQVMsQ0FBQ0QsR0FBRzt3QkFDdEIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDWixpQkFBaUIsQ0FBQ0YsUUFBUTtnQ0FDNUNHLFdBQVdBO2dDQUNYRSxZQUFZQTs0QkFDaEI7eUJBQUc7b0JBQ1gsS0FBSzt3QkFDRFcsT0FBT1QsR0FBRy9HLElBQUk7d0JBQ2RxSCxNQUFNekcsSUFBSSxDQUFDNEc7d0JBQ1hULEdBQUdoSCxLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRHVIO3dCQUNBLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFFO29CQUMzQixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJO2dDQUFFRyxTQUFTSjs0QkFBTTt5QkFBRTtnQkFDckQ7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRHBCLFdBQVd6SSxTQUFTLENBQUNrSyxnQkFBZ0IsR0FBRyxTQUFVbkIsUUFBUSxFQUFFQyxNQUFNLEVBQUVyRixFQUFFO1FBQ2xFLElBQUlDLEtBQUtELE9BQU8sS0FBSyxJQUFJLENBQUMsSUFBSUEsSUFBSUUsS0FBS0QsR0FBR3VGLFNBQVMsRUFBRUEsWUFBWXRGLE9BQU8sS0FBSyxJQUFJLE9BQU9BLElBQUl1RixLQUFLeEYsR0FBR3lGLFVBQVUsRUFBRUEsYUFBYUQsT0FBTyxLQUFLLElBQUksS0FBS0E7UUFDbEosT0FBT2xJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSW9JLGNBQWN0RTtZQUNsQixPQUFPNUMsWUFBWSxJQUFJLEVBQUUsU0FBVW1ILEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdoSCxLQUFLO29CQUNaLEtBQUs7d0JBQ0QrRyxlQUFlRSxLQUFLQyxHQUFHO3dCQUN2QkYsR0FBR2hILEtBQUssR0FBRztvQkFDZixLQUFLO3dCQUNELElBQUksQ0FBRWlILENBQUFBLEtBQUtDLEdBQUcsS0FBS0gsZUFBZUgsU0FBUSxHQUFJLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFFO3dCQUNyRSxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNMLFlBQVksQ0FBQ0MsVUFBVUM7eUJBQVE7b0JBQzdELEtBQUs7d0JBQ0RoRSxXQUFXdUUsR0FBRy9HLElBQUk7d0JBQ2xCLElBQUksQ0FBQzs0QkFBQyxXQUFXLGlCQUFpQjs0QkFBSSxhQUFhLG1CQUFtQjt5QkFBRyxDQUFDa0gsUUFBUSxDQUFDMUUsU0FBU2IsTUFBTSxHQUM5RixPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSWE7eUJBQVM7d0JBQ25DLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJZ0IsTUFBTXFEO3lCQUFZO29CQUMzQyxLQUFLO3dCQUNERSxHQUFHL0csSUFBSTt3QkFDUCxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTtvQkFDM0IsS0FBSzt3QkFBRyxNQUFNLElBQUk4Qyx3QkFBd0IsY0FBY2QsTUFBTSxDQUFDMkUsV0FBVywrQkFBK0IzRSxNQUFNLENBQUN3RSxRQUFRO2dCQUM1SDtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU9QO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUkwQixRQUFRLFdBQVcsR0FBSTtJQUN2Qjs7OztLQUlDLEdBQ0QsU0FBU0EsTUFBTXpELE1BQU0sRUFBRWtDLEdBQUcsRUFBRXdCLFVBQVU7UUFDbEMsSUFBSSxDQUFDeEIsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ3dCLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDMUIsV0FBVyxHQUFHLElBQUlqQyxhQUFhQztRQUNwQyxJQUFJLENBQUNtRCxLQUFLLEdBQUcsSUFBSXBCLFdBQVcvQjtJQUNoQztJQUNBLEdBQUc7SUFDSCxVQUFVO0lBQ1YsR0FBRztJQUNIOzs7Ozs7Ozs7S0FTQyxHQUNEeUQsTUFBTW5LLFNBQVMsQ0FBQzRILE1BQU0sR0FBRyxTQUFVeUMsS0FBSyxFQUFFQyxPQUFPLEVBQUU1RCxNQUFNO1FBQ3JELE9BQU94RixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTCxJQUFJLENBQUM3RSxLQUFLK0IsMEJBQTBCOUUsU0FBU0EsU0FBUyxDQUFDLEdBQUc2SixVQUFVO2dDQUFFQyxHQUFHRjs0QkFBTSxLQUFLdEUsV0FBV1c7eUJBQVE7b0JBQ2pKLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUkvQyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUN3SyxTQUFTLEdBQUcsU0FBVUgsS0FBSyxFQUFFQyxPQUFPLEVBQUU1RCxNQUFNO1FBQ3hELElBQUkvQyxJQUFJQyxJQUFJQyxJQUFJdUYsSUFBSUc7UUFDcEIsT0FBT3JJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDLEtBQUtpSCxhQUFhQztZQUN0QixPQUFPdEksWUFBWSxJQUFJLEVBQUUsU0FBVXVJLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwSSxLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQzZCLGNBQWMsU0FBVWpELE1BQU07NEJBQzFCLElBQUksT0FBT0EsV0FBVyxVQUNsQixPQUFPQTtpQ0FDTixJQUFJMUgsTUFBTThLLE9BQU8sQ0FBQ3BELFNBQ25CLE1BQU0sSUFBSW5DLGlCQUFpQjtpQ0FFM0IsT0FBT1U7d0JBQ2Y7d0JBQ0EyRSxZQUFZakssU0FBU0EsU0FBUzs0QkFBRThKLEdBQUdGO3dCQUFNLEdBQUdDLFVBQVU7NEJBQUU5QyxRQUFRaUQsWUFBWUgsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE5QyxNQUFNOzRCQUFHcUQsTUFBTSxDQUFDbEgsS0FBSzJHLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRTyxJQUFJLE1BQU0sUUFBUWxILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR21ILElBQUksQ0FBQzs0QkFBTUMsb0JBQW9CLENBQUNuSCxLQUFLMEcsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFTLGtCQUFrQixNQUFNLFFBQVFuSCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdrSCxJQUFJLENBQUM7NEJBQU1FLHNCQUFzQixDQUFDbkgsS0FBS3lHLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRVSxvQkFBb0IsTUFBTSxRQUFRbkgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUgsSUFBSSxDQUFDOzRCQUFNRyxrQkFBa0IsQ0FBQzdCLEtBQUtrQixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUVcsZ0JBQWdCLE1BQU0sUUFBUTdCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRzBCLElBQUksQ0FBQzs0QkFBTUksdUJBQXVCLENBQUMzQixLQUFLZSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUVkscUJBQXFCLE1BQU0sUUFBUTNCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR3VCLElBQUksQ0FBQzt3QkFBSzt3QkFDLzNCLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3BDLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUUsS0FBSytCLDBCQUEwQm1GLFlBQVloRTt5QkFBUTtvQkFDakcsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSWlFLEdBQUduSSxJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxTQUFTO0lBQ1QsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDbUwsVUFBVSxHQUFHO1FBQ3pCLE9BQU9qSyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQyxLQUFLeUU7WUFDVCxPQUFPN0YsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRzt3QkFDaEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUNEeUUsTUFBTXRFLEdBQUduQixJQUFJO3dCQUNiLElBQUksQ0FBQzRILFVBQVUsR0FBR25DLElBQUltQyxVQUFVO3dCQUNoQyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSW5DO3lCQUFJO2dCQUNsQztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RrQyxNQUFNbkssU0FBUyxDQUFDb0wsU0FBUyxHQUFHO1FBQ3hCLE9BQU9sSyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUM0SSxVQUFVO3lCQUFHO29CQUMvQyxLQUFLO3dCQUNEeEgsR0FBR25CLElBQUk7d0JBQ1AsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUksSUFBSTt5QkFBQztnQkFDbkM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ3FMLGVBQWUsR0FBRztRQUM5QixPQUFPbkssVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJeUM7WUFDSixPQUFPdkIsWUFBWSxJQUFJLEVBQUUsU0FBVXdCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdyQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RvQixLQUFLLElBQUk7d0JBQ1QsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDd0gsVUFBVTt5QkFBRztvQkFDM0MsS0FBSzt3QkFDRHhILEdBQUd5RyxVQUFVLEdBQUcsR0FBSTVILElBQUksR0FBSTRILFVBQVU7d0JBQ3RDLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJLElBQUksQ0FBQ0EsVUFBVTt5QkFBQztnQkFDOUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDREQsTUFBTTNKLE1BQU0sR0FBRyxTQUFVb0ksR0FBRyxFQUFFMEIsT0FBTyxFQUFFNUQsTUFBTTtRQUN6QyxJQUFJNEQsWUFBWSxLQUFLLEdBQUc7WUFBRUEsVUFBVSxDQUFDO1FBQUc7UUFDeEMsT0FBT3BKLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDLEtBQUs4SDtZQUNULE9BQU9sSixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakNILE1BQU07Z0JBQ044SCxNQUFNLElBQUk3RSxhQUFhQztnQkFDdkIsT0FBTztvQkFBQyxFQUFFLFFBQVE7b0JBQUk0RSxJQUFJakQsSUFBSSxDQUFDN0UsS0FBSy9DLFNBQVNBLFNBQVMsQ0FBQyxHQUFHNkosVUFBVTt3QkFBRTFCLEtBQUtBO29CQUFJO2lCQUFJO1lBQ3ZGO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEdUIsTUFBTW5LLFNBQVMsQ0FBQ3VMLE1BQU0sR0FBRyxTQUFVakQsSUFBSTtRQUNuQyxPQUFPcEgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRzt3QkFDaEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNILEdBQUcsQ0FBQy9FLEtBQUs4RTt5QkFBTTtvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSTNFLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDLFNBQVMsR0FBRztRQUN4QixPQUFPa0IsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRzt3QkFDaEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUMsU0FBUyxDQUFDbEY7eUJBQUs7b0JBQ3pELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxTQUFTO0lBQ1QsR0FBRztJQUNIOzs7Ozs7O0tBT0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUN3TCxRQUFRLEdBQUc7UUFDdkIsT0FBT3RLLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3NILEtBQUssQ0FBQ1osYUFBYSxDQUFDLElBQUksQ0FBQ0wsR0FBRzt5QkFBRTtvQkFDaEUsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSWpGLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDeUwsT0FBTyxHQUFHLFNBQVV6QyxNQUFNO1FBQ3RDLE9BQU85SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNzSCxLQUFLLENBQUNmLFlBQVksQ0FBQyxJQUFJLENBQUNGLEdBQUcsRUFBRUk7eUJBQVE7b0JBQ3ZFLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlyRixHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7O0tBU0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUMwTCxZQUFZLEdBQUcsU0FBVTlCLE9BQU8sRUFBRWpHLEVBQUU7UUFDaEQsSUFBSUMsS0FBS0QsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFJQSxJQUFJRSxLQUFLRCxHQUFHdUYsU0FBUyxFQUFFQSxZQUFZdEYsT0FBTyxLQUFLLElBQUksT0FBT0EsSUFBSXVGLEtBQUt4RixHQUFHeUYsVUFBVSxFQUFFQSxhQUFhRCxPQUFPLEtBQUssSUFBSSxLQUFLQTtRQUNsSixPQUFPbEksVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPa0IsWUFBWSxJQUFJLEVBQUUsU0FBVW1ILEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdoSCxLQUFLO29CQUNaLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDc0gsS0FBSyxDQUFDRixrQkFBa0IsQ0FBQ0MsU0FBUztnQ0FDNURULFdBQVdBO2dDQUNYRSxZQUFZQTs0QkFDaEI7eUJBQUc7b0JBQ1AsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUUsR0FBRy9HLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDMkwsV0FBVyxHQUFHLFNBQVUzQyxNQUFNLEVBQUVyRixFQUFFO1FBQzlDLElBQUlDLEtBQUtELE9BQU8sS0FBSyxJQUFJLENBQUMsSUFBSUEsSUFBSUUsS0FBS0QsR0FBR3VGLFNBQVMsRUFBRUEsWUFBWXRGLE9BQU8sS0FBSyxJQUFJLE9BQU9BLElBQUl1RixLQUFLeEYsR0FBR3lGLFVBQVUsRUFBRUEsYUFBYUQsT0FBTyxLQUFLLElBQUksS0FBS0E7UUFDbEosT0FBT2xJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVVtSCxFQUFFO2dCQUNqQyxPQUFRQSxHQUFHaEgsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3NILEtBQUssQ0FBQ1gsaUJBQWlCLENBQUNGLFFBQVE7Z0NBQzFERyxXQUFXQTtnQ0FDWEUsWUFBWUE7NEJBQ2hCO3lCQUFHO29CQUNQLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlFLEdBQUcvRyxJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxTQUFTO0lBQ1QsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDNEwsUUFBUSxHQUFHO1FBQ3ZCLE9BQU8xSyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILGFBQWE7SUFDYixHQUFHO0lBQ0g7Ozs7Ozs7S0FPQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQzZMLFlBQVksR0FBRyxTQUFVdkIsT0FBTztRQUM1QyxPQUFPcEosVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0MsS0FBS3NJO1lBQ1QsT0FBTzFKLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsSUFBSTBCLFlBQVl2RSxhQUFhakcsTUFBTThLLE9BQU8sQ0FBQ04sUUFBUVUsb0JBQW9CLEdBQUc7NEJBQ3RFYyxPQUFPeEIsUUFBUVUsb0JBQW9CLENBQUNGLElBQUksQ0FBQzt3QkFDN0M7d0JBQ0EsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDcEMsV0FBVyxDQUFDTixHQUFHLENBQUM1RSxLQUFLL0MsU0FBU0EsU0FBUyxDQUFDLEdBQUc2SixVQUFXd0IsU0FBUy9GLFlBQVk7Z0NBQUVpRixzQkFBc0JjOzRCQUFLLElBQUksQ0FBQzt5QkFBSztvQkFDaEosS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSW5JLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7O0tBT0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUMrTCxXQUFXLEdBQUcsU0FBVUMsVUFBVTtRQUM5QyxPQUFPOUssVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFLGVBQWVwRSxNQUFNLENBQUN3SDt3QkFDeEQsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDdEQsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRDJILE1BQU1uSyxTQUFTLENBQUNpTSxZQUFZLEdBQUcsU0FBVUMsU0FBUyxFQUFFNUIsT0FBTztRQUN2RCxPQUFPcEosVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBSzBJLFdBQVc1Qjt5QkFBUztvQkFDeEUsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSTNHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7S0FTQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ21NLHFCQUFxQixHQUFHLFNBQVVELFNBQVMsRUFBRUUsU0FBUyxFQUFFOUIsT0FBTztRQUMzRSxJQUFJOEIsY0FBYyxLQUFLLEdBQUc7WUFBRUEsWUFBWTtRQUFNO1FBQzlDLE9BQU9sTCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUltTCxTQUFTeEwsR0FBRzhDLElBQUlDO1lBQ3BCLE9BQU94QixZQUFZLElBQUksRUFBRSxTQUFVeUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3RCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRDhKLFVBQVUsRUFBRTt3QkFDWnhMLElBQUk7d0JBQ0pnRCxHQUFHdEIsS0FBSyxHQUFHO29CQUNmLEtBQUs7d0JBQ0QsSUFBSSxDQUFFMUIsQ0FBQUEsSUFBSXFMLFVBQVVsTCxNQUFNLEdBQUcsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUk7eUJBQUU7d0JBQ3BENEMsS0FBSyxDQUFDRCxLQUFLMEksT0FBTSxFQUFHakosSUFBSTt3QkFDeEIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDNkksWUFBWSxDQUFDQyxVQUFVSSxLQUFLLENBQUN6TCxHQUFHQSxJQUFJdUwsWUFBWTlCO3lCQUFTO29CQUN2RixLQUFLO3dCQUNEMUcsR0FBRzNDLEtBQUssQ0FBQzBDLElBQUk7NEJBQUNFLEdBQUdyQixJQUFJO3lCQUFHO3dCQUN4QnFCLEdBQUd0QixLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRDFCLEtBQUt1TDt3QkFDTCxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTtvQkFDM0IsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUM7eUJBQVE7Z0JBQzFDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEbEMsTUFBTW5LLFNBQVMsQ0FBQ3VNLGVBQWUsR0FBRyxTQUFVTCxTQUFTLEVBQUU1QixPQUFPO1FBQzFELE9BQU9wSixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDSCxHQUFHLENBQUMvRSxLQUFLMEksV0FBVzVCO3lCQUFTO29CQUN2RSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJM0csR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDd00sd0JBQXdCLEdBQUcsU0FBVU4sU0FBUyxFQUFFRSxTQUFTLEVBQUU5QixPQUFPO1FBQzlFLElBQUk4QixjQUFjLEtBQUssR0FBRztZQUFFQSxZQUFZO1FBQU07UUFDOUMsT0FBT2xMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSW1MLFNBQVN4TCxHQUFHOEMsSUFBSUM7WUFDcEIsT0FBT3hCLFlBQVksSUFBSSxFQUFFLFNBQVV5QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHdEIsS0FBSztvQkFDWixLQUFLO3dCQUNEOEosVUFBVSxFQUFFO3dCQUNaeEwsSUFBSTt3QkFDSmdELEdBQUd0QixLQUFLLEdBQUc7b0JBQ2YsS0FBSzt3QkFDRCxJQUFJLENBQUUxQixDQUFBQSxJQUFJcUwsVUFBVWxMLE1BQU0sR0FBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTt5QkFBRTt3QkFDcEQ0QyxLQUFLLENBQUNELEtBQUswSSxPQUFNLEVBQUdqSixJQUFJO3dCQUN4QixPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNtSixlQUFlLENBQUNMLFVBQVVJLEtBQUssQ0FBQ3pMLEdBQUdBLElBQUl1TCxZQUFZOUI7eUJBQVM7b0JBQzFGLEtBQUs7d0JBQ0QxRyxHQUFHM0MsS0FBSyxDQUFDMEMsSUFBSTs0QkFBQ0UsR0FBR3JCLElBQUk7eUJBQUc7d0JBQ3hCcUIsR0FBR3RCLEtBQUssR0FBRztvQkFDZixLQUFLO3dCQUNEMUIsS0FBS3VMO3dCQUNMLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJO3lCQUFFO29CQUMzQixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJQzt5QkFBUTtnQkFDMUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRGxDLE1BQU1uSyxTQUFTLENBQUN5TSxjQUFjLEdBQUcsU0FBVVQsVUFBVTtRQUNqRCxPQUFPOUssVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFLGVBQWVwRSxNQUFNLENBQUN3SDt3QkFDeEQsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDdEQsV0FBVyxDQUFDLFNBQVMsQ0FBQ2xGO3lCQUFLO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRDJILE1BQU1uSyxTQUFTLENBQUMwTSxlQUFlLEdBQUcsU0FBVUMsWUFBWTtRQUNwRCxPQUFPekwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBS21KO3lCQUFjO29CQUNsRSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJaEosR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUM0TSxrQkFBa0IsR0FBRztRQUNqQyxPQUFPMUwsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQyxTQUFTLENBQUNsRjt5QkFBSztvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILFlBQVk7SUFDWixHQUFHO0lBQ0g7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUM2TSxXQUFXLEdBQUc7UUFDMUIsT0FBTzNMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDOE0sY0FBYyxHQUFHLFNBQVVDLFFBQVE7UUFDL0MsT0FBTzdMLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNMLElBQUksQ0FBQzdFLEtBQUt1Sjt5QkFBVTtvQkFDOUQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSXBKLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDZ04sYUFBYSxHQUFHO1FBQzVCLE9BQU85TCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDLFNBQVMsQ0FBQ2xGO3lCQUFLO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxHQUFHO0lBQ0gsWUFBWTtJQUNaLEdBQUc7SUFDSDs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ2lOLFdBQVcsR0FBRztRQUMxQixPQUFPL0wsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ2tOLGNBQWMsR0FBRyxTQUFVQyxRQUFRO1FBQy9DLE9BQU9qTSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTCxJQUFJLENBQUM3RSxLQUFLMko7eUJBQVU7b0JBQzlELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUl4SixHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ29OLGFBQWEsR0FBRztRQUM1QixPQUFPbE0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQyxTQUFTLENBQUNsRjt5QkFBSztvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILGNBQWM7SUFDZCxHQUFHO0lBQ0g7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUNxTixZQUFZLEdBQUc7UUFDM0IsT0FBT25NLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRDJILE1BQU1uSyxTQUFTLENBQUNzTixlQUFlLEdBQUcsU0FBVUMsU0FBUztRQUNqRCxPQUFPck0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBSytKO3lCQUFXO29CQUMvRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJNUosR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUN3TixjQUFjLEdBQUc7UUFDN0IsT0FBT3RNLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUMsU0FBUyxDQUFDbEY7eUJBQUs7b0JBQ3pELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxpQkFBaUI7SUFDakIsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDeU4sZUFBZSxHQUFHO1FBQzlCLE9BQU92TSxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDME4sa0JBQWtCLEdBQUcsU0FBVUMsWUFBWTtRQUN2RCxPQUFPek0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBS21LO3lCQUFjO29CQUNsRSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJaEssR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUM0TixpQkFBaUIsR0FBRztRQUNoQyxPQUFPMU0sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQyxTQUFTLENBQUNsRjt5QkFBSztvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILHNCQUFzQjtJQUN0QixHQUFHO0lBQ0g7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUM2TixvQkFBb0IsR0FBRztRQUNuQyxPQUFPM00sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQzhOLHVCQUF1QixHQUFHLFNBQVVDLGlCQUFpQjtRQUNqRSxPQUFPN00sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBS3VLO3lCQUFtQjtvQkFDdkUsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSXBLLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDZ08sc0JBQXNCLEdBQUc7UUFDckMsT0FBTzlNLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUMsU0FBUyxDQUFDbEY7eUJBQUs7b0JBQ3pELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCx5QkFBeUI7SUFDekIsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDaU8sdUJBQXVCLEdBQUc7UUFDdEMsT0FBTy9NLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRDJILE1BQU1uSyxTQUFTLENBQUNrTywwQkFBMEIsR0FBRyxTQUFVQyxvQkFBb0I7UUFDdkUsT0FBT2pOLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNMLElBQUksQ0FBQzdFLEtBQUsySzt5QkFBc0I7b0JBQzFFLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUl4SyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ29PLHlCQUF5QixHQUFHO1FBQ3hDLE9BQU9sTixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDLFNBQVMsQ0FBQ2xGO3lCQUFLO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxHQUFHO0lBQ0gsdUJBQXVCO0lBQ3ZCLEdBQUc7SUFDSDs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ3FPLHFCQUFxQixHQUFHO1FBQ3BDLE9BQU9uTixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDc08sd0JBQXdCLEdBQUcsU0FBVUMsa0JBQWtCO1FBQ25FLE9BQU9yTixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTCxJQUFJLENBQUM3RSxLQUFLK0s7eUJBQW9CO29CQUN4RSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJNUssR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUN3Tyx1QkFBdUIsR0FBRztRQUN0QyxPQUFPdE4sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQyxTQUFTLENBQUNsRjt5QkFBSztvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILHdCQUF3QjtJQUN4QixHQUFHO0lBQ0g7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUN5Tyx1QkFBdUIsR0FBRztRQUN0QyxPQUFPdk4sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQzBPLDBCQUEwQixHQUFHLFNBQVVDLG9CQUFvQjtRQUN2RSxPQUFPek4sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBS21MO3lCQUFzQjtvQkFDMUUsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSWhMLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDNE8seUJBQXlCLEdBQUc7UUFDeEMsT0FBTzFOLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUMsU0FBUyxDQUFDbEY7eUJBQUs7b0JBQ3pELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCx1QkFBdUI7SUFDdkIsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDNk8sc0JBQXNCLEdBQUc7UUFDckMsT0FBTzNOLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRDJILE1BQU1uSyxTQUFTLENBQUM4Tyx5QkFBeUIsR0FBRyxTQUFVQyxtQkFBbUI7UUFDckUsT0FBTzdOLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxXQUFXZ0IsTUFBTSxDQUFDLElBQUksQ0FBQ29FLEdBQUcsRUFBRTt3QkFDbEMsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDRixXQUFXLENBQUNMLElBQUksQ0FBQzdFLEtBQUt1TDt5QkFBcUI7b0JBQ3pFLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlwTCxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ2dQLHdCQUF3QixHQUFHO1FBQ3ZDLE9BQU85TixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDLFNBQVMsQ0FBQ2xGO3lCQUFLO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxHQUFHO0lBQ0gsa0JBQWtCO0lBQ2xCLEdBQUc7SUFDSDs7Ozs7S0FLQyxHQUNEMkgsTUFBTW5LLFNBQVMsQ0FBQ2lQLGdCQUFnQixHQUFHO1FBQy9CLE9BQU8vTixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU0sV0FBV2dCLE1BQU0sQ0FBQyxJQUFJLENBQUNvRSxHQUFHLEVBQUU7d0JBQ2xDLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ0YsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0QySCxNQUFNbkssU0FBUyxDQUFDa1AsbUJBQW1CLEdBQUcsU0FBVUMsYUFBYTtRQUN6RCxPQUFPak8sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBSzJMO3lCQUFlO29CQUNuRSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJeEwsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRDJILE1BQU1uSyxTQUFTLENBQUNvUCxrQkFBa0IsR0FBRztRQUNqQyxPQUFPbE8sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFdBQVdnQixNQUFNLENBQUMsSUFBSSxDQUFDb0UsR0FBRyxFQUFFO3dCQUNsQyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNGLFdBQVcsQ0FBQyxTQUFTLENBQUNsRjt5QkFBSztvQkFDekQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBTzJIO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUNELElBQUlrRixTQUFTLFdBQVcsR0FBSTtJQUN4Qjs7O0tBR0MsR0FDRCxTQUFTQSxPQUFPM0ksTUFBTTtRQUNsQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNnQyxXQUFXLEdBQUcsSUFBSWpDLGFBQWFDO1FBQ3BDLElBQUksQ0FBQ21ELEtBQUssR0FBRyxJQUFJcEIsV0FBVy9CO0lBQ2hDO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNEMkksT0FBT3JQLFNBQVMsQ0FBQ3NQLEtBQUssR0FBRyxTQUFVdkcsUUFBUTtRQUN2QyxPQUFPLElBQUlvQixNQUFNLElBQUksQ0FBQ3pELE1BQU0sRUFBRXFDO0lBQ2xDO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRHNHLE9BQU9yUCxTQUFTLENBQUN1UCxRQUFRLEdBQUcsU0FBVXhHLFFBQVE7UUFDMUMsT0FBTzdILFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFPO29CQUFDLEVBQUUsUUFBUTtvQkFBSSxJQUFJd0csTUFBTSxJQUFJLENBQUN6RCxNQUFNLEVBQUVxQyxVQUFVcUMsU0FBUztpQkFBRztZQUN2RTtRQUNKO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0RpRSxPQUFPclAsU0FBUyxDQUFDd1AsV0FBVyxHQUFHLFNBQVV6RyxRQUFRO1FBQzdDLE9BQU83SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBTztvQkFBQyxFQUFFLFFBQVE7b0JBQUksSUFBSXdHLE1BQU0sSUFBSSxDQUFDekQsTUFBTSxFQUFFcUMsVUFBVW9DLFVBQVU7aUJBQUc7WUFDeEU7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDRGtFLE9BQU9yUCxTQUFTLENBQUN5UCxVQUFVLEdBQUc7UUFDMUIsT0FBT3ZPLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSThELFVBQVUwSztZQUNkLElBQUloTSxRQUFRLElBQUk7WUFDaEIsT0FBT3RCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ29OLGFBQWE7eUJBQUc7b0JBQ2xELEtBQUs7d0JBQ0QzSyxXQUFXckIsR0FBR25CLElBQUk7d0JBQ2xCa04sVUFBVTFLLFNBQVMwQyxHQUFHLENBQUMsU0FBVTRILEtBQUs7NEJBQUksT0FBTyxJQUFJbkYsTUFBTXpHLE1BQU1nRCxNQUFNLEVBQUU0SSxNQUFNMUcsR0FBRyxFQUFFMEcsTUFBTWxGLFVBQVU7d0JBQUc7d0JBQ3ZHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJc0Y7eUJBQVE7Z0JBQ3RDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7O0tBS0MsR0FDREwsT0FBT3JQLFNBQVMsQ0FBQzJQLGFBQWEsR0FBRztRQUM3QixPQUFPek8sVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNO3dCQUNOLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ2tGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDNFAsV0FBVyxHQUFHLFNBQVVoSCxHQUFHLEVBQUUwQixPQUFPO1FBQ2pELElBQUlBLFlBQVksS0FBSyxHQUFHO1lBQUVBLFVBQVUsQ0FBQztRQUFHO1FBQ3hDLE9BQU9wSixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSTRILE1BQU0zSixNQUFNLENBQUNvSSxLQUFLMEIsU0FBUyxJQUFJLENBQUM1RCxNQUFNO3lCQUFFO29CQUNyRSxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJL0MsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUM2UCxXQUFXLEdBQUcsU0FBVWpILEdBQUcsRUFBRTBCLE9BQU87UUFDakQsSUFBSUEsWUFBWSxLQUFLLEdBQUc7WUFBRUEsVUFBVSxDQUFDO1FBQUc7UUFDeEMsT0FBT3BKLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUk0SCxNQUFNLElBQUksQ0FBQ3pELE1BQU0sRUFBRWtDLEtBQUsyQyxNQUFNLENBQUNqQjt5QkFBUztvQkFDekUsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSTNHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7S0FNQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQzhQLFdBQVcsR0FBRyxTQUFVbEgsR0FBRztRQUN4QyxPQUFPMUgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPa0IsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSTRILE1BQU0sSUFBSSxDQUFDekQsTUFBTSxFQUFFa0MsSUFBSSxDQUFDLFNBQVM7eUJBQUc7b0JBQ3JFLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlqRixHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUMrUCxtQkFBbUIsR0FBRyxTQUFVbkgsR0FBRztRQUNoRCxPQUFPMUgsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJbUc7WUFDSixPQUFPakYsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RvQixHQUFHbEIsSUFBSSxDQUFDVyxJQUFJLENBQUM7NEJBQUM7NEJBQUc7OzRCQUFLO3lCQUFFO3dCQUN4QixPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUMwTSxXQUFXLENBQUNsSDt5QkFBSztvQkFDL0MsS0FBSzt3QkFDRGpGLEdBQUduQixJQUFJO3dCQUNQLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJO3lCQUFLO29CQUMvQixLQUFLO3dCQUNENkUsTUFBTTFELEdBQUduQixJQUFJO3dCQUNiLElBQUk2RSxJQUFJL0MsSUFBSSxLQUFLLGtCQUFrQixtQkFBbUIsS0FBSTs0QkFDdEQsT0FBTztnQ0FBQyxFQUFFLFFBQVE7Z0NBQUk7NkJBQU07d0JBQ2hDO3dCQUNBLE1BQU0rQztvQkFDVixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFRO3lCQUFHO2dCQUNqQztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxTQUFTO0lBQ1QsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0RnSSxPQUFPclAsU0FBUyxDQUFDd0wsUUFBUSxHQUFHO1FBQ3hCLE9BQU90SyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNzSCxLQUFLLENBQUNoQixjQUFjO3lCQUFHO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJbEYsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDeUwsT0FBTyxHQUFHLFNBQVV6QyxNQUFNO1FBQ3ZDLE9BQU85SCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9rQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNzSCxLQUFLLENBQUNsQixhQUFhLENBQUNLO3lCQUFRO29CQUM5RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJckYsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUMwTCxZQUFZLEdBQUcsU0FBVTlCLE9BQU8sRUFBRWpHLEVBQUU7UUFDakQsSUFBSUMsS0FBS0QsT0FBTyxLQUFLLElBQUksQ0FBQyxJQUFJQSxJQUFJRSxLQUFLRCxHQUFHdUYsU0FBUyxFQUFFQSxZQUFZdEYsT0FBTyxLQUFLLElBQUksT0FBT0EsSUFBSXVGLEtBQUt4RixHQUFHeUYsVUFBVSxFQUFFQSxhQUFhRCxPQUFPLEtBQUssSUFBSSxLQUFLQTtRQUNsSixPQUFPbEksVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPa0IsWUFBWSxJQUFJLEVBQUUsU0FBVW1ILEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdoSCxLQUFLO29CQUNaLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDc0gsS0FBSyxDQUFDRixrQkFBa0IsQ0FBQ0MsU0FBUztnQ0FDNURULFdBQVdBO2dDQUNYRSxZQUFZQTs0QkFDaEI7eUJBQUc7b0JBQ1AsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUUsR0FBRy9HLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDMkwsV0FBVyxHQUFHLFNBQVUzQyxNQUFNLEVBQUVyRixFQUFFO1FBQy9DLElBQUlDLEtBQUtELE9BQU8sS0FBSyxJQUFJLENBQUMsSUFBSUEsSUFBSUUsS0FBS0QsR0FBR3VGLFNBQVMsRUFBRUEsWUFBWXRGLE9BQU8sS0FBSyxJQUFJLE9BQU9BLElBQUl1RixLQUFLeEYsR0FBR3lGLFVBQVUsRUFBRUEsYUFBYUQsT0FBTyxLQUFLLElBQUksS0FBS0E7UUFDbEosT0FBT2xJLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2tCLFlBQVksSUFBSSxFQUFFLFNBQVVtSCxFQUFFO2dCQUNqQyxPQUFRQSxHQUFHaEgsS0FBSztvQkFDWixLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ3NILEtBQUssQ0FBQ1gsaUJBQWlCLENBQUNGLFFBQVE7Z0NBQzFERyxXQUFXQTtnQ0FDWEUsWUFBWUE7NEJBQ2hCO3lCQUFHO29CQUNQLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlFLEdBQUcvRyxJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxRQUFRO0lBQ1IsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDZ1EsT0FBTyxHQUFHO1FBQ3ZCLE9BQU85TyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU07d0JBQ04sT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDa0YsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQ2lRLE1BQU0sR0FBRyxTQUFVcEssR0FBRztRQUNuQyxPQUFPM0UsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFFBQVFnQixNQUFNLENBQUNxQjt3QkFDckIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDNkMsV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQ2tRLFNBQVMsR0FBRyxTQUFVNUYsT0FBTztRQUMxQyxPQUFPcEosVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNO3dCQUNOLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ2tGLFdBQVcsQ0FBQ0wsSUFBSSxDQUFDN0UsS0FBSzhHO3lCQUFTO29CQUM3RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJM0csR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUNtUSxTQUFTLEdBQUcsU0FBVXRLLEdBQUcsRUFBRXlFLE9BQU87UUFDL0MsT0FBT3BKLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxRQUFRZ0IsTUFBTSxDQUFDcUI7d0JBQ3JCLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQzZDLFdBQVcsQ0FBQ0YsS0FBSyxDQUFDaEYsS0FBSzhHO3lCQUFTO29CQUM5RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJM0csR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQ29RLFNBQVMsR0FBRyxTQUFVdkssR0FBRztRQUN0QyxPQUFPM0UsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNLFFBQVFnQixNQUFNLENBQUNxQjt3QkFDckIsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDNkMsV0FBVyxDQUFDLFNBQVMsQ0FBQ2xGO3lCQUFLO29CQUN6RCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxHQUFHO0lBQ0gsVUFBVTtJQUNWLEdBQUc7SUFDSDs7Ozs7S0FLQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQ3FRLE1BQU0sR0FBRztRQUN0QixPQUFPblAsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNO3dCQUNOLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ2tGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDc1EsU0FBUyxHQUFHO1FBQ3pCLE9BQU9wUCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRG9CLEdBQUdsQixJQUFJLENBQUNXLElBQUksQ0FBQzs0QkFBQzs0QkFBRzs7NEJBQUs7eUJBQUU7d0JBQ3hCSSxNQUFNO3dCQUNOLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ2tGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQ0RHLEdBQUduQixJQUFJO3dCQUNQLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJO3lCQUFLO29CQUMvQixLQUFLO3dCQUNEbUIsR0FBR25CLElBQUk7d0JBQ1AsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUk7eUJBQU07b0JBQ2hDLEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7eUJBQUc7Z0JBQ2pDO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsR0FBRztJQUNILFNBQVM7SUFDVCxHQUFHO0lBQ0g7Ozs7O0tBS0MsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUM0TCxRQUFRLEdBQUc7UUFDeEIsT0FBTzFLLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTTt3QkFDTixPQUFPOzRCQUFDLEVBQUUsT0FBTzs0QkFBSSxJQUFJLENBQUNrRixXQUFXLENBQUNOLEdBQUcsQ0FBQzVFO3lCQUFLO29CQUNuRCxLQUFLO3dCQUFHLE9BQU87NEJBQUMsRUFBRSxRQUFROzRCQUFJRyxHQUFHbkIsSUFBSTt5QkFBRztnQkFDNUM7WUFDSjtRQUNKO0lBQ0o7SUFDQSxHQUFHO0lBQ0gsV0FBVztJQUNYLEdBQUc7SUFDSDs7Ozs7S0FLQyxHQUNENk0sT0FBT3JQLFNBQVMsQ0FBQ3VRLFVBQVUsR0FBRztRQUMxQixPQUFPclAsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJc0M7WUFDSixPQUFPcEIsWUFBWSxJQUFJLEVBQUUsU0FBVXVCLEVBQUU7Z0JBQ2pDLE9BQVFBLEdBQUdwQixLQUFLO29CQUNaLEtBQUs7d0JBQ0RpQixNQUFNO3dCQUNOLE9BQU87NEJBQUMsRUFBRSxPQUFPOzRCQUFJLElBQUksQ0FBQ2tGLFdBQVcsQ0FBQ04sR0FBRyxDQUFDNUU7eUJBQUs7b0JBQ25ELEtBQUs7d0JBQUcsT0FBTzs0QkFBQyxFQUFFLFFBQVE7NEJBQUlHLEdBQUduQixJQUFJO3lCQUFHO2dCQUM1QztZQUNKO1FBQ0o7SUFDSjtJQUNBLEdBQUc7SUFDSCxTQUFTO0lBQ1QsR0FBRztJQUNIOzs7OztLQUtDLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDd1EsVUFBVSxHQUFHO1FBQzFCLE9BQU90UCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUlzQztZQUNKLE9BQU9wQixZQUFZLElBQUksRUFBRSxTQUFVdUIsRUFBRTtnQkFDakMsT0FBUUEsR0FBR3BCLEtBQUs7b0JBQ1osS0FBSzt3QkFDRGlCLE1BQU07d0JBQ04sT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDa0YsV0FBVyxDQUFDTCxJQUFJLENBQUM3RTt5QkFBSztvQkFDcEQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0Q2TSxPQUFPclAsU0FBUyxDQUFDeVEsYUFBYSxHQUFHLFNBQVVDLE9BQU87UUFDOUMsT0FBT3hQLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXNDO1lBQ0osT0FBT3BCLFlBQVksSUFBSSxFQUFFLFNBQVV1QixFQUFFO2dCQUNqQyxPQUFRQSxHQUFHcEIsS0FBSztvQkFDWixLQUFLO3dCQUNEaUIsTUFBTSxTQUFTZ0IsTUFBTSxDQUFDa00sU0FBUzt3QkFDL0IsT0FBTzs0QkFBQyxFQUFFLE9BQU87NEJBQUksSUFBSSxDQUFDaEksV0FBVyxDQUFDTixHQUFHLENBQUM1RTt5QkFBSztvQkFDbkQsS0FBSzt3QkFBRyxPQUFPOzRCQUFDLEVBQUUsUUFBUTs0QkFBSUcsR0FBR25CLElBQUk7eUJBQUc7Z0JBQzVDO1lBQ0o7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRDZNLE9BQU9yUCxTQUFTLENBQUMyUSxtQkFBbUIsR0FBRyxTQUFVQyxZQUFZLEVBQUVDLFFBQVE7UUFDbkUsSUFBSWpNLFFBQVEsSUFBSVI7UUFDaEIsTUFBTSxJQUFJQSxNQUFNLDZHQUE2R0ksTUFBTSxDQUFDSSxNQUFNbkIsS0FBSyxFQUFFO0lBQ3JKO0lBQ0EsT0FBTzRMO0FBQ1g7QUFFQSxTQUFTeUIsU0FBU3hJLElBQUk7SUFDbEIsT0FBT3lJLE9BQU9DLElBQUksQ0FBQ2pKLEtBQUtDLFNBQVMsQ0FBQ00sT0FBT1QsUUFBUSxDQUFDO0FBQ3REO0FBQ0E7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNvSixLQUFLckssTUFBTSxFQUFFc0ssYUFBYSxFQUFFQyxjQUFjO0lBQy9DLE9BQU81Uix3REFDUSxDQUFDLFVBQVVxSCxRQUNyQjJFLE1BQU0sQ0FBQyxHQUFHL0csTUFBTSxDQUFDME0sZUFBZSxLQUFLMU0sTUFBTSxDQUFDMk0saUJBQzVDRSxNQUFNLENBQUMsVUFDUDlNLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxPQUFPLEtBQ2ZBLE9BQU8sQ0FBQyxNQUFNO0FBQ3ZCO0FBQ0E7Ozs7Q0FJQyxHQUNELFNBQVMrTTtJQUNMLElBQUlDLFNBQVM7UUFDVEMsS0FBSztRQUNMQyxLQUFLO0lBQ1Q7SUFDQSxPQUFPWCxTQUFTUyxRQUFRaE4sT0FBTyxDQUFDLE1BQU07QUFDMUM7QUFDQTs7Ozs7O0NBTUMsR0FDRCxTQUFTbU4sZ0JBQWdCQyxhQUFhO0lBQ2xDLElBQUlDLGNBQWNELGNBQWNDLFdBQVcsRUFBRWhMLFNBQVMrSyxjQUFjL0ssTUFBTSxFQUFFaUwsWUFBWUYsY0FBY0UsU0FBUztJQUMvRyxJQUFJak4sUUFBUSxJQUFJUjtJQUNoQixJQUFJeU4sV0FBVztRQUNYLElBQUksQ0FBRUEsQ0FBQUEscUJBQXFCckksSUFBRyxLQUFNcUksVUFBVUMsT0FBTyxLQUFLdEksS0FBS0MsR0FBRyxJQUFJO1lBQ2xFLE1BQU0sSUFBSXJGLE1BQU0sMElBQTBJSSxNQUFNLENBQUNJLE1BQU1uQixLQUFLLEVBQUU7UUFDbEw7SUFDSjtJQUNBLElBQUltTyxhQUFhO1FBQ2IsSUFBSSxDQUFFLFFBQU9BLGdCQUFnQixZQUFZOVIsTUFBTThLLE9BQU8sQ0FBQ2dILFlBQVcsR0FBSTtZQUNsRSxNQUFNLElBQUl4TixNQUFNLG1HQUFtR0ksTUFBTSxDQUFDSSxNQUFNbkIsS0FBSyxFQUFFO1FBQzNJO0lBQ0o7SUFDQSxJQUFJLENBQUNtRCxVQUFVLE9BQU9BLFdBQVcsVUFBVTtRQUN2QyxNQUFNLElBQUl4QyxNQUFNLCtGQUErRkksTUFBTSxDQUFDSSxNQUFNbkIsS0FBSyxFQUFFO0lBQ3ZJO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU3NPLGNBQWNKLGFBQWE7SUFDaEMsSUFBSUMsY0FBY0QsY0FBY0MsV0FBVyxFQUFFaEwsU0FBUytLLGNBQWMvSyxNQUFNLEVBQUVpTCxZQUFZRixjQUFjRSxTQUFTO0lBQy9HSCxnQkFBZ0JDO0lBQ2hCLElBQUlLLFVBQVU7UUFDVkosYUFBYUE7UUFDYkssY0FBY3JMLE9BQU9zTCxTQUFTLENBQUMsR0FBRztRQUNsQ0MsS0FBS04sY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSSxLQUFLLElBQUlBLFVBQVVDLE9BQU87SUFDaEY7SUFDQSxPQUFPaEIsU0FBU2tCLFNBQVN6TixPQUFPLENBQUMsTUFBTTtBQUMzQztBQUNBLElBQUk2TixRQUFRLFdBQVcsR0FBSTtJQUN2QixTQUFTQSxNQUFNMUwsTUFBTTtRQUNqQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7SUFDbEI7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNEMEwsTUFBTXBTLFNBQVMsQ0FBQzJRLG1CQUFtQixHQUFHLFNBQVVpQixXQUFXLEVBQUV0SCxPQUFPO1FBQ2hFLElBQUkxRCxTQUFTLENBQUMwRCxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUTFELE1BQU0sS0FBSyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsTUFBTSxJQUFJO1FBQ3pHLElBQUlpTCxZQUFZdkgsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVF1SCxTQUFTO1FBQ25GLElBQUlYLGdCQUFnQkk7UUFDcEIsSUFBSUgsaUJBQWlCWSxjQUFjO1lBQUVILGFBQWFBO1lBQWFoTCxRQUFRQTtZQUFRaUwsV0FBV0E7UUFBVTtRQUNwRyxJQUFJUSxZQUFZcEIsS0FBS3JLLFFBQVFzSyxlQUFlQztRQUM1QyxPQUFPLEdBQUczTSxNQUFNLENBQUMwTSxlQUFlLEtBQUsxTSxNQUFNLENBQUMyTSxnQkFBZ0IsS0FBSzNNLE1BQU0sQ0FBQzZOO0lBQzVFO0lBQ0EsT0FBT0Q7QUFDWDtBQUVBLElBQUlFLGNBQWMsV0FBVyxHQUFJLFNBQVVoUCxNQUFNO0lBQzdDbkQsVUFBVW1TLGFBQWFoUDtJQUN2QixTQUFTZ1AsWUFBWTVMLE1BQU07UUFDdkIsSUFBSWhELFFBQVFKLE9BQU9wRCxJQUFJLENBQUMsSUFBSSxFQUFFd0csV0FBVyxJQUFJO1FBQzdDaEQsTUFBTTZPLE1BQU0sR0FBRyxJQUFJSCxNQUFNMUw7UUFDekIsT0FBT2hEO0lBQ1g7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNENE8sWUFBWXRTLFNBQVMsQ0FBQzJRLG1CQUFtQixHQUFHLFNBQVVpQixXQUFXLEVBQUV0SCxPQUFPO1FBQ3RFLElBQUksSUFBa0IsRUFBYTtZQUMvQixPQUFPLElBQUksQ0FBQ2lJLE1BQU0sQ0FBQzVCLG1CQUFtQixDQUFDaUIsYUFBYXRIO1FBQ3hEO1FBQ0EsT0FBT2hILE9BQU90RCxTQUFTLENBQUMyUSxtQkFBbUIsQ0FBQ3pRLElBQUksQ0FBQyxJQUFJLEVBQUUwUixhQUFhdEg7SUFDeEU7SUFDQSxPQUFPZ0k7QUFDWCxFQUFFakQ7QUFFMFIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZWR1c2EtbmV4dC8uL25vZGVfbW9kdWxlcy9tZWlsaXNlYXJjaC9kaXN0L2J1bmRsZXMvbWVpbGlzZWFyY2guZXNtLmpzPzUxOWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdjcm9zcy1mZXRjaC9wb2x5ZmlsbCc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cblxudmFyIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IobWVzc2FnZSwgYm9keSwgdXJsLCBzdGFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3InO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSAnTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3InO1xyXG4gICAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubWVzc2FnZSA9IGJvZHkuc3RhdHVzVGV4dDtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IGJvZHkuc3RhdHVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmVycm5vID0gYm9keS5lcnJubztcclxuICAgICAgICAgICAgX3RoaXMuY29kZSA9IGJvZHkuY29kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YWNrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gc3RhY2s7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gKF9hID0gX3RoaXMuc3RhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC8oVHlwZUVycm9yfEZldGNoRXJyb3IpLywgX3RoaXMubmFtZSk7XHJcbiAgICAgICAgICAgIF90aGlzLnN0YWNrID0gKF9iID0gX3RoaXMuc3RhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKCdGYWlsZWQgdG8gZmV0Y2gnLCBcInJlcXVlc3QgdG8gXCIuY29uY2F0KHVybCwgXCIgZmFpbGVkLCByZWFzb246IGNvbm5lY3QgRUNPTk5SRUZVU0VEXCIpKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhY2sgPSAoX2MgPSBfdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlcGxhY2UoJ05vdCBGb3VuZCcsIFwiTm90IEZvdW5kOiBcIi5jb25jYXQodXJsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yO1xyXG59KEVycm9yKSk7XG5cbnZhciBNZWlsaVNlYXJjaEFwaUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBjbGFzc18xKGVycm9yLCBzdGF0dXMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlcnJvci5tZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hBcGlFcnJvcic7XHJcbiAgICAgICAgX3RoaXMuY29kZSA9IGVycm9yLmNvZGU7XHJcbiAgICAgICAgX3RoaXMudHlwZSA9IGVycm9yLnR5cGU7XHJcbiAgICAgICAgX3RoaXMubGluayA9IGVycm9yLmxpbms7XHJcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgX3RoaXMuaHR0cFN0YXR1cyA9IHN0YXR1cztcclxuICAgICAgICAvLyBNYWtlIGVycm9ycyBjb21wYXJpc29uIHBvc3NpYmxlLiBleDogZXJyb3IgaW5zdGFuY2VvZiBNZWlsaVNlYXJjaEFwaUVycm9yLlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVpbGlTZWFyY2hBcGlFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hBcGlFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFzc18xO1xyXG59KEVycm9yKSk7XG5cbmZ1bmN0aW9uIGh0dHBSZXNwb25zZUVycm9ySGFuZGxlcihyZXNwb25zZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlcnI7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzcG9uc2Uub2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsxLCAzLCAsIDRdKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQsIHJlc3BvbnNlLCByZXNwb25zZS51cmwpO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiB0aHJvdyBuZXcgTWVpbGlTZWFyY2hBcGlFcnJvcihlcnIsIHJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGh0dHBFcnJvckhhbmRsZXIocmVzcG9uc2UsIHN0YWNrLCB1cmwpIHtcclxuICAgIGlmIChyZXNwb25zZS50eXBlICE9PSAnTWVpbGlTZWFyY2hBcGlFcnJvcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IocmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2UsIHVybCwgc3RhY2spO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgcmVzcG9uc2U7XHJcbn1cblxudmFyIE1laWxpU2VhcmNoRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWVpbGlTZWFyY2hFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoRXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9ICdNZWlsaVNlYXJjaEVycm9yJztcclxuICAgICAgICBfdGhpcy50eXBlID0gJ01laWxpU2VhcmNoRXJyb3InO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBNZWlsaVNlYXJjaEVycm9yO1xyXG59KEVycm9yKSk7XG5cbnZhciBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaFRpbWVPdXRFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoVGltZU91dEVycm9yKG1lc3NhZ2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3InO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSBfdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3I7XHJcbn0oRXJyb3IpKTtcblxuLyoqXHJcbiAqIFJlbW92ZXMgdW5kZWZpbmVkIGVudHJpZXMgZnJvbSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3VyRW50cnkpIHtcclxuICAgICAgICB2YXIga2V5ID0gY3VyRW50cnlbMF0sIHZhbCA9IGN1ckVudHJ5WzFdO1xyXG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHt9KTtcclxufVxyXG5mdW5jdGlvbiBzbGVlcChtcykge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBtcyk7IH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFByb3RvY29sSWZOb3RQcmVzZW50KGhvc3QpIHtcclxuICAgIGlmICghKGhvc3Quc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSB8fCBob3N0LnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSkpIHtcclxuICAgICAgICByZXR1cm4gXCJodHRwOi8vXCIuY29uY2F0KGhvc3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhvc3Q7XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhaWxpbmdTbGFzaCh1cmwpIHtcclxuICAgIGlmICghdXJsLmVuZHNXaXRoKCcvJykpIHtcclxuICAgICAgICB1cmwgKz0gJy8nO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVybDtcclxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RIb3N0VVJMKGhvc3QpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaG9zdCA9IGFkZFByb3RvY29sSWZOb3RQcmVzZW50KGhvc3QpO1xyXG4gICAgICAgIGhvc3QgPSBhZGRUcmFpbGluZ1NsYXNoKGhvc3QpO1xyXG4gICAgICAgIHJldHVybiBob3N0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIHByb3ZpZGVkIGhvc3QgaXMgbm90IHZhbGlkLicpO1xyXG4gICAgfVxyXG59XHJcbnZhciBIdHRwUmVxdWVzdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBIdHRwUmVxdWVzdHMoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLmhlYWRlcnMgfHwge30pOyAvLyBhc3NpZ24gdG8gYXZvaWQgcmVmZXJlbmNpbmdcclxuICAgICAgICB0aGlzLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgICAgIGlmIChjb25maWcuYXBpS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gXCJCZWFyZXIgXCIuY29uY2F0KGNvbmZpZy5hcGlLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgaG9zdCA9IGNvbnN0cnVjdEhvc3RVUkwoY29uZmlnLmhvc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IG5ldyBVUkwoaG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKCdUaGUgcHJvdmlkZWQgaG9zdCBpcyBub3QgdmFsaWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IF9hLm1ldGhvZCwgdXJsID0gX2EudXJsLCBwYXJhbXMgPSBfYS5wYXJhbXMsIGJvZHkgPSBfYS5ib2R5LCBjb25maWcgPSBfYS5jb25maWc7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0VVJMLCBxdWVyeVBhcmFtc18xLCByZXNwb25zZSwgcGFyc2VkQm9keSwgcGFyc2VkSnNvbiwgZV8xLCBzdGFjaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0VVJMID0gbmV3IFVSTCh1cmwsIHRoaXMudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNfMSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBwYXJhbXNbeF0gIT09IG51bGw7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcXVlcnlQYXJhbXNfMS5zZXQoeCwgcGFyYW1zW3hdKTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RVUkwuc2VhcmNoID0gcXVlcnlQYXJhbXNfMS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnRyeXMucHVzaChbMSwgNCwgLCA1XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKGNvbnN0cnVjdFVSTC50b1N0cmluZygpLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29uZmlnKSwgeyBtZXRob2Q6IG1ldGhvZCwgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksIGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KSkudGhlbihmdW5jdGlvbiAocmVzKSB7IHJldHVybiBodHRwUmVzcG9uc2VFcnJvckhhbmRsZXIocmVzKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLnRleHQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRCb2R5ID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSnNvbiA9IEpTT04ucGFyc2UocGFyc2VkQm9keSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGFyc2VkSnNvbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBlXzEuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBFcnJvckhhbmRsZXIoZV8xLCBzdGFjaywgY29uc3RydWN0VVJMLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIdHRwUmVxdWVzdHMucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSHR0cFJlcXVlc3RzO1xyXG59KCkpO1xuXG52YXIgVGFza0NsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhc2tDbGllbnQoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcclxuICAgIH1cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmdldENsaWVudFRhc2sgPSBmdW5jdGlvbiAodWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInRhc2tzL1wiLmNvbmNhdCh1aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS5nZXRDbGllbnRUYXNrcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3NcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhUYXNrID0gZnVuY3Rpb24gKGluZGV4VWlkLCB0YXNrSWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQoaW5kZXhVaWQsIFwiL3Rhc2tzL1wiKS5jb25jYXQodGFza0lkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhUYXNrcyA9IGZ1bmN0aW9uIChpbmRleFVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdChpbmRleFVpZCwgXCIvdGFza3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSB0YXNrIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdWlkIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gb3B0aW9ucyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VGFzaz59IFByb21pc2UgcmV0dXJuaW5nIGEgdGFzayBhZnRlciBpdCBoYXMgYmVlbiBwcm9jZXNzZWRcclxuICAgICAqL1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUud2FpdEZvckNsaWVudFRhc2sgPSBmdW5jdGlvbiAodGFza0lkLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnRpbWVPdXRNcywgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYywgX2QgPSBfYi5pbnRlcnZhbE1zLCBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdUaW1lLCByZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoRGF0ZS5ub3coKSAtIHN0YXJ0aW5nVGltZSA8IHRpbWVPdXRNcykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldENsaWVudFRhc2sodGFza0lkKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFbXCJlbnF1ZXVlZFwiIC8qIFRBU0tfRU5RVUVVRUQgKi8sIFwicHJvY2Vzc2luZ1wiIC8qIFRBU0tfUFJPQ0VTU0lORyAqL10uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNsZWVwKGludGVydmFsTXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiB0aHJvdyBuZXcgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IoXCJ0aW1lb3V0IG9mIFwiLmNvbmNhdCh0aW1lT3V0TXMsIFwibXMgaGFzIGV4Y2VlZGVkIG9uIHByb2Nlc3MgXCIpLmNvbmNhdCh0YXNrSWQsIFwiIHdoZW4gd2FpdGluZyBhIHRhc2sgdG8gYmUgcmVzb2x2ZWQuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0cyBmb3IgbXVsdGlwbGUgdGFza3MgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZHMgVGFza3MgaWRlbnRpZmllciBsaXN0XHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSBvcHRpb25zIFdhaXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0PFRhc2tbXT4+fSBQcm9taXNlIHJldHVybmluZyBhIGxpc3Qgb2YgdGFza3MgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gcHJvY2Vzc2VkXHJcbiAgICAgKi9cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLndhaXRGb3JDbGllbnRUYXNrcyA9IGZ1bmN0aW9uICh0YXNrSWRzLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnRpbWVPdXRNcywgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYywgX2QgPSBfYi5pbnRlcnZhbE1zLCBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdGFza3MsIF9pLCB0YXNrSWRzXzEsIHRhc2tJZCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCB0YXNrSWRzXzEgPSB0YXNrSWRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IHRhc2tJZHNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza0lkID0gdGFza0lkc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy53YWl0Rm9yQ2xpZW50VGFzayh0YXNrSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0TXM6IHRpbWVPdXRNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHRhc2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB7IHJlc3VsdHM6IHRhc2tzIH1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhaXRzIGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCBUYXNrIGlkZW50aWZpZXJcclxuICAgICAqIEBwYXJhbSB7V2FpdE9wdGlvbnN9IG9wdGlvbnMgV2FpdCBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gUHJvbWlzZSByZXR1cm5pbmcgYSB0YXNrIGFmdGVyIGl0IGhhcyBiZWVuIHByb2Nlc3NlZFxyXG4gICAgICovXHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9ySW5kZXhUYXNrID0gZnVuY3Rpb24gKGluZGV4VWlkLCB0YXNrSWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGFydGluZ1RpbWUsIHJlc3BvbnNlO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9lLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydGluZ1RpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShEYXRlLm5vdygpIC0gc3RhcnRpbmdUaW1lIDwgdGltZU91dE1zKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0SW5kZXhUYXNrKGluZGV4VWlkLCB0YXNrSWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVtcImVucXVldWVkXCIgLyogVEFTS19FTlFVRVVFRCAqLywgXCJwcm9jZXNzaW5nXCIgLyogVEFTS19QUk9DRVNTSU5HICovXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2xlZXAoaW50ZXJ2YWxNcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHRocm93IG5ldyBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvcihcInRpbWVvdXQgb2YgXCIuY29uY2F0KHRpbWVPdXRNcywgXCJtcyBoYXMgZXhjZWVkZWQgb24gcHJvY2VzcyBcIikuY29uY2F0KHRhc2tJZCwgXCIgd2hlbiB3YWl0aW5nIGZvciBwZW5kaW5nIHVwZGF0ZSB0byByZXNvbHZlLlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrQ2xpZW50O1xyXG59KCkpO1xuXG4vKlxyXG4gKiBCdW5kbGU6IE1laWxpU2VhcmNoIC8gSW5kZXhlc1xyXG4gKiBQcm9qZWN0OiBNZWlsaVNlYXJjaCAtIEphdmFzY3JpcHQgQVBJXHJcbiAqIEF1dGhvcjogUXVlbnRpbiBkZSBRdWVsZW4gPHF1ZW50aW5AbWVpbGlzZWFyY2guY29tPlxyXG4gKiBDb3B5cmlnaHQ6IDIwMTksIE1laWxpU2VhcmNoXHJcbiAqL1xyXG52YXIgSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Q29uZmlnfSBjb25maWcgUmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVUlEIG9mIHRoZSBpbmRleFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlLZXk/IFByaW1hcnkgS2V5IG9mIHRoZSBpbmRleFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJbmRleChjb25maWcsIHVpZCwgcHJpbWFyeUtleSkge1xyXG4gICAgICAgIHRoaXMudWlkID0gdWlkO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeUtleSA9IHByaW1hcnlLZXk7XHJcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcclxuICAgICAgICB0aGlzLnRhc2tzID0gbmV3IFRhc2tDbGllbnQoY29uZmlnKTtcclxuICAgIH1cclxuICAgIC8vL1xyXG4gICAgLy8vIFNFQVJDSFxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgZG9jdW1lbnRzIGludG8gYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBzZWFyY2hcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHF1ZXJ5PyBRdWVyeSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U2VhcmNoUGFyYW1zfSBvcHRpb25zPyBTZWFyY2ggb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPFJlcXVlc3Q+fSBjb25maWc/IEFkZGl0aW9uYWwgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlYXJjaFJlc3BvbnNlPFQ+Pn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZWFyY2hcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3QoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHE6IHF1ZXJ5IH0pKSwgdW5kZWZpbmVkLCBjb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaCBmb3IgZG9jdW1lbnRzIGludG8gYW4gaW5kZXggdXNpbmcgdGhlIEdFVCBtZXRob2RcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBzZWFyY2hcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHF1ZXJ5PyBRdWVyeSBzdHJpbmdcclxuICAgICAqIEBwYXJhbSB7U2VhcmNoUGFyYW1zfSBvcHRpb25zPyBTZWFyY2ggb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtQYXJ0aWFsPFJlcXVlc3Q+fSBjb25maWc/IEFkZGl0aW9uYWwgcmVxdWVzdCBjb25maWd1cmF0aW9uIG9wdGlvbnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFNlYXJjaFJlc3BvbnNlPFQ+Pn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaEdldCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHBhcnNlRmlsdGVyLCBnZXRQYXJhbXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NlYXJjaFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIGZpbHRlciBxdWVyeSBwYXJhbWV0ZXIgc2hvdWxkIGJlIGluIHN0cmluZyBmb3JtYXQgd2hlbiB1c2luZyBzZWFyY2hHZXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHE6IHF1ZXJ5IH0sIG9wdGlvbnMpLCB7IGZpbHRlcjogcGFyc2VGaWx0ZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlciksIHNvcnQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCcpLCBmYWNldHNEaXN0cmlidXRpb246IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWNldHNEaXN0cmlidXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1RvUmV0cmlldmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb0Nyb3A6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9Dcm9wKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quam9pbignLCcpLCBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9IaWdobGlnaHQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5qb2luKCcsJykgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChnZXRQYXJhbXMpLCBjb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZi5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBJTkRFWFxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCBpbmRleCBpbmZvcm1hdGlvbi5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRSYXdJbmZvXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleFJlc3BvbnNlPn0gUHJvbWlzZSBjb250YWluaW5nIGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRSYXdJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgcmVzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpbWFyeUtleSA9IHJlcy5wcmltYXJ5S2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaCBhbmQgdXBkYXRlIEluZGV4IGluZm9ybWF0aW9uLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGZldGNoSW5mb1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dGhpcz59IFByb21pc2UgdG8gdGhlIGN1cnJlbnQgSW5kZXggb2JqZWN0IHdpdGggdXBkYXRlZCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZmV0Y2hJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSYXdJbmZvKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IFByaW1hcnkgS2V5LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGZldGNoUHJpbWFyeUtleVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPn0gUHJvbWlzZSBjb250YWluaW5nIHRoZSBQcmltYXJ5IEtleSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmZldGNoUHJpbWFyeUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZm8oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5wcmltYXJ5S2V5ID0gKF9iLnNlbnQoKSkucHJpbWFyeUtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucHJpbWFyeUtleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluZGV4LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIEluZGV4XHJcbiAgICAgKiBAcGFyYW0ge0luZGV4T3B0aW9uc30gb3B0aW9ucyBJbmRleCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIFJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleDxUPj59IE5ld2x5IGNyZWF0ZWQgSW5kZXggb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEluZGV4LmNyZWF0ZSA9IGZ1bmN0aW9uICh1aWQsIG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCByZXE7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlc1wiO1xyXG4gICAgICAgICAgICAgICAgcmVxID0gbmV3IEh0dHBSZXF1ZXN0cyhjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlcS5wb3N0KHVybCwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHVpZDogdWlkIH0pKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGluZGV4LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtJbmRleE9wdGlvbnN9IGRhdGEgRGF0YSB0byB1cGRhdGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHRoaXM+fSBQcm9taXNlIHRvIHRoZSBjdXJyZW50IEluZGV4IG9iamVjdCB3aXRoIHVwZGF0ZWQgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBkYXRhKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW4gaW5kZXguXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGluZGV4IGlzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFRBU0tTXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCB0aGUgaW5kZXggdGFza3MuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4ZXNcclxuICAgICAqIEBtZXRob2QgZ2V0VGFza3NcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSBjb250YWluaW5nIGFsbCB0YXNrc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldEluZGV4VGFza3ModGhpcy51aWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgdGFzayBvZiB0aGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4ZXNcclxuICAgICAqIEBtZXRob2QgZ2V0VGFza1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRhc2s+fSAtIFByb21pc2UgY29udGFpbmluZyBhIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAodGFza0lkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldEluZGV4VGFzayh0aGlzLnVpZCwgdGFza0lkKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBhIGJhdGNoIG9mIGFuIGluZGV4IHRhc2tzIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhlc1xyXG4gICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza3NcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRhc2tJZHMgLSBUYXNrcyBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSB3YWl0T3B0aW9ucyAtIE9wdGlvbnMgb24gdGltZW91dCBhbmQgaW50ZXJ2YWxcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSBjb250YWluaW5nIGFuIGFycmF5IG9mIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza0lkcywgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi50aW1lT3V0TXMsIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsIF9kID0gX2IuaW50ZXJ2YWxNcywgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yQ2xpZW50VGFza3ModGFza0lkcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhaXQgZm9yIGFuIGluZGV4IHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleGVzXHJcbiAgICAgKiBAbWV0aG9kIHdhaXRGb3JUYXNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza0lkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0ge1dhaXRPcHRpb25zfSB3YWl0T3B0aW9ucyAtIE9wdGlvbnMgb24gdGltZW91dCBhbmQgaW50ZXJ2YWxcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gLSBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLndhaXRGb3JUYXNrID0gZnVuY3Rpb24gKHRhc2tJZCwgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi50aW1lT3V0TXMsIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsIF9kID0gX2IuaW50ZXJ2YWxNcywgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yQ2xpZW50VGFzayh0YXNrSWQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RBVFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBnZXQgc3RhdHMgb2YgYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTdGF0c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXhTdGF0cz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgd2l0aCBzdGF0cyBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc3RhdHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIERPQ1VNRU5UU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIGdldCBkb2N1bWVudHMgb2YgYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREb2N1bWVudHNcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge0dldERvY3VtZW50c1BhcmFtczxUPn0gb3B0aW9ucz8gT3B0aW9ucyB0byBicm93c2UgdGhlIGRvY3VtZW50c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8R2V0RG9jdW1lbnRzUmVzcG9uc2U8VD4+fSBQcm9taXNlIGNvbnRhaW5pbmcgRG9jdW1lbnQgcmVzcG9uc2VzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXREb2N1bWVudHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgYXR0cjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5hdHRyaWJ1dGVzVG9SZXRyaWV2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBvcHRpb25zLmF0dHJpYnV0ZXNUb1JldHJpZXZlLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgKGF0dHIgIT09IHVuZGVmaW5lZCA/IHsgYXR0cmlidXRlc1RvUmV0cmlldmU6IGF0dHIgfSA6IHt9KSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgZG9jdW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREb2N1bWVudFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBkb2N1bWVudElkIERvY3VtZW50IElEXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxEb2N1bWVudDxUPj59IFByb21pc2UgY29udGFpbmluZyBEb2N1bWVudCByZXNwb25zZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnRJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzL1wiKS5jb25jYXQoZG9jdW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIG9yIHJlcGxhY2UgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleFxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGFkZERvY3VtZW50c1xyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ8VD4+fSBkb2N1bWVudHMgQXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cyB0byBhZGQvcmVwbGFjZVxyXG4gICAgICogQHBhcmFtIHtBZGREb2N1bWVudFBhcmFtc30gb3B0aW9ucz8gUXVlcnkgcGFyYW1ldGVyc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5hZGREb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIGRvY3VtZW50cywgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIG9yIHJlcGxhY2UgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgYWRkRG9jdW1lbnRzSW5CYXRjaGVzXHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC9yZXBsYWNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmF0Y2hTaXplIFNpemUgb2YgdGhlIGJhdGNoXHJcbiAgICAgKiBAcGFyYW0ge0FkZERvY3VtZW50UGFyYW1zfSBvcHRpb25zPyBRdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2tzPn0gUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIGVucXVldWVkIHVwZGF0ZSBvYmplY3RzIGZvciBlYWNoIGJhdGNoXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5hZGREb2N1bWVudHNJbkJhdGNoZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzLCBiYXRjaFNpemUsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoYmF0Y2hTaXplID09PSB2b2lkIDApIHsgYmF0Y2hTaXplID0gMTAwMDsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVwZGF0ZXMsIGksIF9hLCBfYjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGRvY3VtZW50cy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB1cGRhdGVzKS5wdXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmFkZERvY3VtZW50cyhkb2N1bWVudHMuc2xpY2UoaSwgaSArIGJhdGNoU2l6ZSksIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gYmF0Y2hTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB1cGRhdGVzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb3IgdXBkYXRlIG11bHRpcGxlcyBkb2N1bWVudHMgdG8gYW4gaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVEb2N1bWVudHNcclxuICAgICAqIEBwYXJhbSB7QXJyYXk8RG9jdW1lbnQ8UGFydGlhbDxUPj4+fSBkb2N1bWVudHMgQXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cyB0byBhZGQvdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge0FkZERvY3VtZW50UGFyYW1zfSBvcHRpb25zPyBRdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50cyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBkb2N1bWVudHMsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBvciB1cGRhdGUgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleCBpbiBiYXRjaGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRG9jdW1lbnRzXHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtBcnJheTxEb2N1bWVudDxUPj59IGRvY3VtZW50cyBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXRjaFNpemUgU2l6ZSBvZiB0aGUgYmF0Y2hcclxuICAgICAqIEBwYXJhbSB7QWRkRG9jdW1lbnRQYXJhbXN9IG9wdGlvbnM/IFF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFza3M+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2YgZW5xdWV1ZWQgdXBkYXRlIG9iamVjdHMgZm9yIGVhY2ggYmF0Y2hcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50c0luQmF0Y2hlcyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIGJhdGNoU2l6ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChiYXRjaFNpemUgPT09IHZvaWQgMCkgeyBiYXRjaFNpemUgPSAxMDAwOyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXBkYXRlcywgaSwgX2EsIF9iO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgZG9jdW1lbnRzLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHVwZGF0ZXMpLnB1c2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudXBkYXRlRG9jdW1lbnRzKGRvY3VtZW50cy5zbGljZShpLCBpICsgYmF0Y2hTaXplKSwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVwZGF0ZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBvbmUgZG9jdW1lbnRcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBkZWxldGVEb2N1bWVudFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGRvY3VtZW50SWQgSWQgb2YgRG9jdW1lbnQgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvXCIpLmNvbmNhdChkb2N1bWVudElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBtdWx0aXBsZXMgZG9jdW1lbnRzIG9mIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlRG9jdW1lbnRzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgbnVtYmVyW119IGRvY3VtZW50c0lkcyBBcnJheSBvZiBEb2N1bWVudCBJZHMgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzSWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvZGVsZXRlLWJhdGNoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHNJZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhbGwgZG9jdW1lbnRzIG9mIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZGVsZXRlQWxsRG9jdW1lbnRzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVBbGxEb2N1bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU0VUVElOR1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhbGwgc2V0dGluZ3NcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2V0dGluZ3M+fSBQcm9taXNlIGNvbnRhaW5pbmcgU2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbGwgc2V0dGluZ3NcclxuICAgICAqIEFueSBwYXJhbWV0ZXJzIG5vdCBwcm92aWRlZCB3aWxsIGJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge1NldHRpbmdzfSBzZXR0aW5ncyBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzIHdpdGggdGhlaXIgdXBkYXRlZCB2YWx1ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5nc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc2V0dGluZ3MpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHNldHRpbmdzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0U2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5nc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBTWU5PTllNU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgc3lub255bXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTeW5vbnltc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiBzeW5vbnltIG1hcHBpbmdzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTeW5vbnltcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3N5bm9ueW1zXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBzeW5vbnltcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTeW5vbnltc1xyXG4gICAgICogQHBhcmFtIHtTeW5vbnltc30gc3lub255bXMgTWFwcGluZyBvZiBzeW5vbnltcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd29yZHNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVN5bm9ueW1zID0gZnVuY3Rpb24gKHN5bm9ueW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zeW5vbnltc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc3lub255bXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzeW5vbnltIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFN5bm9ueW1zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB0YXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN5bm9ueW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3lub255bXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RPUCBXT1JEU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgc3RvcC13b3Jkc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFN0b3BXb3Jkc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc3RvcC13b3Jkc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U3RvcFdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2Ygc3RvcC13b3Jkcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTdG9wV29yZHNcclxuICAgICAqIEBwYXJhbSB7U3RvcFdvcmRzfSBzdG9wV29yZHMgQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHRoZSBzdG9wLXdvcmRzLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTdG9wV29yZHMgPSBmdW5jdGlvbiAoc3RvcFdvcmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zdG9wLXdvcmRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBzdG9wV29yZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzdG9wLXdvcmRzIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFN0b3BXb3Jkc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN0b3BXb3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3N0b3Atd29yZHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gUkFOS0lORyBSVUxFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgcmFua2luZy1ydWxlc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFJhbmtpbmdSdWxlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW119IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiByYW5raW5nLXJ1bGVzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRSYW5raW5nUnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiByYW5raW5nLXJ1bGVzLiBPdmVyd3JpdGUgdGhlIG9sZCBsaXN0LlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVJhbmtpbmdSdWxlc1xyXG4gICAgICogQHBhcmFtIHtSYW5raW5nUnVsZXN9IHJhbmtpbmdSdWxlcyBBcnJheSB0aGF0IGNvbnRhaW4gcmFua2luZyBydWxlcyBzb3J0ZWQgYnkgb3JkZXIgb2YgaW1wb3J0YW5jZS5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlUmFua2luZ1J1bGVzID0gZnVuY3Rpb24gKHJhbmtpbmdSdWxlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcmFua2luZy1ydWxlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgcmFua2luZ1J1bGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgcmFua2luZyBydWxlcyBsaXN0IHRvIGl0cyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgcmVzZXRSYW5raW5nUnVsZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRSYW5raW5nUnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIERJU1RJTkNUIEFUVFJJQlVURVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlzdGluY3QtYXR0cmlidXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0RGlzdGluY3RBdHRyaWJ1dGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZyB8IG51bGw+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGRpc3RpbmN0LWF0dHJpYnV0ZSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldERpc3RpbmN0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlzdGluY3QtYXR0cmlidXRlLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZURpc3RpbmN0QXR0cmlidXRlXHJcbiAgICAgKiBAcGFyYW0ge0Rpc3RpbmN0QXR0cmlidXRlfSBkaXN0aW5jdEF0dHJpYnV0ZSBGaWVsZCBuYW1lIG9mIHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGVcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRGlzdGluY3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoZGlzdGluY3RBdHRyaWJ1dGUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3RpbmN0LWF0dHJpYnV0ZVwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgZGlzdGluY3RBdHRyaWJ1dGUpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGUuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgcmVzZXREaXN0aW5jdEF0dHJpYnV0ZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3RpbmN0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIEZJTFRFUkFCTEUgQVRUUklCVVRFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gUHJvbWlzZSBjb250YWluaW5nIGFuIGFycmF5IG9mIGZpbHRlcmFibGUtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBmaWx0ZXJhYmxlLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRmlsdGVyYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEBwYXJhbSB7RmlsdGVyYWJsZUF0dHJpYnV0ZXN9IGZpbHRlcmFibGVBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGZpbHRlcnMgYXQgcXVlcnkgdGltZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVGaWx0ZXJhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChmaWx0ZXJhYmxlQXR0cmlidXRlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBmaWx0ZXJhYmxlQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGZpbHRlcmFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldEZpbHRlcmFibGVBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9maWx0ZXJhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU09SVEFCTEUgQVRUUklCVVRFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc29ydGFibGUtYXR0cmlidXRlc1xyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIGdldFNvcnRhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc29ydGFibGUtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U29ydGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHNvcnRhYmxlLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlU29ydGFibGVBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcGFyYW0ge1NvcnRhYmxlQXR0cmlidXRlc30gc29ydGFibGVBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIHRvIHNvcnQgc2VhcmNoIHJlc3VsdHMgYXQgcXVlcnkgdGltZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlU29ydGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNvcnRhYmxlQXR0cmlidXRlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgc29ydGFibGVBdHRyaWJ1dGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc29ydGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFNvcnRhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zb3J0YWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFNFQVJDSEFCTEUgQVRUUklCVVRFXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzZWFyY2hhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXRTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZWFyY2hhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3NlYXJjaGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHNlYXJjaGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVTZWFyY2hhYmxlQXR0cmlidXRlc1xyXG4gICAgICogQHBhcmFtIHtTZWFyY2hhYmxlQXR0cmlidXRlc30gc2VhcmNoYWJsZUF0dHJpYnV0ZXMgQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHNlYXJjaGFibGUgYXR0cmlidXRlcyBzb3J0ZWQgYnkgb3JkZXIgb2YgaW1wb3J0YW5jZShtb3N0IHRvIGxlYXN0IGltcG9ydGFudClcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVNlYXJjaGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHNlYXJjaGFibGVBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zZWFyY2hhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHNlYXJjaGFibGVBdHRyaWJ1dGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc2VhcmNoYWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zZWFyY2hhYmxlLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRElTUExBWUVEIEFUVFJJQlVURVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXNcclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCBnZXREaXNwbGF5ZWRBdHRyaWJ1dGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBkaXNwbGF5ZWQtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlRGlzcGxheWVkQXR0cmlidXRlc1xyXG4gICAgICogQHBhcmFtIHtEaXNwbGF5ZWRBdHRyaWJ1dGVzfSBkaXNwbGF5ZWRBdHRyaWJ1dGVzIEFycmF5IG9mIHN0cmluZ3MgdGhhdCBjb250YWlucyBhdHRyaWJ1dGVzIG9mIGFuIGluZGV4IHRvIGRpc3BsYXlcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRGlzcGxheWVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChkaXNwbGF5ZWRBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9kaXNwbGF5ZWQtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgZGlzcGxheWVkQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRpc3BsYXllZC1hdHRyaWJ1dGVzLlxyXG4gICAgICogQG1lbWJlcm9mIEluZGV4XHJcbiAgICAgKiBAbWV0aG9kIHJlc2V0RGlzcGxheWVkQXR0cmlidXRlc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWRUYXNrPn0gUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3BsYXllZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9kaXNwbGF5ZWQtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBUWVBPIFRPTEVSQU5DRVxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgZ2V0VHlwb1RvbGVyYW5jZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VHlwb1RvbGVyYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAbWVtYmVyb2YgSW5kZXhcclxuICAgICAqIEBtZXRob2QgdXBkYXRlVHlwb1RvbGVyYW5jZVxyXG4gICAgICogQHBhcmFtIHtUeXBvVG9sZXJhbmNlfSB0eXBvVG9sZXJhbmNlIE9iamVjdCBjb250YWluaW5nIHRoZSBjdXN0b20gdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbnF1ZXVlZFRhc2s+fSBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVR5cG9Ub2xlcmFuY2UgPSBmdW5jdGlvbiAodHlwb1RvbGVyYW5jZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvdHlwby10b2xlcmFuY2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHR5cG9Ub2xlcmFuY2UpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAqIEBtZW1iZXJvZiBJbmRleFxyXG4gICAgICogQG1ldGhvZCByZXNldFR5cG9Ub2xlcmFuY2VcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkVGFzaz59IFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRUeXBvVG9sZXJhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvdHlwby10b2xlcmFuY2VcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluZGV4O1xyXG59KCkpO1xuXG4vKlxyXG4gKiBCdW5kbGU6IE1laWxpU2VhcmNoXHJcbiAqIFByb2plY3Q6IE1laWxpU2VhcmNoIC0gSmF2YXNjcmlwdCBBUElcclxuICogQXV0aG9yOiBRdWVudGluIGRlIFF1ZWxlbiA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+XHJcbiAqIENvcHlyaWdodDogMjAxOSwgTWVpbGlTZWFyY2hcclxuICovXHJcbnZhciBDbGllbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IE1laWxpU2VhcmNoIGluc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0ge0NvbmZpZ30gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENsaWVudChjb25maWcpIHtcclxuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgICAgICB0aGlzLmh0dHBSZXF1ZXN0ID0gbmV3IEh0dHBSZXF1ZXN0cyhjb25maWcpO1xyXG4gICAgICAgIHRoaXMudGFza3MgPSBuZXcgVGFza0NsaWVudChjb25maWcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gSW5kZXggaW5zdGFuY2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBpbmRleFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmRleFVpZCBUaGUgaW5kZXggVUlEXHJcbiAgICAgKiBAcmV0dXJucyB7SW5kZXg8VD59IEluc3RhbmNlIG9mIEluZGV4XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4KHRoaXMuY29uZmlnLCBpbmRleFVpZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kZXggYnkgY2FsbGluZyBNZWlsaVNlYXJjaCBhbmRcclxuICAgICAqIHJldHVybiBhbiBJbmRleCBpbnN0YW5jZSB3aXRoIHRoZSBnYXRoZXJlZCBpbmZvcm1hdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldEluZGV4XHJcbiAgICAgKiBAdGVtcGxhdGUgVFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4VWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4PFQ+Pn0gUHJvbWlzZSByZXR1cm5pbmcgSW5kZXggaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uIChpbmRleFVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgaW5kZXhVaWQpLmZldGNoSW5mbygpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kZXggYnkgY2FsbGluZyBNZWlsaVNlYXJjaCBhbmRcclxuICAgICAqIHJldHVybiB0aGUgcmF3IEpTT04gcmVzcG9uc2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRSYXdJbmRleFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluZGV4VWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4UmVzcG9uc2U+fSBQcm9taXNlIHJldHVybmluZyBpbmRleCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFJhd0luZGV4ID0gZnVuY3Rpb24gKGluZGV4VWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEluZGV4KHRoaXMuY29uZmlnLCBpbmRleFVpZCkuZ2V0UmF3SW5mbygpXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHRoZSBpbmRleGVzIGFzIEluZGV4IGluc3RhbmNlcy5cclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRJbmRleGVzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleFtdPn0gUHJvbWlzZSByZXR1cm5pbmcgYXJyYXkgb2YgcmF3IGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgaW5kZXhlcztcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRSYXdJbmRleGVzKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMgPSByZXNwb25zZS5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBuZXcgSW5kZXgoX3RoaXMuY29uZmlnLCBpbmRleC51aWQsIGluZGV4LnByaW1hcnlLZXkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGluZGV4ZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgdGhlIGluZGV4ZXMgaW4gdGhlaXIgcmF3IHZhbHVlIChubyBJbmRleCBpbnN0YW5jZXMpLlxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldFJhd0luZGV4ZXNcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEluZGV4UmVzcG9uc2VbXT59IFByb21pc2UgcmV0dXJuaW5nIGFycmF5IG9mIHJhdyBpbmRleCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFJhd0luZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5kZXhcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBjcmVhdGVJbmRleFxyXG4gICAgICogQHRlbXBsYXRlIFRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIGluZGV4IFVJRFxyXG4gICAgICogQHBhcmFtIHtJbmRleE9wdGlvbnN9IG9wdGlvbnMgSW5kZXggb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW5kZXg8VD4+fSBQcm9taXNlIHJldHVybmluZyBJbmRleCBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBJbmRleC5jcmVhdGUodWlkLCBvcHRpb25zLCB0aGlzLmNvbmZpZyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgdXBkYXRlSW5kZXhcclxuICAgICAqIEB0ZW1wbGF0ZSBUXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEBwYXJhbSB7SW5kZXhPcHRpb25zfSBvcHRpb25zIEluZGV4IG9wdGlvbnMgdG8gdXBkYXRlXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbmRleDxUPj59IFByb21pc2UgcmV0dXJuaW5nIEluZGV4IGluc3RhbmNlIGFmdGVyIHVwZGF0aW5nXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUudXBkYXRlSW5kZXggPSBmdW5jdGlvbiAodWlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgdWlkKS51cGRhdGUob3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIGFuIGluZGV4XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZGVsZXRlSW5kZXhcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIGluZGV4IFVJRFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBpbmRleCBpcyBkZWxldGVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IEluZGV4KHRoaXMuY29uZmlnLCB1aWQpW1wiZGVsZXRlXCJdKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyBhbiBpbmRleCBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBkZWxldGVJbmRleElmRXhpc3RzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRydWUgd2hlbiBpbmRleCBleGlzdHMgYW5kIGlzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBvdGhlcndpc2UgZmFsc2UgaWYgaXQgZG9lcyBub3QgZXhpc3RcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5kZWxldGVJbmRleElmRXhpc3RzID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVfMTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5kZWxldGVJbmRleCh1aWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZV8xID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZV8xLmNvZGUgPT09IFwiaW5kZXhfbm90X2ZvdW5kXCIgLyogSU5ERVhfTk9UX0ZPVU5EICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gVEFTS1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIGNsaWVudCB0YXNrc1xyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdldFRhc2tzXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ8VGFza1tdPj59IC0gUHJvbWlzZSByZXR1cm5pbmcgYWxsIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldENsaWVudFRhc2tzKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSB0YXNrIG9uIHRoZSBjbGllbnQgc2NvcGVcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRUYXNrXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFza0lkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYXNrPn0gLSBQcm9taXNlIHJldHVybmluZyBhIHRhc2tcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRUYXNrID0gZnVuY3Rpb24gKHRhc2tJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy5nZXRDbGllbnRUYXNrKHRhc2tJZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSBiYXRjaCBvZiB0YXNrcyB0byBiZSBwcm9jZXNzZWQuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2Qgd2FpdEZvclRhc2tzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0YXNrSWRzIC0gVGFza3MgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0PFRhc2tbXT4+fSAtIFByb21pc2UgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUud2FpdEZvclRhc2tzID0gZnVuY3Rpb24gKHRhc2tJZHMsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvckNsaWVudFRhc2tzKHRhc2tJZHMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCB3YWl0Rm9yVGFza1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRhc2tJZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHtXYWl0T3B0aW9uc30gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VGFzaz59IC0gUHJvbWlzZSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFzayA9IGZ1bmN0aW9uICh0YXNrSWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvckNsaWVudFRhc2sodGFza0lkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0TXM6IHRpbWVPdXRNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsTXM6IGludGVydmFsTXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9lLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIEtFWVNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIEFQSSBrZXlzXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0S2V5c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5cz59IFByb21pc2UgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGtleXNcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSBBUEkga2V5XHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0S2V5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIEtleVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5cz59IFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzL1wiLmNvbmNhdChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBvbmUgQVBJIGtleVxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUtleVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7S2V5UGF5bG9hZH0gb3B0aW9ucyAtIEtleSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXk+fSBQcm9taXNlIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBrZXlzXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlS2V5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5c1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBvcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgb25lIEFQSSBrZXlcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCB1cGRhdGVLZXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gS2V5XHJcbiAgICAgKiBAcGFyYW0ge0tleVBheWxvYWR9IG9wdGlvbnMgLSBLZXkgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8S2V5Pn0gUHJvbWlzZSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGgga2V5c1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLnVwZGF0ZUtleSA9IGZ1bmN0aW9uIChrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wYXRjaCh1cmwsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBvbmUgQVBJIGtleVxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGRlbGV0ZUtleVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBLZXlcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFZvaWQ+fVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwia2V5cy9cIi5jb25jYXQoa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBIRUFMVEhcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5LCBvdGhlcndpc2UgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgaGVhbHRoXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxIZWFsdGg+fSBQcm9taXNlIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBoZWFsdGggZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmhlYWx0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaGVhbHRoXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBzZXJ2ZXIgaXMgaGVhbHRoeSwgcmV0dXJuIHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgaXNIZWFsdGh5XHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUHJvbWlzZSByZXR1cm5pbmcgYSBib29sZWFuXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuaXNIZWFsdGh5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCAyLCAsIDNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJoZWFsdGhcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZhbHNlXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU1RBVFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHN0YXRzIG9mIGFsbCB0aGUgZGF0YWJhc2VcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXRTdGF0c1xyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U3RhdHM+fSBQcm9taXNlIHJldHVybmluZyBvYmplY3Qgb2YgYWxsIHRoZSBzdGF0c1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJzdGF0c1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBWRVJTSU9OXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB2ZXJzaW9uIG9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWVtYmVyb2YgTWVpbGlTZWFyY2hcclxuICAgICAqIEBtZXRob2QgZ2V0VmVyc2lvblxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VmVyc2lvbj59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCB3aXRoIHZlcnNpb24gZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInZlcnNpb25cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRFVNUFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhIGR1bXAgY3JlYXRpb24gcHJvY2Vzc1xyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZUR1bXBcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEVucXVldWVkRHVtcD59IFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuY3JlYXRlRHVtcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiZHVtcHNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBkdW1wIGNyZWF0aW9uIHByb2Nlc3NcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZXREdW1wU3RhdHVzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHVtcFVpZCBEdW1wIFVJRFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RW5xdWV1ZWREdW1wPn0gUHJvbWlzZSByZXR1cm5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXREdW1wU3RhdHVzID0gZnVuY3Rpb24gKGR1bXBVaWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiZHVtcHMvXCIuY29uY2F0KGR1bXBVaWQsIFwiL3N0YXR1c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHRlbmFudCB0b2tlblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZVRlbmFudFRva2VuXHJcbiAgICAgKiBAcGFyYW0ge1NlYXJjaFJ1bGVzfSBzZWFyY2hSdWxlcyBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0ge1Rva2VuT3B0aW9uc30gb3B0aW9ucyBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZW5lcmF0ZVRlbmFudFRva2VuID0gZnVuY3Rpb24gKF9zZWFyY2hSdWxlcywgX29wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZWlsaXNlYXJjaDogZmFpbGVkIHRvIGdlbmVyYXRlIGEgdGVuYW50IHRva2VuLiBHZW5lcmF0aW9uIG9mIGEgdG9rZW4gb25seSB3b3JrcyBpbiBhIG5vZGUgZW52aXJvbm1lbnQgXFxuIFwiLmNvbmNhdChlcnJvci5zdGFjaywgXCIuXCIpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2xpZW50O1xyXG59KCkpO1xuXG5mdW5jdGlvbiBlbmNvZGU2NChkYXRhKSB7XHJcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YSkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBoZWFkZXIgb2YgdGhlIHRva2VuLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IEFQSSBrZXkgdXNlZCB0byBzaWduIHRoZSB0b2tlbi5cclxuICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZWRIZWFkZXIgSGVhZGVyIG9mIHRoZSB0b2tlbiBpbiBiYXNlNjQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkUGF5bG9hZCBQYXlsb2FkIG9mIHRoZSB0b2tlbiBpbiBiYXNlNjQuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzaWduYXR1cmUgb2YgdGhlIHRva2VuIGluIGJhc2U2NC5cclxuICovXHJcbmZ1bmN0aW9uIHNpZ24oYXBpS2V5LCBlbmNvZGVkSGVhZGVyLCBlbmNvZGVkUGF5bG9hZCkge1xyXG4gICAgcmV0dXJuIGNyeXB0b1xyXG4gICAgICAgIC5jcmVhdGVIbWFjKCdzaGEyNTYnLCBhcGlLZXkpXHJcbiAgICAgICAgLnVwZGF0ZShcIlwiLmNvbmNhdChlbmNvZGVkSGVhZGVyLCBcIi5cIikuY29uY2F0KGVuY29kZWRQYXlsb2FkKSlcclxuICAgICAgICAuZGlnZXN0KCdiYXNlNjQnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXC8vZywgJ18nKVxyXG4gICAgICAgIC5yZXBsYWNlKC89L2csICcnKTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBoZWFkZXIgb2YgdGhlIHRva2VuLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgaGVhZGVyIGVuY29kZWQgaW4gYmFzZTY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSGVhZGVyKCkge1xyXG4gICAgdmFyIGhlYWRlciA9IHtcclxuICAgICAgICBhbGc6ICdIUzI1NicsXHJcbiAgICAgICAgdHlwOiAnSldUJ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBlbmNvZGU2NChoZWFkZXIpLnJlcGxhY2UoLz0vZywgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aGUgcGFyYW1ldGVyIHVzZWQgZm9yIHRoZSBwYXlsb2FkIG9mIHRoZSB0b2tlbi5cclxuICpcclxuICogQHBhcmFtIHtTZWFyY2hSdWxlc30gc2VhcmNoUnVsZXMgU2VhcmNoIHJ1bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gZXZlcnkgc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IEFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gKiBAcGFyYW0ge0RhdGUgfCB1bmRlZmluZWR9IGV4cGlyZXNBdCBEYXRlIGF0IHdoaWNoIHRoZSB0b2tlbiBleHBpcmVzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVQYXlsb2FkKHBheWxvYWRQYXJhbXMpIHtcclxuICAgIHZhciBzZWFyY2hSdWxlcyA9IHBheWxvYWRQYXJhbXMuc2VhcmNoUnVsZXMsIGFwaUtleSA9IHBheWxvYWRQYXJhbXMuYXBpS2V5LCBleHBpcmVzQXQgPSBwYXlsb2FkUGFyYW1zLmV4cGlyZXNBdDtcclxuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xyXG4gICAgaWYgKGV4cGlyZXNBdCkge1xyXG4gICAgICAgIGlmICghKGV4cGlyZXNBdCBpbnN0YW5jZW9mIERhdGUpIHx8IGV4cGlyZXNBdC5nZXRUaW1lKCkgPCBEYXRlLm5vdygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1laWxpc2VhcmNoOiBXaGVuIHRoZSBleHBpcmVzQXQgZmllbGQgaW4gdGhlIHRva2VuIGdlbmVyYXRpb24gaGFzIGEgdmFsdWUsIGl0IG11c3QgYmUgYSBkYXRlIHNldCBpbiB0aGUgZnV0dXJlIGFuZCBub3QgaW4gdGhlIHBhc3QuIFxcbiBcIi5jb25jYXQoZXJyb3Iuc3RhY2ssIFwiLlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlYXJjaFJ1bGVzKSB7XHJcbiAgICAgICAgaWYgKCEodHlwZW9mIHNlYXJjaFJ1bGVzID09PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHNlYXJjaFJ1bGVzKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVpbGlzZWFyY2g6IFRoZSBzZWFyY2ggcnVsZXMgYWRkZWQgaW4gdGhlIHRva2VuIGdlbmVyYXRpb24gbXVzdCBiZSBvZiB0eXBlIGFycmF5IG9yIG9iamVjdC4gXFxuIFwiLmNvbmNhdChlcnJvci5zdGFjaywgXCIuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwaUtleSB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1laWxpc2VhcmNoOiBUaGUgQVBJIGtleSB1c2VkIGZvciB0aGUgdG9rZW4gZ2VuZXJhdGlvbiBtdXN0IGV4aXN0IGFuZCBiZSBvZiB0eXBlIHN0cmluZy4gXFxuIFwiLmNvbmNhdChlcnJvci5zdGFjaywgXCIuXCIpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlIHRoZSBwYXlsb2FkIG9mIHRoZSB0b2tlbi5cclxuICpcclxuICogQHBhcmFtIHtTZWFyY2hSdWxlc30gc2VhcmNoUnVsZXMgU2VhcmNoIHJ1bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gZXZlcnkgc2VhcmNoLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYXBpS2V5IEFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gKiBAcGFyYW0ge0RhdGUgfCB1bmRlZmluZWR9IGV4cGlyZXNBdCBEYXRlIGF0IHdoaWNoIHRoZSB0b2tlbiBleHBpcmVzLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcGF5bG9hZCBlbmNvZGVkIGluIGJhc2U2NC5cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVBheWxvYWQocGF5bG9hZFBhcmFtcykge1xyXG4gICAgdmFyIHNlYXJjaFJ1bGVzID0gcGF5bG9hZFBhcmFtcy5zZWFyY2hSdWxlcywgYXBpS2V5ID0gcGF5bG9hZFBhcmFtcy5hcGlLZXksIGV4cGlyZXNBdCA9IHBheWxvYWRQYXJhbXMuZXhwaXJlc0F0O1xyXG4gICAgdmFsaWRhdGVQYXlsb2FkKHBheWxvYWRQYXJhbXMpO1xyXG4gICAgdmFyIHBheWxvYWQgPSB7XHJcbiAgICAgICAgc2VhcmNoUnVsZXM6IHNlYXJjaFJ1bGVzLFxyXG4gICAgICAgIGFwaUtleVByZWZpeDogYXBpS2V5LnN1YnN0cmluZygwLCA4KSxcclxuICAgICAgICBleHA6IGV4cGlyZXNBdCA9PT0gbnVsbCB8fCBleHBpcmVzQXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cGlyZXNBdC5nZXRUaW1lKClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZW5jb2RlNjQocGF5bG9hZCkucmVwbGFjZSgvPS9nLCAnJyk7XHJcbn1cclxudmFyIFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9rZW4oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdGVuYW50IHRva2VuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIE1laWxpU2VhcmNoXHJcbiAgICAgKiBAbWV0aG9kIGdlbmVyYXRlVGVuYW50VG9rZW5cclxuICAgICAqIEBwYXJhbSB7U2VhcmNoUnVsZXN9IHNlYXJjaFJ1bGVzIFNlYXJjaCBydWxlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IHNlYXJjaC5cclxuICAgICAqIEBwYXJhbSB7VG9rZW5PcHRpb25zfSBvcHRpb25zIFRva2VuIG9wdGlvbnMgdG8gY3VzdG9taXplIHNvbWUgYXNwZWN0IG9mIHRoZSB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0b2tlbiBpbiBKV1QgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBUb2tlbi5wcm90b3R5cGUuZ2VuZXJhdGVUZW5hbnRUb2tlbiA9IGZ1bmN0aW9uIChzZWFyY2hSdWxlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBhcGlLZXkgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFwaUtleSkgfHwgdGhpcy5jb25maWcuYXBpS2V5IHx8ICcnO1xyXG4gICAgICAgIHZhciBleHBpcmVzQXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhwaXJlc0F0O1xyXG4gICAgICAgIHZhciBlbmNvZGVkSGVhZGVyID0gY3JlYXRlSGVhZGVyKCk7XHJcbiAgICAgICAgdmFyIGVuY29kZWRQYXlsb2FkID0gY3JlYXRlUGF5bG9hZCh7IHNlYXJjaFJ1bGVzOiBzZWFyY2hSdWxlcywgYXBpS2V5OiBhcGlLZXksIGV4cGlyZXNBdDogZXhwaXJlc0F0IH0pO1xyXG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBzaWduKGFwaUtleSwgZW5jb2RlZEhlYWRlciwgZW5jb2RlZFBheWxvYWQpO1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChlbmNvZGVkSGVhZGVyLCBcIi5cIikuY29uY2F0KGVuY29kZWRQYXlsb2FkLCBcIi5cIikuY29uY2F0KHNpZ25hdHVyZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRva2VuO1xyXG59KCkpO1xuXG52YXIgTWVpbGlTZWFyY2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWVpbGlTZWFyY2gsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNZWlsaVNlYXJjaChjb25maWcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb25maWcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudG9rZW5zID0gbmV3IFRva2VuKGNvbmZpZyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIHRlbmFudCB0b2tlblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBNZWlsaVNlYXJjaFxyXG4gICAgICogQG1ldGhvZCBnZW5lcmF0ZVRlbmFudFRva2VuXHJcbiAgICAgKiBAcGFyYW0ge1NlYXJjaFJ1bGVzfSBzZWFyY2hSdWxlcyBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0ge1Rva2VuT3B0aW9uc30gb3B0aW9ucyBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgTWVpbGlTZWFyY2gucHJvdG90eXBlLmdlbmVyYXRlVGVuYW50VG9rZW4gPSBmdW5jdGlvbiAoc2VhcmNoUnVsZXMsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLmdlbmVyYXRlVGVuYW50VG9rZW4oc2VhcmNoUnVsZXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZW5lcmF0ZVRlbmFudFRva2VuLmNhbGwodGhpcywgc2VhcmNoUnVsZXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZWlsaVNlYXJjaDtcclxufShDbGllbnQpKTtcblxuZXhwb3J0IHsgSHR0cFJlcXVlc3RzLCBJbmRleCwgTWVpbGlTZWFyY2gsIE1laWxpU2VhcmNoQXBpRXJyb3IsIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yLCBNZWlsaVNlYXJjaEVycm9yLCBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvciwgYWRkUHJvdG9jb2xJZk5vdFByZXNlbnQsIGFkZFRyYWlsaW5nU2xhc2gsIE1laWxpU2VhcmNoIGFzIGRlZmF1bHQsIGh0dHBFcnJvckhhbmRsZXIsIGh0dHBSZXNwb25zZUVycm9ySGFuZGxlciwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdCwgc2xlZXAgfTtcbiJdLCJuYW1lcyI6WyJjcnlwdG8iLCJleHRlbmRTdGF0aWNzIiwiZCIsImIiLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIkFycmF5IiwicCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIl9fZXh0ZW5kcyIsIlR5cGVFcnJvciIsIlN0cmluZyIsIl9fIiwiY29uc3RydWN0b3IiLCJjcmVhdGUiLCJfX2Fzc2lnbiIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInYiLCJvcCIsInBvcCIsInB1c2giLCJNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvciIsIl9zdXBlciIsIm1lc3NhZ2UiLCJ1cmwiLCJzdGFjayIsIl90aGlzIiwiX2EiLCJfYiIsIl9jIiwibmFtZSIsInR5cGUiLCJSZXNwb25zZSIsInN0YXR1c1RleHQiLCJzdGF0dXNDb2RlIiwic3RhdHVzIiwiRXJyb3IiLCJlcnJubyIsImNvZGUiLCJyZXBsYWNlIiwiY29uY2F0IiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJNZWlsaVNlYXJjaEFwaUVycm9yIiwiY2xhc3NfMSIsImVycm9yIiwibGluayIsImh0dHBTdGF0dXMiLCJodHRwUmVzcG9uc2VFcnJvckhhbmRsZXIiLCJyZXNwb25zZSIsImVyciIsIm9rIiwianNvbiIsImh0dHBFcnJvckhhbmRsZXIiLCJNZWlsaVNlYXJjaEVycm9yIiwiTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IiLCJyZW1vdmVVbmRlZmluZWRGcm9tT2JqZWN0Iiwib2JqIiwiZW50cmllcyIsInJlZHVjZSIsImFjYyIsImN1ckVudHJ5Iiwia2V5IiwidmFsIiwidW5kZWZpbmVkIiwic2xlZXAiLCJtcyIsInNldFRpbWVvdXQiLCJhZGRQcm90b2NvbElmTm90UHJlc2VudCIsImhvc3QiLCJzdGFydHNXaXRoIiwiYWRkVHJhaWxpbmdTbGFzaCIsImVuZHNXaXRoIiwiY29uc3RydWN0SG9zdFVSTCIsIkh0dHBSZXF1ZXN0cyIsImNvbmZpZyIsImhlYWRlcnMiLCJhcGlLZXkiLCJVUkwiLCJyZXF1ZXN0IiwibWV0aG9kIiwicGFyYW1zIiwiY29uc3RydWN0VVJMIiwicXVlcnlQYXJhbXNfMSIsInBhcnNlZEJvZHkiLCJwYXJzZWRKc29uIiwiZV8xIiwiVVJMU2VhcmNoUGFyYW1zIiwia2V5cyIsImZpbHRlciIsIngiLCJtYXAiLCJzZXQiLCJzZWFyY2giLCJ0b1N0cmluZyIsImZldGNoIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyIsInRleHQiLCJwYXJzZSIsImdldCIsInBvc3QiLCJkYXRhIiwicHV0IiwicGF0Y2giLCJUYXNrQ2xpZW50IiwiaHR0cFJlcXVlc3QiLCJnZXRDbGllbnRUYXNrIiwidWlkIiwiZ2V0Q2xpZW50VGFza3MiLCJnZXRJbmRleFRhc2siLCJpbmRleFVpZCIsInRhc2tJZCIsImdldEluZGV4VGFza3MiLCJ3YWl0Rm9yQ2xpZW50VGFzayIsInRpbWVPdXRNcyIsIl9kIiwiaW50ZXJ2YWxNcyIsInN0YXJ0aW5nVGltZSIsIl9lIiwiRGF0ZSIsIm5vdyIsImluY2x1ZGVzIiwid2FpdEZvckNsaWVudFRhc2tzIiwidGFza0lkcyIsInRhc2tzIiwiX2kiLCJ0YXNrSWRzXzEiLCJ0YXNrIiwicmVzdWx0cyIsIndhaXRGb3JJbmRleFRhc2siLCJJbmRleCIsInByaW1hcnlLZXkiLCJxdWVyeSIsIm9wdGlvbnMiLCJxIiwic2VhcmNoR2V0IiwicGFyc2VGaWx0ZXIiLCJnZXRQYXJhbXMiLCJfZiIsImlzQXJyYXkiLCJzb3J0Iiwiam9pbiIsImZhY2V0c0Rpc3RyaWJ1dGlvbiIsImF0dHJpYnV0ZXNUb1JldHJpZXZlIiwiYXR0cmlidXRlc1RvQ3JvcCIsImF0dHJpYnV0ZXNUb0hpZ2hsaWdodCIsImdldFJhd0luZm8iLCJmZXRjaEluZm8iLCJmZXRjaFByaW1hcnlLZXkiLCJyZXEiLCJ1cGRhdGUiLCJnZXRUYXNrcyIsImdldFRhc2siLCJ3YWl0Rm9yVGFza3MiLCJ3YWl0Rm9yVGFzayIsImdldFN0YXRzIiwiZ2V0RG9jdW1lbnRzIiwiYXR0ciIsImdldERvY3VtZW50IiwiZG9jdW1lbnRJZCIsImFkZERvY3VtZW50cyIsImRvY3VtZW50cyIsImFkZERvY3VtZW50c0luQmF0Y2hlcyIsImJhdGNoU2l6ZSIsInVwZGF0ZXMiLCJzbGljZSIsInVwZGF0ZURvY3VtZW50cyIsInVwZGF0ZURvY3VtZW50c0luQmF0Y2hlcyIsImRlbGV0ZURvY3VtZW50IiwiZGVsZXRlRG9jdW1lbnRzIiwiZG9jdW1lbnRzSWRzIiwiZGVsZXRlQWxsRG9jdW1lbnRzIiwiZ2V0U2V0dGluZ3MiLCJ1cGRhdGVTZXR0aW5ncyIsInNldHRpbmdzIiwicmVzZXRTZXR0aW5ncyIsImdldFN5bm9ueW1zIiwidXBkYXRlU3lub255bXMiLCJzeW5vbnltcyIsInJlc2V0U3lub255bXMiLCJnZXRTdG9wV29yZHMiLCJ1cGRhdGVTdG9wV29yZHMiLCJzdG9wV29yZHMiLCJyZXNldFN0b3BXb3JkcyIsImdldFJhbmtpbmdSdWxlcyIsInVwZGF0ZVJhbmtpbmdSdWxlcyIsInJhbmtpbmdSdWxlcyIsInJlc2V0UmFua2luZ1J1bGVzIiwiZ2V0RGlzdGluY3RBdHRyaWJ1dGUiLCJ1cGRhdGVEaXN0aW5jdEF0dHJpYnV0ZSIsImRpc3RpbmN0QXR0cmlidXRlIiwicmVzZXREaXN0aW5jdEF0dHJpYnV0ZSIsImdldEZpbHRlcmFibGVBdHRyaWJ1dGVzIiwidXBkYXRlRmlsdGVyYWJsZUF0dHJpYnV0ZXMiLCJmaWx0ZXJhYmxlQXR0cmlidXRlcyIsInJlc2V0RmlsdGVyYWJsZUF0dHJpYnV0ZXMiLCJnZXRTb3J0YWJsZUF0dHJpYnV0ZXMiLCJ1cGRhdGVTb3J0YWJsZUF0dHJpYnV0ZXMiLCJzb3J0YWJsZUF0dHJpYnV0ZXMiLCJyZXNldFNvcnRhYmxlQXR0cmlidXRlcyIsImdldFNlYXJjaGFibGVBdHRyaWJ1dGVzIiwidXBkYXRlU2VhcmNoYWJsZUF0dHJpYnV0ZXMiLCJzZWFyY2hhYmxlQXR0cmlidXRlcyIsInJlc2V0U2VhcmNoYWJsZUF0dHJpYnV0ZXMiLCJnZXREaXNwbGF5ZWRBdHRyaWJ1dGVzIiwidXBkYXRlRGlzcGxheWVkQXR0cmlidXRlcyIsImRpc3BsYXllZEF0dHJpYnV0ZXMiLCJyZXNldERpc3BsYXllZEF0dHJpYnV0ZXMiLCJnZXRUeXBvVG9sZXJhbmNlIiwidXBkYXRlVHlwb1RvbGVyYW5jZSIsInR5cG9Ub2xlcmFuY2UiLCJyZXNldFR5cG9Ub2xlcmFuY2UiLCJDbGllbnQiLCJpbmRleCIsImdldEluZGV4IiwiZ2V0UmF3SW5kZXgiLCJnZXRJbmRleGVzIiwiaW5kZXhlcyIsImdldFJhd0luZGV4ZXMiLCJjcmVhdGVJbmRleCIsInVwZGF0ZUluZGV4IiwiZGVsZXRlSW5kZXgiLCJkZWxldGVJbmRleElmRXhpc3RzIiwiZ2V0S2V5cyIsImdldEtleSIsImNyZWF0ZUtleSIsInVwZGF0ZUtleSIsImRlbGV0ZUtleSIsImhlYWx0aCIsImlzSGVhbHRoeSIsImdldFZlcnNpb24iLCJjcmVhdGVEdW1wIiwiZ2V0RHVtcFN0YXR1cyIsImR1bXBVaWQiLCJnZW5lcmF0ZVRlbmFudFRva2VuIiwiX3NlYXJjaFJ1bGVzIiwiX29wdGlvbnMiLCJlbmNvZGU2NCIsIkJ1ZmZlciIsImZyb20iLCJzaWduIiwiZW5jb2RlZEhlYWRlciIsImVuY29kZWRQYXlsb2FkIiwiY3JlYXRlSG1hYyIsImRpZ2VzdCIsImNyZWF0ZUhlYWRlciIsImhlYWRlciIsImFsZyIsInR5cCIsInZhbGlkYXRlUGF5bG9hZCIsInBheWxvYWRQYXJhbXMiLCJzZWFyY2hSdWxlcyIsImV4cGlyZXNBdCIsImdldFRpbWUiLCJjcmVhdGVQYXlsb2FkIiwicGF5bG9hZCIsImFwaUtleVByZWZpeCIsInN1YnN0cmluZyIsImV4cCIsIlRva2VuIiwic2lnbmF0dXJlIiwiTWVpbGlTZWFyY2giLCJ0b2tlbnMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.esm.js\n");

/***/ })

};
;