"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-currency-input-field";
exports.ids = ["vendor-chunks/react-currency-input-field"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-currency-input-field/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   formatValue: () => (/* binding */ formatValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || from);\n}\n/**\n * Escape regex char\n *\n * See: https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript\n */ var escapeRegExp = function(stringToGoIntoTheRegex) {\n    return stringToGoIntoTheRegex.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\nvar abbrMap = {\n    k: 1000,\n    m: 1000000,\n    b: 1000000000\n};\n/**\n * Parse a value with abbreviation e.g 1k = 1000\n */ var parseAbbrValue = function(value, decimalSeparator) {\n    if (decimalSeparator === void 0) {\n        decimalSeparator = \".\";\n    }\n    var reg = new RegExp(\"(\\\\d+(\" + escapeRegExp(decimalSeparator) + \"\\\\d*)?)([kmb])$\", \"i\");\n    var match = value.match(reg);\n    if (match) {\n        var digits = match[1], abbr = match[3];\n        var multiplier = abbrMap[abbr.toLowerCase()];\n        return Number(digits.replace(decimalSeparator, \".\")) * multiplier;\n    }\n    return undefined;\n};\n/**\n * Remove group separator from value eg. 1,000 > 1000\n */ var removeSeparators = function(value, separator) {\n    if (separator === void 0) {\n        separator = \",\";\n    }\n    var reg = new RegExp(escapeRegExp(separator), \"g\");\n    return value.replace(reg, \"\");\n};\n/**\n * Remove invalid characters\n */ var removeInvalidChars = function(value, validChars) {\n    var chars = escapeRegExp(validChars.join(\"\"));\n    var reg = new RegExp(\"[^\\\\d\" + chars + \"]\", \"gi\");\n    return value.replace(reg, \"\");\n};\n/**\n * Remove prefix, separators and extra decimals from value\n */ var cleanValue = function(_a) {\n    var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? \",\" : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? \".\" : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e = _a.decimalsLimit, decimalsLimit = _e === void 0 ? 2 : _e, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? \"\" : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function(rawValue) {\n        return rawValue;\n    } : _j;\n    var transformedValue = transformRawValue(value);\n    if (transformedValue === \"-\") {\n        return transformedValue;\n    }\n    var abbreviations = disableAbbreviations ? [] : [\n        \"k\",\n        \"m\",\n        \"b\"\n    ];\n    var reg = new RegExp(\"((^|\\\\D)-\\\\d)|(-\" + escapeRegExp(prefix) + \")\");\n    var isNegative = reg.test(transformedValue);\n    // Is there a digit before the prefix? eg. 1$\n    var _k = RegExp(\"(\\\\d+)-?\" + escapeRegExp(prefix)).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];\n    var withoutPrefix = prefix ? prefixWithValue ? transformedValue.replace(prefixWithValue, \"\").concat(preValue) : transformedValue.replace(prefix, \"\") : transformedValue;\n    var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);\n    var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([\n        groupSeparator,\n        decimalSeparator\n    ], abbreviations));\n    var valueOnly = withoutInvalidChars;\n    if (!disableAbbreviations) {\n        // disallow letter without number\n        if (abbreviations.some(function(letter) {\n            return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, \"\");\n        })) {\n            return \"\";\n        }\n        var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);\n        if (parsed) {\n            valueOnly = String(parsed);\n        }\n    }\n    var includeNegative = isNegative && allowNegativeValue ? \"-\" : \"\";\n    if (decimalSeparator && valueOnly.includes(decimalSeparator)) {\n        var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];\n        var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;\n        var includeDecimals = allowDecimals ? \"\" + decimalSeparator + trimmedDecimals : \"\";\n        return \"\" + includeNegative + int + includeDecimals;\n    }\n    return \"\" + includeNegative + valueOnly;\n};\nvar fixedDecimalValue = function(value, decimalSeparator, fixedDecimalLength) {\n    if (fixedDecimalLength && value.length > 1) {\n        if (value.includes(decimalSeparator)) {\n            var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n            if (decimals.length > fixedDecimalLength) {\n                return \"\" + int + decimalSeparator + decimals.slice(0, fixedDecimalLength);\n            }\n        }\n        var reg = value.length > fixedDecimalLength ? new RegExp(\"(\\\\d+)(\\\\d{\" + fixedDecimalLength + \"})\") : new RegExp(\"(\\\\d)(\\\\d+)\");\n        var match = value.match(reg);\n        if (match) {\n            var int = match[1], decimals = match[2];\n            return \"\" + int + decimalSeparator + decimals;\n        }\n    }\n    return value;\n};\nvar getSuffix = function(value, _a) {\n    var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? \",\" : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? \".\" : _c;\n    var suffixReg = new RegExp(\"\\\\d([^\" + escapeRegExp(groupSeparator) + escapeRegExp(decimalSeparator) + \"0-9]+)\");\n    var suffixMatch = value.match(suffixReg);\n    return suffixMatch ? suffixMatch[1] : undefined;\n};\n/**\n * Format value with decimal separator, group separator and prefix\n */ var formatValue = function(options) {\n    var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? \"\" : _a, _b = options.suffix, suffix = _b === void 0 ? \"\" : _b;\n    if (_value === \"\" || _value === undefined) {\n        return \"\";\n    }\n    if (_value === \"-\") {\n        return \"-\";\n    }\n    var isNegative = new RegExp(\"^\\\\d?-\" + (prefix ? escapeRegExp(prefix) + \"?\" : \"\") + \"\\\\d\").test(_value);\n    var value = decimalSeparator !== \".\" ? replaceDecimalSeparator(_value, decimalSeparator, isNegative) : _value;\n    var defaultNumberFormatOptions = {\n        minimumFractionDigits: decimalScale || 0,\n        maximumFractionDigits: 20\n    };\n    var numberFormatter = intlConfig ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency ? __assign(__assign({}, defaultNumberFormatOptions), {\n        style: \"currency\",\n        currency: intlConfig.currency\n    }) : defaultNumberFormatOptions) : new Intl.NumberFormat(undefined, defaultNumberFormatOptions);\n    var parts = numberFormatter.formatToParts(Number(value));\n    var formatted = replaceParts(parts, options);\n    // Does intl formatting add a suffix?\n    var intlSuffix = getSuffix(formatted, __assign({}, options));\n    // Include decimal separator if user input ends with decimal separator\n    var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : \"\";\n    var _c = value.match(RegExp(\"\\\\d+\\\\.(\\\\d+)\")) || [], decimals = _c[1];\n    // Keep original decimal padding if no decimalScale\n    if (decimalScale === undefined && decimals && decimalSeparator) {\n        if (formatted.includes(decimalSeparator)) {\n            formatted = formatted.replace(RegExp(\"(\\\\d+)(\" + escapeRegExp(decimalSeparator) + \")(\\\\d+)\", \"g\"), \"$1$2\" + decimals);\n        } else {\n            if (intlSuffix && !suffix) {\n                formatted = formatted.replace(intlSuffix, \"\" + decimalSeparator + decimals + intlSuffix);\n            } else {\n                formatted = \"\" + formatted + decimalSeparator + decimals;\n            }\n        }\n    }\n    if (suffix && includeDecimalSeparator) {\n        return \"\" + formatted + includeDecimalSeparator + suffix;\n    }\n    if (intlSuffix && includeDecimalSeparator) {\n        return formatted.replace(intlSuffix, \"\" + includeDecimalSeparator + intlSuffix);\n    }\n    if (intlSuffix && suffix) {\n        return formatted.replace(intlSuffix, \"\" + includeDecimalSeparator + suffix);\n    }\n    return [\n        formatted,\n        includeDecimalSeparator,\n        suffix\n    ].join(\"\");\n};\n/**\n * Before converting to Number, decimal separator has to be .\n */ var replaceDecimalSeparator = function(value, decimalSeparator, isNegative) {\n    var newValue = value;\n    if (decimalSeparator && decimalSeparator !== \".\") {\n        newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), \"g\"), \".\");\n        if (isNegative && decimalSeparator === \"-\") {\n            newValue = \"-\" + newValue.slice(1);\n        }\n    }\n    return newValue;\n};\nvar replaceParts = function(parts, _a) {\n    var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;\n    return parts.reduce(function(prev, _a, i) {\n        var type = _a.type, value = _a.value;\n        if (i === 0 && prefix) {\n            if (type === \"minusSign\") {\n                return [\n                    value,\n                    prefix\n                ];\n            }\n            if (type === \"currency\") {\n                return __spreadArray(__spreadArray([], prev), [\n                    prefix\n                ]);\n            }\n            return [\n                prefix,\n                value\n            ];\n        }\n        if (type === \"currency\") {\n            return prefix ? prev : __spreadArray(__spreadArray([], prev), [\n                value\n            ]);\n        }\n        if (type === \"group\") {\n            return !disableGroupSeparators ? __spreadArray(__spreadArray([], prev), [\n                groupSeparator !== undefined ? groupSeparator : value\n            ]) : prev;\n        }\n        if (type === \"decimal\") {\n            if (decimalScale !== undefined && decimalScale === 0) {\n                return prev;\n            }\n            return __spreadArray(__spreadArray([], prev), [\n                decimalSeparator !== undefined ? decimalSeparator : value\n            ]);\n        }\n        if (type === \"fraction\") {\n            return __spreadArray(__spreadArray([], prev), [\n                decimalScale !== undefined ? value.slice(0, decimalScale) : value\n            ]);\n        }\n        return __spreadArray(__spreadArray([], prev), [\n            value\n        ]);\n    }, [\n        \"\"\n    ]).join(\"\");\n};\nvar defaultConfig = {\n    currencySymbol: \"\",\n    groupSeparator: \"\",\n    decimalSeparator: \"\",\n    prefix: \"\",\n    suffix: \"\"\n};\n/**\n * Get locale config from input or default\n */ var getLocaleConfig = function(intlConfig) {\n    var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;\n    var numberFormatter = locale ? new Intl.NumberFormat(locale, currency ? {\n        currency: currency,\n        style: \"currency\"\n    } : undefined) : new Intl.NumberFormat();\n    return numberFormatter.formatToParts(1000.1).reduce(function(prev, curr, i) {\n        if (curr.type === \"currency\") {\n            if (i === 0) {\n                return __assign(__assign({}, prev), {\n                    currencySymbol: curr.value,\n                    prefix: curr.value\n                });\n            } else {\n                return __assign(__assign({}, prev), {\n                    currencySymbol: curr.value,\n                    suffix: curr.value\n                });\n            }\n        }\n        if (curr.type === \"group\") {\n            return __assign(__assign({}, prev), {\n                groupSeparator: curr.value\n            });\n        }\n        if (curr.type === \"decimal\") {\n            return __assign(__assign({}, prev), {\n                decimalSeparator: curr.value\n            });\n        }\n        return prev;\n    }, defaultConfig);\n};\nvar isNumber = function(input) {\n    return RegExp(/\\d/, \"gi\").test(input);\n};\nvar padTrimValue = function(value, decimalSeparator, decimalScale) {\n    if (decimalSeparator === void 0) {\n        decimalSeparator = \".\";\n    }\n    if (decimalScale === undefined || value === \"\" || value === undefined) {\n        return value;\n    }\n    if (!value.match(/\\d/g)) {\n        return \"\";\n    }\n    var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n    if (decimalScale === 0) {\n        return int;\n    }\n    var newValue = decimals || \"\";\n    if (newValue.length < decimalScale) {\n        while(newValue.length < decimalScale){\n            newValue += \"0\";\n        }\n    } else {\n        newValue = newValue.slice(0, decimalScale);\n    }\n    return \"\" + int + decimalSeparator + newValue;\n};\n/**\n * Based on the last key stroke and the cursor position, update the value\n * and reposition the cursor to the right place\n */ var repositionCursor = function(_a) {\n    var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;\n    var cursorPosition = selectionStart;\n    var modifiedValue = value;\n    if (stateValue && cursorPosition) {\n        var splitValue = value.split(\"\");\n        // if cursor is to right of groupSeparator and backspace pressed, delete the character to the left of the separator and reposition the cursor\n        if (lastKeyStroke === \"Backspace\" && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition - 1, 1);\n            cursorPosition -= 1;\n        }\n        // if cursor is to left of groupSeparator and delete pressed, delete the character to the right of the separator and reposition the cursor\n        if (lastKeyStroke === \"Delete\" && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition, 1);\n            cursorPosition += 1;\n        }\n        modifiedValue = splitValue.join(\"\");\n        return {\n            modifiedValue: modifiedValue,\n            cursorPosition: cursorPosition\n        };\n    }\n    return {\n        modifiedValue: modifiedValue,\n        cursorPosition: selectionStart\n    };\n};\nvar CurrencyInput = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(_a, ref) {\n    var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min = _a.min, max = _a.max, _e = _a.disableGroupSeparators, disableGroupSeparators = _e === void 0 ? false : _e, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, props = __rest(_a, [\n        \"allowDecimals\",\n        \"allowNegativeValue\",\n        \"id\",\n        \"name\",\n        \"className\",\n        \"customInput\",\n        \"decimalsLimit\",\n        \"defaultValue\",\n        \"disabled\",\n        \"maxLength\",\n        \"value\",\n        \"onValueChange\",\n        \"fixedDecimalLength\",\n        \"placeholder\",\n        \"decimalScale\",\n        \"prefix\",\n        \"suffix\",\n        \"intlConfig\",\n        \"step\",\n        \"min\",\n        \"max\",\n        \"disableGroupSeparators\",\n        \"disableAbbreviations\",\n        \"decimalSeparator\",\n        \"groupSeparator\",\n        \"onChange\",\n        \"onFocus\",\n        \"onBlur\",\n        \"onKeyDown\",\n        \"onKeyUp\",\n        \"transformRawValue\"\n    ]);\n    if (_decimalSeparator && isNumber(_decimalSeparator)) {\n        throw new Error(\"decimalSeparator cannot be a number\");\n    }\n    if (_groupSeparator && isNumber(_groupSeparator)) {\n        throw new Error(\"groupSeparator cannot be a number\");\n    }\n    var localeConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function() {\n        return getLocaleConfig(intlConfig);\n    }, [\n        intlConfig\n    ]);\n    var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || \"\";\n    var groupSeparator = _groupSeparator || localeConfig.groupSeparator || \"\";\n    if (decimalSeparator && groupSeparator && decimalSeparator === groupSeparator && disableGroupSeparators === false) {\n        throw new Error(\"decimalSeparator cannot be the same as groupSeparator\");\n    }\n    var formatValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        disableGroupSeparators: disableGroupSeparators,\n        intlConfig: intlConfig,\n        prefix: prefix || localeConfig.prefix,\n        suffix: suffix\n    };\n    var cleanValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        allowDecimals: allowDecimals,\n        decimalsLimit: decimalsLimit || fixedDecimalLength || 2,\n        allowNegativeValue: allowNegativeValue,\n        disableAbbreviations: disableAbbreviations,\n        prefix: prefix || localeConfig.prefix,\n        transformRawValue: transformRawValue\n    };\n    var formattedStateValue = defaultValue !== undefined && defaultValue !== null ? formatValue(__assign(__assign({}, formatValueOptions), {\n        decimalScale: decimalScale,\n        value: String(defaultValue)\n    })) : userValue !== undefined && userValue !== null ? formatValue(__assign(__assign({}, formatValueOptions), {\n        decimalScale: decimalScale,\n        value: String(userValue)\n    })) : \"\";\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(formattedStateValue), stateValue = _g[0], setStateValue = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), dirty = _h[0], setDirty = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), cursor = _j[0], setCursor = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), changeCount = _k[0], setChangeCount = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), lastKeyStroke = _l[0], setLastKeyStroke = _l[1];\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function() {\n        return inputRef.current;\n    });\n    /**\n     * Process change in value\n     */ var processChange = function(value, selectionStart) {\n        setDirty(true);\n        var _a = repositionCursor({\n            selectionStart: selectionStart,\n            value: value,\n            lastKeyStroke: lastKeyStroke,\n            stateValue: stateValue,\n            groupSeparator: groupSeparator\n        }), modifiedValue = _a.modifiedValue, cursorPosition = _a.cursorPosition;\n        var stringValue = cleanValue(__assign({\n            value: modifiedValue\n        }, cleanValueOptions));\n        if (userMaxLength && stringValue.replace(/-/g, \"\").length > userMaxLength) {\n            return;\n        }\n        if (stringValue === \"\" || stringValue === \"-\" || stringValue === decimalSeparator) {\n            onValueChange && onValueChange(undefined, name, {\n                float: null,\n                formatted: \"\",\n                value: \"\"\n            });\n            setStateValue(stringValue);\n            // Always sets cursor after '-' or decimalSeparator input\n            setCursor(1);\n            return;\n        }\n        var stringValueWithoutSeparator = decimalSeparator ? stringValue.replace(decimalSeparator, \".\") : stringValue;\n        var numberValue = parseFloat(stringValueWithoutSeparator);\n        var formattedValue = formatValue(__assign({\n            value: stringValue\n        }, formatValueOptions));\n        if (cursorPosition !== undefined && cursorPosition !== null) {\n            // Prevent cursor jumping\n            var newCursor = cursorPosition + (formattedValue.length - value.length);\n            newCursor = newCursor <= 0 ? prefix ? prefix.length : 0 : newCursor;\n            setCursor(newCursor);\n            setChangeCount(changeCount + 1);\n        }\n        setStateValue(formattedValue);\n        if (onValueChange) {\n            var values = {\n                float: numberValue,\n                formatted: formattedValue,\n                value: stringValue\n            };\n            onValueChange(stringValue, name, values);\n        }\n    };\n    /**\n     * Handle change event\n     */ var handleOnChange = function(event) {\n        var _a = event.target, value = _a.value, selectionStart = _a.selectionStart;\n        processChange(value, selectionStart);\n        onChange && onChange(event);\n    };\n    /**\n     * Handle focus event\n     */ var handleOnFocus = function(event) {\n        onFocus && onFocus(event);\n        return stateValue ? stateValue.length : 0;\n    };\n    /**\n     * Handle blur event\n     *\n     * Format value by padding/trimming decimals if required by\n     */ var handleOnBlur = function(event) {\n        var value = event.target.value;\n        var valueOnly = cleanValue(__assign({\n            value: value\n        }, cleanValueOptions));\n        if (valueOnly === \"-\" || valueOnly === decimalSeparator || !valueOnly) {\n            setStateValue(\"\");\n            onBlur && onBlur(event);\n            return;\n        }\n        var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);\n        var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== undefined ? decimalScale : fixedDecimalLength);\n        var numberValue = parseFloat(newValue.replace(decimalSeparator, \".\"));\n        var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), {\n            value: newValue\n        }));\n        if (onValueChange) {\n            onValueChange(newValue, name, {\n                float: numberValue,\n                formatted: formattedValue,\n                value: newValue\n            });\n        }\n        setStateValue(formattedValue);\n        onBlur && onBlur(event);\n    };\n    /**\n     * Handle key down event\n     *\n     * Increase or decrease value by step\n     */ var handleOnKeyDown = function(event) {\n        var key = event.key;\n        setLastKeyStroke(key);\n        if (step && (key === \"ArrowUp\" || key === \"ArrowDown\")) {\n            event.preventDefault();\n            setCursor(stateValue.length);\n            var currentValue = parseFloat(userValue !== undefined && userValue !== null ? String(userValue).replace(decimalSeparator, \".\") : cleanValue(__assign({\n                value: stateValue\n            }, cleanValueOptions))) || 0;\n            var newValue = key === \"ArrowUp\" ? currentValue + step : currentValue - step;\n            if (min !== undefined && newValue < min) {\n                return;\n            }\n            if (max !== undefined && newValue > max) {\n                return;\n            }\n            var fixedLength = String(step).includes(\".\") ? Number(String(step).split(\".\")[1].length) : undefined;\n            processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace(\".\", decimalSeparator));\n        }\n        onKeyDown && onKeyDown(event);\n    };\n    /**\n     * Handle key up event\n     *\n     * Move cursor if there is a suffix to prevent user typing past suffix\n     */ var handleOnKeyUp = function(event) {\n        var key = event.key, selectionStart = event.currentTarget.selectionStart;\n        if (key !== \"ArrowUp\" && key !== \"ArrowDown\" && stateValue !== \"-\") {\n            var suffix_1 = getSuffix(stateValue, {\n                groupSeparator: groupSeparator,\n                decimalSeparator: decimalSeparator\n            });\n            if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {\n                /* istanbul ignore else */ if (inputRef.current) {\n                    var newCursor = stateValue.length - suffix_1.length;\n                    inputRef.current.setSelectionRange(newCursor, newCursor);\n                }\n            }\n        }\n        onKeyUp && onKeyUp(event);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        // prevent cursor jumping if editing value\n        if (dirty && stateValue !== \"-\" && inputRef.current && document.activeElement === inputRef.current) {\n            inputRef.current.setSelectionRange(cursor, cursor);\n        }\n    }, [\n        stateValue,\n        cursor,\n        inputRef,\n        dirty,\n        changeCount\n    ]);\n    /**\n     * If user has only entered \"-\" or decimal separator,\n     * keep the char to allow them to enter next value\n     */ var getRenderValue = function() {\n        if (userValue !== undefined && userValue !== null && stateValue !== \"-\" && (!decimalSeparator || stateValue !== decimalSeparator)) {\n            return formatValue(__assign(__assign({}, formatValueOptions), {\n                decimalScale: dirty ? undefined : decimalScale,\n                value: String(userValue)\n            }));\n        }\n        return stateValue;\n    };\n    var inputProps = __assign({\n        type: \"text\",\n        inputMode: \"decimal\",\n        id: id,\n        name: name,\n        className: className,\n        onChange: handleOnChange,\n        onBlur: handleOnBlur,\n        onFocus: handleOnFocus,\n        onKeyDown: handleOnKeyDown,\n        onKeyUp: handleOnKeyUp,\n        placeholder: placeholder,\n        disabled: disabled,\n        value: getRenderValue(),\n        ref: inputRef\n    }, props);\n    if (customInput) {\n        var CustomInput = customInput;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, __assign({}, inputProps));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", __assign({}, inputProps));\n});\nCurrencyInput.displayName = \"CurrencyInput\";\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CurrencyInput);\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRztBQUVyRzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsSUFBSU8sV0FBVztJQUNYQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBU0YsU0FBU0csQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJSSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFDaEY7UUFDQSxPQUFPTjtJQUNYO0lBQ0EsT0FBT0gsU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRU47QUFDaEM7QUFFQSxTQUFTTyxPQUFPVixDQUFDLEVBQUVXLENBQUM7SUFDaEIsSUFBSVosSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJTSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLE1BQU1NLEVBQUVDLE9BQU8sQ0FBQ1AsS0FBSyxHQUM5RU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUNmLElBQUlMLEtBQUssUUFBUSxPQUFPSCxPQUFPZ0IscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJWixJQUFJLEdBQUdJLElBQUlSLE9BQU9nQixxQkFBcUIsQ0FBQ2IsSUFBSUMsSUFBSUksRUFBRUQsTUFBTSxFQUFFSCxJQUFLO1FBQ3BFLElBQUlVLEVBQUVDLE9BQU8sQ0FBQ1AsQ0FBQyxDQUFDSixFQUFFLElBQUksS0FBS0osT0FBT1MsU0FBUyxD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eHQvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanM/OWJiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IGZyb20pO1xyXG59XG5cbi8qKlxuICogRXNjYXBlIHJlZ2V4IGNoYXJcbiAqXG4gKiBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODg1ODU1L3VzZS1keW5hbWljLXZhcmlhYmxlLXN0cmluZy1hcy1yZWdleC1wYXR0ZXJuLWluLWphdmFzY3JpcHRcbiAqL1xudmFyIGVzY2FwZVJlZ0V4cCA9IGZ1bmN0aW9uIChzdHJpbmdUb0dvSW50b1RoZVJlZ2V4KSB7XG4gICAgcmV0dXJuIHN0cmluZ1RvR29JbnRvVGhlUmVnZXgucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59O1xuXG52YXIgYWJick1hcCA9IHsgazogMTAwMCwgbTogMTAwMDAwMCwgYjogMTAwMDAwMDAwMCB9O1xuLyoqXG4gKiBQYXJzZSBhIHZhbHVlIHdpdGggYWJicmV2aWF0aW9uIGUuZyAxayA9IDEwMDBcbiAqL1xudmFyIHBhcnNlQWJiclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBkZWNpbWFsU2VwYXJhdG9yID0gJy4nOyB9XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXGQrKFwiICsgZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpICsgXCJcXFxcZCopPykoW2ttYl0pJFwiLCAnaScpO1xuICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKHJlZyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBkaWdpdHMgPSBtYXRjaFsxXSwgYWJiciA9IG1hdGNoWzNdO1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IGFiYnJNYXBbYWJici50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgcmV0dXJuIE51bWJlcihkaWdpdHMucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpKSAqIG11bHRpcGxpZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBncm91cCBzZXBhcmF0b3IgZnJvbSB2YWx1ZSBlZy4gMSwwMDAgPiAxMDAwXG4gKi9cbnZhciByZW1vdmVTZXBhcmF0b3JzID0gZnVuY3Rpb24gKHZhbHVlLCBzZXBhcmF0b3IpIHtcbiAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDApIHsgc2VwYXJhdG9yID0gJywnOyB9XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHNlcGFyYXRvciksICdnJyk7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnLCAnJyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpbnZhbGlkIGNoYXJhY3RlcnNcbiAqL1xudmFyIHJlbW92ZUludmFsaWRDaGFycyA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFsaWRDaGFycykge1xuICAgIHZhciBjaGFycyA9IGVzY2FwZVJlZ0V4cCh2YWxpZENoYXJzLmpvaW4oJycpKTtcbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChcIlteXFxcXGRcIiArIGNoYXJzICsgXCJdXCIsICdnaScpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZywgJycpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgcHJlZml4LCBzZXBhcmF0b3JzIGFuZCBleHRyYSBkZWNpbWFscyBmcm9tIHZhbHVlXG4gKi9cbnZhciBjbGVhblZhbHVlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWUsIF9iID0gX2EuZ3JvdXBTZXBhcmF0b3IsIGdyb3VwU2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/ICcsJyA6IF9iLCBfYyA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IgPSBfYyA9PT0gdm9pZCAwID8gJy4nIDogX2MsIF9kID0gX2EuYWxsb3dEZWNpbWFscywgYWxsb3dEZWNpbWFscyA9IF9kID09PSB2b2lkIDAgPyB0cnVlIDogX2QsIF9lID0gX2EuZGVjaW1hbHNMaW1pdCwgZGVjaW1hbHNMaW1pdCA9IF9lID09PSB2b2lkIDAgPyAyIDogX2UsIF9mID0gX2EuYWxsb3dOZWdhdGl2ZVZhbHVlLCBhbGxvd05lZ2F0aXZlVmFsdWUgPSBfZiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9mLCBfZyA9IF9hLmRpc2FibGVBYmJyZXZpYXRpb25zLCBkaXNhYmxlQWJicmV2aWF0aW9ucyA9IF9nID09PSB2b2lkIDAgPyBmYWxzZSA6IF9nLCBfaCA9IF9hLnByZWZpeCwgcHJlZml4ID0gX2ggPT09IHZvaWQgMCA/ICcnIDogX2gsIF9qID0gX2EudHJhbnNmb3JtUmF3VmFsdWUsIHRyYW5zZm9ybVJhd1ZhbHVlID0gX2ogPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChyYXdWYWx1ZSkgeyByZXR1cm4gcmF3VmFsdWU7IH0gOiBfajtcbiAgICB2YXIgdHJhbnNmb3JtZWRWYWx1ZSA9IHRyYW5zZm9ybVJhd1ZhbHVlKHZhbHVlKTtcbiAgICBpZiAodHJhbnNmb3JtZWRWYWx1ZSA9PT0gJy0nKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFZhbHVlO1xuICAgIH1cbiAgICB2YXIgYWJicmV2aWF0aW9ucyA9IGRpc2FibGVBYmJyZXZpYXRpb25zID8gW10gOiBbJ2snLCAnbScsICdiJ107XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoKF58XFxcXEQpLVxcXFxkKXwoLVwiICsgZXNjYXBlUmVnRXhwKHByZWZpeCkgKyBcIilcIik7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSByZWcudGVzdCh0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAvLyBJcyB0aGVyZSBhIGRpZ2l0IGJlZm9yZSB0aGUgcHJlZml4PyBlZy4gMSRcbiAgICB2YXIgX2sgPSBSZWdFeHAoXCIoXFxcXGQrKS0/XCIgKyBlc2NhcGVSZWdFeHAocHJlZml4KSkuZXhlYyh2YWx1ZSkgfHwgW10sIHByZWZpeFdpdGhWYWx1ZSA9IF9rWzBdLCBwcmVWYWx1ZSA9IF9rWzFdO1xuICAgIHZhciB3aXRob3V0UHJlZml4ID0gcHJlZml4XG4gICAgICAgID8gcHJlZml4V2l0aFZhbHVlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVkVmFsdWUucmVwbGFjZShwcmVmaXhXaXRoVmFsdWUsICcnKS5jb25jYXQocHJlVmFsdWUpXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVkVmFsdWUucmVwbGFjZShwcmVmaXgsICcnKVxuICAgICAgICA6IHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgdmFyIHdpdGhvdXRTZXBhcmF0b3JzID0gcmVtb3ZlU2VwYXJhdG9ycyh3aXRob3V0UHJlZml4LCBncm91cFNlcGFyYXRvcik7XG4gICAgdmFyIHdpdGhvdXRJbnZhbGlkQ2hhcnMgPSByZW1vdmVJbnZhbGlkQ2hhcnMod2l0aG91dFNlcGFyYXRvcnMsIF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICBncm91cFNlcGFyYXRvcixcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvclxuICAgIF0sIGFiYnJldmlhdGlvbnMpKTtcbiAgICB2YXIgdmFsdWVPbmx5ID0gd2l0aG91dEludmFsaWRDaGFycztcbiAgICBpZiAoIWRpc2FibGVBYmJyZXZpYXRpb25zKSB7XG4gICAgICAgIC8vIGRpc2FsbG93IGxldHRlciB3aXRob3V0IG51bWJlclxuICAgICAgICBpZiAoYWJicmV2aWF0aW9ucy5zb21lKGZ1bmN0aW9uIChsZXR0ZXIpIHsgcmV0dXJuIGxldHRlciA9PT0gd2l0aG91dEludmFsaWRDaGFycy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJycpOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUFiYnJWYWx1ZSh3aXRob3V0SW52YWxpZENoYXJzLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgdmFsdWVPbmx5ID0gU3RyaW5nKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGluY2x1ZGVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUgJiYgYWxsb3dOZWdhdGl2ZVZhbHVlID8gJy0nIDogJyc7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiYgdmFsdWVPbmx5LmluY2x1ZGVzKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgIHZhciBfbCA9IHdpdGhvdXRJbnZhbGlkQ2hhcnMuc3BsaXQoZGVjaW1hbFNlcGFyYXRvciksIGludCA9IF9sWzBdLCBkZWNpbWFscyA9IF9sWzFdO1xuICAgICAgICB2YXIgdHJpbW1lZERlY2ltYWxzID0gZGVjaW1hbHNMaW1pdCAmJiBkZWNpbWFscyA/IGRlY2ltYWxzLnNsaWNlKDAsIGRlY2ltYWxzTGltaXQpIDogZGVjaW1hbHM7XG4gICAgICAgIHZhciBpbmNsdWRlRGVjaW1hbHMgPSBhbGxvd0RlY2ltYWxzID8gXCJcIiArIGRlY2ltYWxTZXBhcmF0b3IgKyB0cmltbWVkRGVjaW1hbHMgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIgKyBpbmNsdWRlTmVnYXRpdmUgKyBpbnQgKyBpbmNsdWRlRGVjaW1hbHM7XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgaW5jbHVkZU5lZ2F0aXZlICsgdmFsdWVPbmx5O1xufTtcblxudmFyIGZpeGVkRGVjaW1hbFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBmaXhlZERlY2ltYWxMZW5ndGgpIHtcbiAgICBpZiAoZml4ZWREZWNpbWFsTGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB2YWx1ZS5zcGxpdChkZWNpbWFsU2VwYXJhdG9yKSwgaW50ID0gX2FbMF0sIGRlY2ltYWxzID0gX2FbMV07XG4gICAgICAgICAgICBpZiAoZGVjaW1hbHMubGVuZ3RoID4gZml4ZWREZWNpbWFsTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyBpbnQgKyBkZWNpbWFsU2VwYXJhdG9yICsgZGVjaW1hbHMuc2xpY2UoMCwgZml4ZWREZWNpbWFsTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnID0gdmFsdWUubGVuZ3RoID4gZml4ZWREZWNpbWFsTGVuZ3RoXG4gICAgICAgICAgICA/IG5ldyBSZWdFeHAoXCIoXFxcXGQrKShcXFxcZHtcIiArIGZpeGVkRGVjaW1hbExlbmd0aCArIFwifSlcIilcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIihcXFxcZCkoXFxcXGQrKVwiKTtcbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaW50ID0gbWF0Y2hbMV0sIGRlY2ltYWxzID0gbWF0Y2hbMl07XG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIGludCArIGRlY2ltYWxTZXBhcmF0b3IgKyBkZWNpbWFscztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2V0U3VmZml4ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgIHZhciBfYiA9IF9hLmdyb3VwU2VwYXJhdG9yLCBncm91cFNlcGFyYXRvciA9IF9iID09PSB2b2lkIDAgPyAnLCcgOiBfYiwgX2MgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yID0gX2MgPT09IHZvaWQgMCA/ICcuJyA6IF9jO1xuICAgIHZhciBzdWZmaXhSZWcgPSBuZXcgUmVnRXhwKFwiXFxcXGQoW15cIiArIGVzY2FwZVJlZ0V4cChncm91cFNlcGFyYXRvcikgKyBlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvcikgKyBcIjAtOV0rKVwiKTtcbiAgICB2YXIgc3VmZml4TWF0Y2ggPSB2YWx1ZS5tYXRjaChzdWZmaXhSZWcpO1xuICAgIHJldHVybiBzdWZmaXhNYXRjaCA/IHN1ZmZpeE1hdGNoWzFdIDogdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBGb3JtYXQgdmFsdWUgd2l0aCBkZWNpbWFsIHNlcGFyYXRvciwgZ3JvdXAgc2VwYXJhdG9yIGFuZCBwcmVmaXhcbiAqL1xudmFyIGZvcm1hdFZhbHVlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgX3ZhbHVlID0gb3B0aW9ucy52YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciA9IG9wdGlvbnMuZGVjaW1hbFNlcGFyYXRvciwgaW50bENvbmZpZyA9IG9wdGlvbnMuaW50bENvbmZpZywgZGVjaW1hbFNjYWxlID0gb3B0aW9ucy5kZWNpbWFsU2NhbGUsIF9hID0gb3B0aW9ucy5wcmVmaXgsIHByZWZpeCA9IF9hID09PSB2b2lkIDAgPyAnJyA6IF9hLCBfYiA9IG9wdGlvbnMuc3VmZml4LCBzdWZmaXggPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcbiAgICBpZiAoX3ZhbHVlID09PSAnJyB8fCBfdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChfdmFsdWUgPT09ICctJykge1xuICAgICAgICByZXR1cm4gJy0nO1xuICAgIH1cbiAgICB2YXIgaXNOZWdhdGl2ZSA9IG5ldyBSZWdFeHAoXCJeXFxcXGQ/LVwiICsgKHByZWZpeCA/IGVzY2FwZVJlZ0V4cChwcmVmaXgpICsgXCI/XCIgOiAnJykgKyBcIlxcXFxkXCIpLnRlc3QoX3ZhbHVlKTtcbiAgICB2YXIgdmFsdWUgPSBkZWNpbWFsU2VwYXJhdG9yICE9PSAnLidcbiAgICAgICAgPyByZXBsYWNlRGVjaW1hbFNlcGFyYXRvcihfdmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGlzTmVnYXRpdmUpXG4gICAgICAgIDogX3ZhbHVlO1xuICAgIHZhciBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyA9IHtcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBkZWNpbWFsU2NhbGUgfHwgMCxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyMCxcbiAgICB9O1xuICAgIHZhciBudW1iZXJGb3JtYXR0ZXIgPSBpbnRsQ29uZmlnXG4gICAgICAgID8gbmV3IEludGwuTnVtYmVyRm9ybWF0KGludGxDb25maWcubG9jYWxlLCBpbnRsQ29uZmlnLmN1cnJlbmN5XG4gICAgICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyksIHsgc3R5bGU6ICdjdXJyZW5jeScsIGN1cnJlbmN5OiBpbnRsQ29uZmlnLmN1cnJlbmN5IH0pIDogZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMpXG4gICAgICAgIDogbmV3IEludGwuTnVtYmVyRm9ybWF0KHVuZGVmaW5lZCwgZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMpO1xuICAgIHZhciBwYXJ0cyA9IG51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKE51bWJlcih2YWx1ZSkpO1xuICAgIHZhciBmb3JtYXR0ZWQgPSByZXBsYWNlUGFydHMocGFydHMsIG9wdGlvbnMpO1xuICAgIC8vIERvZXMgaW50bCBmb3JtYXR0aW5nIGFkZCBhIHN1ZmZpeD9cbiAgICB2YXIgaW50bFN1ZmZpeCA9IGdldFN1ZmZpeChmb3JtYXR0ZWQsIF9fYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgLy8gSW5jbHVkZSBkZWNpbWFsIHNlcGFyYXRvciBpZiB1c2VyIGlucHV0IGVuZHMgd2l0aCBkZWNpbWFsIHNlcGFyYXRvclxuICAgIHZhciBpbmNsdWRlRGVjaW1hbFNlcGFyYXRvciA9IF92YWx1ZS5zbGljZSgtMSkgPT09IGRlY2ltYWxTZXBhcmF0b3IgPyBkZWNpbWFsU2VwYXJhdG9yIDogJyc7XG4gICAgdmFyIF9jID0gdmFsdWUubWF0Y2goUmVnRXhwKCdcXFxcZCtcXFxcLihcXFxcZCspJykpIHx8IFtdLCBkZWNpbWFscyA9IF9jWzFdO1xuICAgIC8vIEtlZXAgb3JpZ2luYWwgZGVjaW1hbCBwYWRkaW5nIGlmIG5vIGRlY2ltYWxTY2FsZVxuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IHVuZGVmaW5lZCAmJiBkZWNpbWFscyAmJiBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIGlmIChmb3JtYXR0ZWQuaW5jbHVkZXMoZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKFJlZ0V4cChcIihcXFxcZCspKFwiICsgZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpICsgXCIpKFxcXFxkKylcIiwgJ2cnKSwgXCIkMSQyXCIgKyBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW50bFN1ZmZpeCAmJiAhc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoaW50bFN1ZmZpeCwgXCJcIiArIGRlY2ltYWxTZXBhcmF0b3IgKyBkZWNpbWFscyArIGludGxTdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gXCJcIiArIGZvcm1hdHRlZCArIGRlY2ltYWxTZXBhcmF0b3IgKyBkZWNpbWFscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VmZml4ICYmIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgZm9ybWF0dGVkICsgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IgKyBzdWZmaXg7XG4gICAgfVxuICAgIGlmIChpbnRsU3VmZml4ICYmIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiICsgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IgKyBpbnRsU3VmZml4KTtcbiAgICB9XG4gICAgaWYgKGludGxTdWZmaXggJiYgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiICsgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IgKyBzdWZmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gW2Zvcm1hdHRlZCwgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IsIHN1ZmZpeF0uam9pbignJyk7XG59O1xuLyoqXG4gKiBCZWZvcmUgY29udmVydGluZyB0byBOdW1iZXIsIGRlY2ltYWwgc2VwYXJhdG9yIGhhcyB0byBiZSAuXG4gKi9cbnZhciByZXBsYWNlRGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgaXNOZWdhdGl2ZSkge1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmIGRlY2ltYWxTZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnJlcGxhY2UoUmVnRXhwKGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgJ2cnKSwgJy4nKTtcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUgJiYgZGVjaW1hbFNlcGFyYXRvciA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFwiLVwiICsgbmV3VmFsdWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufTtcbnZhciByZXBsYWNlUGFydHMgPSBmdW5jdGlvbiAocGFydHMsIF9hKSB7XG4gICAgdmFyIHByZWZpeCA9IF9hLnByZWZpeCwgZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSA9IF9hLmRlY2ltYWxTY2FsZSwgX2IgPSBfYS5kaXNhYmxlR3JvdXBTZXBhcmF0b3JzLCBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgcmV0dXJuIHBhcnRzXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIF9hLCBpKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21pbnVzU2lnbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlLCBwcmVmaXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2KSwgW3ByZWZpeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2N1cnJlbmN5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCA/IHByZXYgOiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYpLCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgICAgcmV0dXJuICFkaXNhYmxlR3JvdXBTZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYpLCBbZ3JvdXBTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IGdyb3VwU2VwYXJhdG9yIDogdmFsdWVdKSA6IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkZWNpbWFsJykge1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkICYmIGRlY2ltYWxTY2FsZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFtkZWNpbWFsU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsU2VwYXJhdG9yIDogdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2ZyYWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiksIFtkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCA/IHZhbHVlLnNsaWNlKDAsIGRlY2ltYWxTY2FsZSkgOiB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYpLCBbdmFsdWVdKTtcbiAgICB9LCBbJyddKVxuICAgICAgICAuam9pbignJyk7XG59O1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBjdXJyZW5jeVN5bWJvbDogJycsXG4gICAgZ3JvdXBTZXBhcmF0b3I6ICcnLFxuICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcnLFxuICAgIHByZWZpeDogJycsXG4gICAgc3VmZml4OiAnJyxcbn07XG4vKipcbiAqIEdldCBsb2NhbGUgY29uZmlnIGZyb20gaW5wdXQgb3IgZGVmYXVsdFxuICovXG52YXIgZ2V0TG9jYWxlQ29uZmlnID0gZnVuY3Rpb24gKGludGxDb25maWcpIHtcbiAgICB2YXIgX2EgPSBpbnRsQ29uZmlnIHx8IHt9LCBsb2NhbGUgPSBfYS5sb2NhbGUsIGN1cnJlbmN5ID0gX2EuY3VycmVuY3k7XG4gICAgdmFyIG51bWJlckZvcm1hdHRlciA9IGxvY2FsZVxuICAgICAgICA/IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGN1cnJlbmN5ID8geyBjdXJyZW5jeTogY3VycmVuY3ksIHN0eWxlOiAnY3VycmVuY3knIH0gOiB1bmRlZmluZWQpXG4gICAgICAgIDogbmV3IEludGwuTnVtYmVyRm9ybWF0KCk7XG4gICAgcmV0dXJuIG51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKDEwMDAuMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpKSB7XG4gICAgICAgIGlmIChjdXJyLnR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBjdXJyZW5jeVN5bWJvbDogY3Vyci52YWx1ZSwgcHJlZml4OiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBjdXJyZW5jeVN5bWJvbDogY3Vyci52YWx1ZSwgc3VmZml4OiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgZ3JvdXBTZXBhcmF0b3I6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2RlY2ltYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGRlY2ltYWxTZXBhcmF0b3I6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgZGVmYXVsdENvbmZpZyk7XG59O1xuXG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIFJlZ0V4cCgvXFxkLywgJ2dpJykudGVzdChpbnB1dCk7IH07XG5cbnZhciBwYWRUcmltVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSkge1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDApIHsgZGVjaW1hbFNlcGFyYXRvciA9ICcuJzsgfVxuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghdmFsdWUubWF0Y2goL1xcZC9nKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBfYSA9IHZhbHVlLnNwbGl0KGRlY2ltYWxTZXBhcmF0b3IpLCBpbnQgPSBfYVswXSwgZGVjaW1hbHMgPSBfYVsxXTtcbiAgICBpZiAoZGVjaW1hbFNjYWxlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpbnQ7XG4gICAgfVxuICAgIHZhciBuZXdWYWx1ZSA9IGRlY2ltYWxzIHx8ICcnO1xuICAgIGlmIChuZXdWYWx1ZS5sZW5ndGggPCBkZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgd2hpbGUgKG5ld1ZhbHVlLmxlbmd0aCA8IGRlY2ltYWxTY2FsZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgKz0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIGRlY2ltYWxTY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiICsgaW50ICsgZGVjaW1hbFNlcGFyYXRvciArIG5ld1ZhbHVlO1xufTtcblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgbGFzdCBrZXkgc3Ryb2tlIGFuZCB0aGUgY3Vyc29yIHBvc2l0aW9uLCB1cGRhdGUgdGhlIHZhbHVlXG4gKiBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yIHRvIHRoZSByaWdodCBwbGFjZVxuICovXG52YXIgcmVwb3NpdGlvbkN1cnNvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IF9hLnNlbGVjdGlvblN0YXJ0LCB2YWx1ZSA9IF9hLnZhbHVlLCBsYXN0S2V5U3Ryb2tlID0gX2EubGFzdEtleVN0cm9rZSwgc3RhdGVWYWx1ZSA9IF9hLnN0YXRlVmFsdWUsIGdyb3VwU2VwYXJhdG9yID0gX2EuZ3JvdXBTZXBhcmF0b3I7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoc3RhdGVWYWx1ZSAmJiBjdXJzb3JQb3NpdGlvbikge1xuICAgICAgICB2YXIgc3BsaXRWYWx1ZSA9IHZhbHVlLnNwbGl0KCcnKTtcbiAgICAgICAgLy8gaWYgY3Vyc29yIGlzIHRvIHJpZ2h0IG9mIGdyb3VwU2VwYXJhdG9yIGFuZCBiYWNrc3BhY2UgcHJlc3NlZCwgZGVsZXRlIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgb2YgdGhlIHNlcGFyYXRvciBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yXG4gICAgICAgIGlmIChsYXN0S2V5U3Ryb2tlID09PSAnQmFja3NwYWNlJyAmJiBzdGF0ZVZhbHVlW2N1cnNvclBvc2l0aW9uXSA9PT0gZ3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNwbGl0VmFsdWUuc3BsaWNlKGN1cnNvclBvc2l0aW9uIC0gMSwgMSk7XG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGN1cnNvciBpcyB0byBsZWZ0IG9mIGdyb3VwU2VwYXJhdG9yIGFuZCBkZWxldGUgcHJlc3NlZCwgZGVsZXRlIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBzZXBhcmF0b3IgYW5kIHJlcG9zaXRpb24gdGhlIGN1cnNvclxuICAgICAgICBpZiAobGFzdEtleVN0cm9rZSA9PT0gJ0RlbGV0ZScgJiYgc3RhdGVWYWx1ZVtjdXJzb3JQb3NpdGlvbl0gPT09IGdyb3VwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzcGxpdFZhbHVlLnNwbGljZShjdXJzb3JQb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBzcGxpdFZhbHVlLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZFZhbHVlOiBtb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbjogY3Vyc29yUG9zaXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWRWYWx1ZTogbW9kaWZpZWRWYWx1ZSwgY3Vyc29yUG9zaXRpb246IHNlbGVjdGlvblN0YXJ0IH07XG59O1xuXG52YXIgQ3VycmVuY3lJbnB1dCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKF9hLCByZWYpIHtcbiAgICB2YXIgX2IgPSBfYS5hbGxvd0RlY2ltYWxzLCBhbGxvd0RlY2ltYWxzID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBfYS5hbGxvd05lZ2F0aXZlVmFsdWUsIGFsbG93TmVnYXRpdmVWYWx1ZSA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIGlkID0gX2EuaWQsIG5hbWUgPSBfYS5uYW1lLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGN1c3RvbUlucHV0ID0gX2EuY3VzdG9tSW5wdXQsIGRlY2ltYWxzTGltaXQgPSBfYS5kZWNpbWFsc0xpbWl0LCBkZWZhdWx0VmFsdWUgPSBfYS5kZWZhdWx0VmFsdWUsIF9kID0gX2EuZGlzYWJsZWQsIGRpc2FibGVkID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHVzZXJNYXhMZW5ndGggPSBfYS5tYXhMZW5ndGgsIHVzZXJWYWx1ZSA9IF9hLnZhbHVlLCBvblZhbHVlQ2hhbmdlID0gX2Eub25WYWx1ZUNoYW5nZSwgZml4ZWREZWNpbWFsTGVuZ3RoID0gX2EuZml4ZWREZWNpbWFsTGVuZ3RoLCBwbGFjZWhvbGRlciA9IF9hLnBsYWNlaG9sZGVyLCBkZWNpbWFsU2NhbGUgPSBfYS5kZWNpbWFsU2NhbGUsIHByZWZpeCA9IF9hLnByZWZpeCwgc3VmZml4ID0gX2Euc3VmZml4LCBpbnRsQ29uZmlnID0gX2EuaW50bENvbmZpZywgc3RlcCA9IF9hLnN0ZXAsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBfZSA9IF9hLmRpc2FibGVHcm91cFNlcGFyYXRvcnMsIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYS5kaXNhYmxlQWJicmV2aWF0aW9ucywgZGlzYWJsZUFiYnJldmlhdGlvbnMgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZiwgX2RlY2ltYWxTZXBhcmF0b3IgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBfZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvciwgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgb25Gb2N1cyA9IF9hLm9uRm9jdXMsIG9uQmx1ciA9IF9hLm9uQmx1ciwgb25LZXlEb3duID0gX2Eub25LZXlEb3duLCBvbktleVVwID0gX2Eub25LZXlVcCwgdHJhbnNmb3JtUmF3VmFsdWUgPSBfYS50cmFuc2Zvcm1SYXdWYWx1ZSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImFsbG93RGVjaW1hbHNcIiwgXCJhbGxvd05lZ2F0aXZlVmFsdWVcIiwgXCJpZFwiLCBcIm5hbWVcIiwgXCJjbGFzc05hbWVcIiwgXCJjdXN0b21JbnB1dFwiLCBcImRlY2ltYWxzTGltaXRcIiwgXCJkZWZhdWx0VmFsdWVcIiwgXCJkaXNhYmxlZFwiLCBcIm1heExlbmd0aFwiLCBcInZhbHVlXCIsIFwib25WYWx1ZUNoYW5nZVwiLCBcImZpeGVkRGVjaW1hbExlbmd0aFwiLCBcInBsYWNlaG9sZGVyXCIsIFwiZGVjaW1hbFNjYWxlXCIsIFwicHJlZml4XCIsIFwic3VmZml4XCIsIFwiaW50bENvbmZpZ1wiLCBcInN0ZXBcIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJkaXNhYmxlR3JvdXBTZXBhcmF0b3JzXCIsIFwiZGlzYWJsZUFiYnJldmlhdGlvbnNcIiwgXCJkZWNpbWFsU2VwYXJhdG9yXCIsIFwiZ3JvdXBTZXBhcmF0b3JcIiwgXCJvbkNoYW5nZVwiLCBcIm9uRm9jdXNcIiwgXCJvbkJsdXJcIiwgXCJvbktleURvd25cIiwgXCJvbktleVVwXCIsIFwidHJhbnNmb3JtUmF3VmFsdWVcIl0pO1xuICAgIGlmIChfZGVjaW1hbFNlcGFyYXRvciAmJiBpc051bWJlcihfZGVjaW1hbFNlcGFyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWNpbWFsU2VwYXJhdG9yIGNhbm5vdCBiZSBhIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAoX2dyb3VwU2VwYXJhdG9yICYmIGlzTnVtYmVyKF9ncm91cFNlcGFyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdncm91cFNlcGFyYXRvciBjYW5ub3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgdmFyIGxvY2FsZUNvbmZpZyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TG9jYWxlQ29uZmlnKGludGxDb25maWcpOyB9LCBbaW50bENvbmZpZ10pO1xuICAgIHZhciBkZWNpbWFsU2VwYXJhdG9yID0gX2RlY2ltYWxTZXBhcmF0b3IgfHwgbG9jYWxlQ29uZmlnLmRlY2ltYWxTZXBhcmF0b3IgfHwgJyc7XG4gICAgdmFyIGdyb3VwU2VwYXJhdG9yID0gX2dyb3VwU2VwYXJhdG9yIHx8IGxvY2FsZUNvbmZpZy5ncm91cFNlcGFyYXRvciB8fCAnJztcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJlxuICAgICAgICBncm91cFNlcGFyYXRvciAmJlxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yID09PSBncm91cFNlcGFyYXRvciAmJlxuICAgICAgICBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlY2ltYWxTZXBhcmF0b3IgY2Fubm90IGJlIHRoZSBzYW1lIGFzIGdyb3VwU2VwYXJhdG9yJyk7XG4gICAgfVxuICAgIHZhciBmb3JtYXRWYWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IsXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgZGlzYWJsZUdyb3VwU2VwYXJhdG9yczogZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyxcbiAgICAgICAgaW50bENvbmZpZzogaW50bENvbmZpZyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXggfHwgbG9jYWxlQ29uZmlnLnByZWZpeCxcbiAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgfTtcbiAgICB2YXIgY2xlYW5WYWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgIGRlY2ltYWxTZXBhcmF0b3I6IGRlY2ltYWxTZXBhcmF0b3IsXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvcixcbiAgICAgICAgYWxsb3dEZWNpbWFsczogYWxsb3dEZWNpbWFscyxcbiAgICAgICAgZGVjaW1hbHNMaW1pdDogZGVjaW1hbHNMaW1pdCB8fCBmaXhlZERlY2ltYWxMZW5ndGggfHwgMixcbiAgICAgICAgYWxsb3dOZWdhdGl2ZVZhbHVlOiBhbGxvd05lZ2F0aXZlVmFsdWUsXG4gICAgICAgIGRpc2FibGVBYmJyZXZpYXRpb25zOiBkaXNhYmxlQWJicmV2aWF0aW9ucyxcbiAgICAgICAgcHJlZml4OiBwcmVmaXggfHwgbG9jYWxlQ29uZmlnLnByZWZpeCxcbiAgICAgICAgdHJhbnNmb3JtUmF3VmFsdWU6IHRyYW5zZm9ybVJhd1ZhbHVlLFxuICAgIH07XG4gICAgdmFyIGZvcm1hdHRlZFN0YXRlVmFsdWUgPSBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgIT09IG51bGxcbiAgICAgICAgPyBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyhkZWZhdWx0VmFsdWUpIH0pKVxuICAgICAgICA6IHVzZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHVzZXJWYWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgPyBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyh1c2VyVmFsdWUpIH0pKVxuICAgICAgICAgICAgOiAnJztcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShmb3JtYXR0ZWRTdGF0ZVZhbHVlKSwgc3RhdGVWYWx1ZSA9IF9nWzBdLCBzZXRTdGF0ZVZhbHVlID0gX2dbMV07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUoZmFsc2UpLCBkaXJ0eSA9IF9oWzBdLCBzZXREaXJ0eSA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKDApLCBjdXJzb3IgPSBfalswXSwgc2V0Q3Vyc29yID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUoMCksIGNoYW5nZUNvdW50ID0gX2tbMF0sIHNldENoYW5nZUNvdW50ID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUobnVsbCksIGxhc3RLZXlTdHJva2UgPSBfbFswXSwgc2V0TGFzdEtleVN0cm9rZSA9IF9sWzFdO1xuICAgIHZhciBpbnB1dFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXRSZWYuY3VycmVudDsgfSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBjaGFuZ2UgaW4gdmFsdWVcbiAgICAgKi9cbiAgICB2YXIgcHJvY2Vzc0NoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpIHtcbiAgICAgICAgc2V0RGlydHkodHJ1ZSk7XG4gICAgICAgIHZhciBfYSA9IHJlcG9zaXRpb25DdXJzb3Ioe1xuICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQ6IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFzdEtleVN0cm9rZTogbGFzdEtleVN0cm9rZSxcbiAgICAgICAgICAgIHN0YXRlVmFsdWU6IHN0YXRlVmFsdWUsXG4gICAgICAgICAgICBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgIH0pLCBtb2RpZmllZFZhbHVlID0gX2EubW9kaWZpZWRWYWx1ZSwgY3Vyc29yUG9zaXRpb24gPSBfYS5jdXJzb3JQb3NpdGlvbjtcbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gY2xlYW5WYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiBtb2RpZmllZFZhbHVlIH0sIGNsZWFuVmFsdWVPcHRpb25zKSk7XG4gICAgICAgIGlmICh1c2VyTWF4TGVuZ3RoICYmIHN0cmluZ1ZhbHVlLnJlcGxhY2UoLy0vZywgJycpLmxlbmd0aCA+IHVzZXJNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nVmFsdWUgPT09ICcnIHx8IHN0cmluZ1ZhbHVlID09PSAnLScgfHwgc3RyaW5nVmFsdWUgPT09IGRlY2ltYWxTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2UgJiYgb25WYWx1ZUNoYW5nZSh1bmRlZmluZWQsIG5hbWUsIHsgZmxvYXQ6IG51bGwsIGZvcm1hdHRlZDogJycsIHZhbHVlOiAnJyB9KTtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUoc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgLy8gQWx3YXlzIHNldHMgY3Vyc29yIGFmdGVyICctJyBvciBkZWNpbWFsU2VwYXJhdG9yIGlucHV0XG4gICAgICAgICAgICBzZXRDdXJzb3IoMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlV2l0aG91dFNlcGFyYXRvciA9IGRlY2ltYWxTZXBhcmF0b3JcbiAgICAgICAgICAgID8gc3RyaW5nVmFsdWUucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpXG4gICAgICAgICAgICA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB2YXIgbnVtYmVyVmFsdWUgPSBwYXJzZUZsb2F0KHN0cmluZ1ZhbHVlV2l0aG91dFNlcGFyYXRvcik7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdFZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHN0cmluZ1ZhbHVlIH0sIGZvcm1hdFZhbHVlT3B0aW9ucykpO1xuICAgICAgICBpZiAoY3Vyc29yUG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJiBjdXJzb3JQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBjdXJzb3IganVtcGluZ1xuICAgICAgICAgICAgdmFyIG5ld0N1cnNvciA9IGN1cnNvclBvc2l0aW9uICsgKGZvcm1hdHRlZFZhbHVlLmxlbmd0aCAtIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdDdXJzb3IgPSBuZXdDdXJzb3IgPD0gMCA/IChwcmVmaXggPyBwcmVmaXgubGVuZ3RoIDogMCkgOiBuZXdDdXJzb3I7XG4gICAgICAgICAgICBzZXRDdXJzb3IobmV3Q3Vyc29yKTtcbiAgICAgICAgICAgIHNldENoYW5nZUNvdW50KGNoYW5nZUNvdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdGVWYWx1ZShmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIGlmIChvblZhbHVlQ2hhbmdlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIGZsb2F0OiBudW1iZXJWYWx1ZSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IGZvcm1hdHRlZFZhbHVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHJpbmdWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlKHN0cmluZ1ZhbHVlLCBuYW1lLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2hhbmdlIGV2ZW50XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IGV2ZW50LnRhcmdldCwgdmFsdWUgPSBfYS52YWx1ZSwgc2VsZWN0aW9uU3RhcnQgPSBfYS5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgcHJvY2Vzc0NoYW5nZSh2YWx1ZSwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICBvbkNoYW5nZSAmJiBvbkNoYW5nZShldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgZm9jdXMgZXZlbnRcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25Gb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBvbkZvY3VzICYmIG9uRm9jdXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZSA/IHN0YXRlVmFsdWUubGVuZ3RoIDogMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBibHVyIGV2ZW50XG4gICAgICpcbiAgICAgKiBGb3JtYXQgdmFsdWUgYnkgcGFkZGluZy90cmltbWluZyBkZWNpbWFscyBpZiByZXF1aXJlZCBieVxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbkJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB2YXIgdmFsdWVPbmx5ID0gY2xlYW5WYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiB2YWx1ZSB9LCBjbGVhblZhbHVlT3B0aW9ucykpO1xuICAgICAgICBpZiAodmFsdWVPbmx5ID09PSAnLScgfHwgdmFsdWVPbmx5ID09PSBkZWNpbWFsU2VwYXJhdG9yIHx8ICF2YWx1ZU9ubHkpIHtcbiAgICAgICAgICAgIHNldFN0YXRlVmFsdWUoJycpO1xuICAgICAgICAgICAgb25CbHVyICYmIG9uQmx1cihldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpeGVkRGVjaW1hbHMgPSBmaXhlZERlY2ltYWxWYWx1ZSh2YWx1ZU9ubHksIGRlY2ltYWxTZXBhcmF0b3IsIGZpeGVkRGVjaW1hbExlbmd0aCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHBhZFRyaW1WYWx1ZShmaXhlZERlY2ltYWxzLCBkZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2NhbGUgIT09IHVuZGVmaW5lZCA/IGRlY2ltYWxTY2FsZSA6IGZpeGVkRGVjaW1hbExlbmd0aCk7XG4gICAgICAgIHZhciBudW1iZXJWYWx1ZSA9IHBhcnNlRmxvYXQobmV3VmFsdWUucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpKTtcbiAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgdmFsdWU6IG5ld1ZhbHVlIH0pKTtcbiAgICAgICAgaWYgKG9uVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2UobmV3VmFsdWUsIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBmbG9hdDogbnVtYmVyVmFsdWUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0ZVZhbHVlKGZvcm1hdHRlZFZhbHVlKTtcbiAgICAgICAgb25CbHVyICYmIG9uQmx1cihldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5IGRvd24gZXZlbnRcbiAgICAgKlxuICAgICAqIEluY3JlYXNlIG9yIGRlY3JlYXNlIHZhbHVlIGJ5IHN0ZXBcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXk7XG4gICAgICAgIHNldExhc3RLZXlTdHJva2Uoa2V5KTtcbiAgICAgICAgaWYgKHN0ZXAgJiYgKGtleSA9PT0gJ0Fycm93VXAnIHx8IGtleSA9PT0gJ0Fycm93RG93bicpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2V0Q3Vyc29yKHN0YXRlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KHVzZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHVzZXJWYWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHVzZXJWYWx1ZSkucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpXG4gICAgICAgICAgICAgICAgOiBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHN0YXRlVmFsdWUgfSwgY2xlYW5WYWx1ZU9wdGlvbnMpKSkgfHwgMDtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGtleSA9PT0gJ0Fycm93VXAnID8gY3VycmVudFZhbHVlICsgc3RlcCA6IGN1cnJlbnRWYWx1ZSAtIHN0ZXA7XG4gICAgICAgICAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZml4ZWRMZW5ndGggPSBTdHJpbmcoc3RlcCkuaW5jbHVkZXMoJy4nKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKFN0cmluZyhzdGVwKS5zcGxpdCgnLicpWzFdLmxlbmd0aClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHByb2Nlc3NDaGFuZ2UoU3RyaW5nKGZpeGVkTGVuZ3RoID8gbmV3VmFsdWUudG9GaXhlZChmaXhlZExlbmd0aCkgOiBuZXdWYWx1ZSkucmVwbGFjZSgnLicsIGRlY2ltYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBvbktleURvd24gJiYgb25LZXlEb3duKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXkgdXAgZXZlbnRcbiAgICAgKlxuICAgICAqIE1vdmUgY3Vyc29yIGlmIHRoZXJlIGlzIGEgc3VmZml4IHRvIHByZXZlbnQgdXNlciB0eXBpbmcgcGFzdCBzdWZmaXhcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25LZXlVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5LCBzZWxlY3Rpb25TdGFydCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGlmIChrZXkgIT09ICdBcnJvd1VwJyAmJiBrZXkgIT09ICdBcnJvd0Rvd24nICYmIHN0YXRlVmFsdWUgIT09ICctJykge1xuICAgICAgICAgICAgdmFyIHN1ZmZpeF8xID0gZ2V0U3VmZml4KHN0YXRlVmFsdWUsIHsgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yOiBkZWNpbWFsU2VwYXJhdG9yIH0pO1xuICAgICAgICAgICAgaWYgKHN1ZmZpeF8xICYmIHNlbGVjdGlvblN0YXJ0ICYmIHNlbGVjdGlvblN0YXJ0ID4gc3RhdGVWYWx1ZS5sZW5ndGggLSBzdWZmaXhfMS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdDdXJzb3IgPSBzdGF0ZVZhbHVlLmxlbmd0aCAtIHN1ZmZpeF8xLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuY3VycmVudC5zZXRTZWxlY3Rpb25SYW5nZShuZXdDdXJzb3IsIG5ld0N1cnNvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9uS2V5VXAgJiYgb25LZXlVcChldmVudCk7XG4gICAgfTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBwcmV2ZW50IGN1cnNvciBqdW1waW5nIGlmIGVkaXRpbmcgdmFsdWVcbiAgICAgICAgaWYgKGRpcnR5ICYmXG4gICAgICAgICAgICBzdGF0ZVZhbHVlICE9PSAnLScgJiZcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2V0U2VsZWN0aW9uUmFuZ2UoY3Vyc29yLCBjdXJzb3IpO1xuICAgICAgICB9XG4gICAgfSwgW3N0YXRlVmFsdWUsIGN1cnNvciwgaW5wdXRSZWYsIGRpcnR5LCBjaGFuZ2VDb3VudF0pO1xuICAgIC8qKlxuICAgICAqIElmIHVzZXIgaGFzIG9ubHkgZW50ZXJlZCBcIi1cIiBvciBkZWNpbWFsIHNlcGFyYXRvcixcbiAgICAgKiBrZWVwIHRoZSBjaGFyIHRvIGFsbG93IHRoZW0gdG8gZW50ZXIgbmV4dCB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBnZXRSZW5kZXJWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHVzZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB1c2VyVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHN0YXRlVmFsdWUgIT09ICctJyAmJlxuICAgICAgICAgICAgKCFkZWNpbWFsU2VwYXJhdG9yIHx8IHN0YXRlVmFsdWUgIT09IGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUoX19hc3NpZ24oX19hc3NpZ24oe30sIGZvcm1hdFZhbHVlT3B0aW9ucyksIHsgZGVjaW1hbFNjYWxlOiBkaXJ0eSA/IHVuZGVmaW5lZCA6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyh1c2VyVmFsdWUpIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVWYWx1ZTtcbiAgICB9O1xuICAgIHZhciBpbnB1dFByb3BzID0gX19hc3NpZ24oeyB0eXBlOiAndGV4dCcsIGlucHV0TW9kZTogJ2RlY2ltYWwnLCBpZDogaWQsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBvbkNoYW5nZTogaGFuZGxlT25DaGFuZ2UsIG9uQmx1cjogaGFuZGxlT25CbHVyLCBvbkZvY3VzOiBoYW5kbGVPbkZvY3VzLCBvbktleURvd246IGhhbmRsZU9uS2V5RG93biwgb25LZXlVcDogaGFuZGxlT25LZXlVcCwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsIHZhbHVlOiBnZXRSZW5kZXJWYWx1ZSgpLCByZWY6IGlucHV0UmVmIH0sIHByb3BzKTtcbiAgICBpZiAoY3VzdG9tSW5wdXQpIHtcbiAgICAgICAgdmFyIEN1c3RvbUlucHV0ID0gY3VzdG9tSW5wdXQ7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEN1c3RvbUlucHV0LCBfX2Fzc2lnbih7fSwgaW5wdXRQcm9wcykpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImlucHV0XCIsIF9fYXNzaWduKHt9LCBpbnB1dFByb3BzKSk7XG59KTtcbkN1cnJlbmN5SW5wdXQuZGlzcGxheU5hbWUgPSAnQ3VycmVuY3lJbnB1dCc7XG5cbmV4cG9ydCBkZWZhdWx0IEN1cnJlbmN5SW5wdXQ7XG5leHBvcnQgeyBmb3JtYXRWYWx1ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZU1lbW8iLCJ1c2VTdGF0ZSIsInVzZVJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VFZmZlY3QiLCJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJsIiwiYXIiLCJBcnJheSIsInNsaWNlIiwiY29uY2F0IiwiZXNjYXBlUmVnRXhwIiwic3RyaW5nVG9Hb0ludG9UaGVSZWdleCIsInJlcGxhY2UiLCJhYmJyTWFwIiwiayIsIm0iLCJiIiwicGFyc2VBYmJyVmFsdWUiLCJ2YWx1ZSIsImRlY2ltYWxTZXBhcmF0b3IiLCJyZWciLCJSZWdFeHAiLCJtYXRjaCIsImRpZ2l0cyIsImFiYnIiLCJtdWx0aXBsaWVyIiwidG9Mb3dlckNhc2UiLCJOdW1iZXIiLCJ1bmRlZmluZWQiLCJyZW1vdmVTZXBhcmF0b3JzIiwic2VwYXJhdG9yIiwicmVtb3ZlSW52YWxpZENoYXJzIiwidmFsaWRDaGFycyIsImNoYXJzIiwiam9pbiIsImNsZWFuVmFsdWUiLCJfYSIsIl9iIiwiZ3JvdXBTZXBhcmF0b3IiLCJfYyIsIl9kIiwiYWxsb3dEZWNpbWFscyIsIl9lIiwiZGVjaW1hbHNMaW1pdCIsIl9mIiwiYWxsb3dOZWdhdGl2ZVZhbHVlIiwiX2ciLCJkaXNhYmxlQWJicmV2aWF0aW9ucyIsIl9oIiwicHJlZml4IiwiX2oiLCJ0cmFuc2Zvcm1SYXdWYWx1ZSIsInJhd1ZhbHVlIiwidHJhbnNmb3JtZWRWYWx1ZSIsImFiYnJldmlhdGlvbnMiLCJpc05lZ2F0aXZlIiwidGVzdCIsIl9rIiwiZXhlYyIsInByZWZpeFdpdGhWYWx1ZSIsInByZVZhbHVlIiwid2l0aG91dFByZWZpeCIsIndpdGhvdXRTZXBhcmF0b3JzIiwid2l0aG91dEludmFsaWRDaGFycyIsInZhbHVlT25seSIsInNvbWUiLCJsZXR0ZXIiLCJwYXJzZWQiLCJTdHJpbmciLCJpbmNsdWRlTmVnYXRpdmUiLCJpbmNsdWRlcyIsIl9sIiwic3BsaXQiLCJpbnQiLCJkZWNpbWFscyIsInRyaW1tZWREZWNpbWFscyIsImluY2x1ZGVEZWNpbWFscyIsImZpeGVkRGVjaW1hbFZhbHVlIiwiZml4ZWREZWNpbWFsTGVuZ3RoIiwiZ2V0U3VmZml4Iiwic3VmZml4UmVnIiwic3VmZml4TWF0Y2giLCJmb3JtYXRWYWx1ZSIsIm9wdGlvbnMiLCJfdmFsdWUiLCJpbnRsQ29uZmlnIiwiZGVjaW1hbFNjYWxlIiwic3VmZml4IiwicmVwbGFjZURlY2ltYWxTZXBhcmF0b3IiLCJkZWZhdWx0TnVtYmVyRm9ybWF0T3B0aW9ucyIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsIm51bWJlckZvcm1hdHRlciIsIkludGwiLCJOdW1iZXJGb3JtYXQiLCJsb2NhbGUiLCJjdXJyZW5jeSIsInN0eWxlIiwicGFydHMiLCJmb3JtYXRUb1BhcnRzIiwiZm9ybWF0dGVkIiwicmVwbGFjZVBhcnRzIiwiaW50bFN1ZmZpeCIsImluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yIiwibmV3VmFsdWUiLCJkaXNhYmxlR3JvdXBTZXBhcmF0b3JzIiwicmVkdWNlIiwicHJldiIsInR5cGUiLCJkZWZhdWx0Q29uZmlnIiwiY3VycmVuY3lTeW1ib2wiLCJnZXRMb2NhbGVDb25maWciLCJjdXJyIiwiaXNOdW1iZXIiLCJpbnB1dCIsInBhZFRyaW1WYWx1ZSIsInJlcG9zaXRpb25DdXJzb3IiLCJzZWxlY3Rpb25TdGFydCIsImxhc3RLZXlTdHJva2UiLCJzdGF0ZVZhbHVlIiwiY3Vyc29yUG9zaXRpb24iLCJtb2RpZmllZFZhbHVlIiwic3BsaXRWYWx1ZSIsInNwbGljZSIsIkN1cnJlbmN5SW5wdXQiLCJyZWYiLCJpZCIsIm5hbWUiLCJjbGFzc05hbWUiLCJjdXN0b21JbnB1dCIsImRlZmF1bHRWYWx1ZSIsImRpc2FibGVkIiwidXNlck1heExlbmd0aCIsIm1heExlbmd0aCIsInVzZXJWYWx1ZSIsIm9uVmFsdWVDaGFuZ2UiLCJwbGFjZWhvbGRlciIsInN0ZXAiLCJtaW4iLCJtYXgiLCJfZGVjaW1hbFNlcGFyYXRvciIsIl9ncm91cFNlcGFyYXRvciIsIm9uQ2hhbmdlIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uS2V5RG93biIsIm9uS2V5VXAiLCJwcm9wcyIsIkVycm9yIiwibG9jYWxlQ29uZmlnIiwiZm9ybWF0VmFsdWVPcHRpb25zIiwiY2xlYW5WYWx1ZU9wdGlvbnMiLCJmb3JtYXR0ZWRTdGF0ZVZhbHVlIiwic2V0U3RhdGVWYWx1ZSIsImRpcnR5Iiwic2V0RGlydHkiLCJjdXJzb3IiLCJzZXRDdXJzb3IiLCJjaGFuZ2VDb3VudCIsInNldENoYW5nZUNvdW50Iiwic2V0TGFzdEtleVN0cm9rZSIsImlucHV0UmVmIiwiY3VycmVudCIsInByb2Nlc3NDaGFuZ2UiLCJzdHJpbmdWYWx1ZSIsImZsb2F0Iiwic3RyaW5nVmFsdWVXaXRob3V0U2VwYXJhdG9yIiwibnVtYmVyVmFsdWUiLCJwYXJzZUZsb2F0IiwiZm9ybWF0dGVkVmFsdWUiLCJuZXdDdXJzb3IiLCJ2YWx1ZXMiLCJoYW5kbGVPbkNoYW5nZSIsImV2ZW50IiwidGFyZ2V0IiwiaGFuZGxlT25Gb2N1cyIsImhhbmRsZU9uQmx1ciIsImZpeGVkRGVjaW1hbHMiLCJoYW5kbGVPbktleURvd24iLCJrZXkiLCJwcmV2ZW50RGVmYXVsdCIsImN1cnJlbnRWYWx1ZSIsImZpeGVkTGVuZ3RoIiwidG9GaXhlZCIsImhhbmRsZU9uS2V5VXAiLCJjdXJyZW50VGFyZ2V0Iiwic3VmZml4XzEiLCJzZXRTZWxlY3Rpb25SYW5nZSIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImdldFJlbmRlclZhbHVlIiwiaW5wdXRQcm9wcyIsImlucHV0TW9kZSIsIkN1c3RvbUlucHV0IiwiY3JlYXRlRWxlbWVudCIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js\n");

/***/ })

};
;