"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@meilisearch";
exports.ids = ["vendor-chunks/@meilisearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   instantMeiliSearch: () => (/* binding */ instantMeiliSearch)\n/* harmony export */ });\n/* harmony import */ var meilisearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meilisearch */ \"(ssr)/./node_modules/meilisearch/dist/bundles/meilisearch.esm.js\");\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction __spreadArray(to, from) {\n    for(var i = 0, il = from.length, j = to.length; i < il; i++, j++)to[j] = from[i];\n    return to;\n}\nvar removeUndefined = function(arr) {\n    return arr.filter(function(x) {\n        return x !== undefined;\n    });\n};\n/**\r\n * @param  {any} str\r\n * @returns {boolean}\r\n */ /**\r\n * @param  {string} filter\r\n * @returns {string}\r\n */ function replaceColonByEqualSign(filter) {\n    // will only change first occurence of `:`\n    return filter.replace(/:(.*)/i, '=\"$1\"');\n}\n/**\r\n * @param  {any[]} arr\r\n * @returns {string}\r\n */ function stringifyArray(arr) {\n    return arr.reduce(function(acc, curr) {\n        return acc += JSON.stringify(curr);\n    }, \"\");\n}\n/**\r\n * @param  {number} dividend\r\n * @param  {number} divisor\r\n * @returns number\r\n */ function ceiledDivision(dividend, divisor) {\n    if (divisor > 0) {\n        var NumberPages = Math.ceil(dividend / divisor); // total number of pages rounded up to the next largest integer.\n        return NumberPages;\n    }\n    return 0;\n}\nfunction isPureObject(data) {\n    return typeof data === \"object\" && !Array.isArray(data) && data !== null;\n}\n/**\r\n * @param  {string} filter\r\n */ var adaptFilterSyntax = function(filter) {\n    var matches = filter.match(/([^=]*)=\"?([^\\\\\"]*)\"?$/);\n    if (matches) {\n        matches[0];\n        var filterName = matches[1], value = matches[2];\n        return [\n            {\n                filterName: filterName,\n                value: value\n            }\n        ];\n    }\n    return [];\n};\n/**\r\n * @param  {Filter} filters?\r\n * @returns {Array}\r\n */ function extractFilters(filters) {\n    if (typeof filters === \"string\") {\n        return adaptFilterSyntax(filters);\n    } else if (Array.isArray(filters)) {\n        return filters.map(function(nestedFilter) {\n            if (Array.isArray(nestedFilter)) {\n                return nestedFilter.map(function(filter) {\n                    return adaptFilterSyntax(filter);\n                });\n            }\n            return adaptFilterSyntax(nestedFilter);\n        }).flat(2);\n    }\n    return [];\n}\n/**\r\n * @param  {Filter} filters?\r\n * @returns {FacetsCache}\r\n */ function getFacetsFromFilter(filters) {\n    var extractedFilters = extractFilters(filters);\n    var cleanFilters = removeUndefined(extractedFilters);\n    return cleanFilters.reduce(function(cache, parsedFilter) {\n        var _a;\n        var filterName = parsedFilter.filterName, value = parsedFilter.value;\n        var prevFields = cache[filterName] || [];\n        cache = __assign(__assign({}, cache), (_a = {}, _a[filterName] = __spreadArray(__spreadArray([], prevFields, true), [\n            value\n        ]), _a));\n        return cache;\n    }, {});\n}\nfunction getFacetsFromDefaultDistribution(facetsDistribution) {\n    return Object.keys(facetsDistribution).reduce(function(cache, facet) {\n        var _a;\n        var facetValues = Object.keys(facetsDistribution[facet]);\n        return __assign(__assign({}, cache), (_a = {}, _a[facet] = facetValues, _a));\n    }, {});\n}\n/**\r\n * @param  {Filter} filters?\r\n * @returns {FacetsCache}\r\n */ function extractFacets(searchContext, searchParams) {\n    if (searchContext.keepZeroFacets) {\n        return getFacetsFromDefaultDistribution(searchContext.defaultFacetDistribution);\n    } else {\n        return getFacetsFromFilter(searchParams === null || searchParams === void 0 ? void 0 : searchParams.filter);\n    }\n}\n/**\r\n * Assign missing filters to facetsDistribution.\r\n * All facet passed as filter should appear in the facetsDistribution.\r\n * If not present, the facet is added with 0 as value.\r\n *\r\n *\r\n * @param  {FacetsCache} cache?\r\n * @param  {FacetsDistribution} distribution?\r\n * @returns {FacetsDistribution}\r\n */ function addMissingFacets(cachedFacets, distribution) {\n    distribution = distribution || {};\n    // If cachedFacets contains something\n    if (cachedFacets && Object.keys(cachedFacets).length > 0) {\n        // for all filters in cached filters\n        for(var cachedFacet in cachedFacets){\n            // if facet does not exist on returned distribution, add an empty object\n            if (!distribution[cachedFacet]) distribution[cachedFacet] = {};\n            // for all fields in every filter\n            for(var _i = 0, _a = cachedFacets[cachedFacet]; _i < _a.length; _i++){\n                var cachedField = _a[_i];\n                // if the field is not present in the returned distribution\n                // set it at 0\n                if (!Object.keys(distribution[cachedFacet]).includes(cachedField)) {\n                    // add 0 value\n                    distribution[cachedFacet][cachedField] = 0;\n                }\n            }\n        }\n    }\n    return distribution;\n}\nvar emptySearch = {\n    hits: [],\n    query: \"\",\n    facetsDistribution: {},\n    limit: 0,\n    offset: 0,\n    exhaustiveNbHits: false,\n    nbHits: 0,\n    processingTimeMs: 0\n};\n/**\r\n * @param  {ResponseCacher} cache\r\n */ function SearchResolver(cache) {\n    return {\n        /**\r\n         * @param  {SearchContext} searchContext\r\n         * @param  {MeiliSearchParams} searchParams\r\n         * @param  {MeiliSearch} client\r\n         * @returns {Promise}\r\n         */ searchResponse: function(searchContext, searchParams, client) {\n            return __awaiter(this, void 0, void 0, function() {\n                var placeholderSearch, query, pagination, paginationCache, key, cachedResponse, facetsCache, searchResponse;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            placeholderSearch = searchContext.placeholderSearch, query = searchContext.query;\n                            // query can be: empty string, undefined or null\n                            // all of them are falsy's\n                            if (!placeholderSearch && !query) {\n                                return [\n                                    2 /*return*/ ,\n                                    emptySearch\n                                ];\n                            }\n                            pagination = searchContext.pagination;\n                            paginationCache = searchContext.finitePagination ? {} : pagination;\n                            key = cache.formatKey([\n                                searchParams,\n                                searchContext.indexUid,\n                                searchContext.query,\n                                paginationCache\n                            ]);\n                            cachedResponse = cache.getEntry(key);\n                            // Check if specific request is already cached with its associated search response.\n                            if (cachedResponse) return [\n                                2 /*return*/ ,\n                                cachedResponse\n                            ];\n                            facetsCache = extractFacets(searchContext, searchParams);\n                            return [\n                                4 /*yield*/ ,\n                                client.index(searchContext.indexUid).search(searchContext.query, searchParams)\n                            ];\n                        case 1:\n                            searchResponse = _a.sent();\n                            // Add missing facets back into facetsDistribution\n                            searchResponse.facetsDistribution = addMissingFacets(facetsCache, searchResponse.facetsDistribution);\n                            // Cache response\n                            cache.setEntry(key, searchResponse);\n                            return [\n                                2 /*return*/ ,\n                                searchResponse\n                            ];\n                    }\n                });\n            });\n        }\n    };\n}\n/**\r\n * @param  {number} rad\r\n * @returns {number}\r\n */ function rad2degr(rad) {\n    return rad * 180 / Math.PI;\n}\n/**\r\n * @param  {number} degr\r\n * @returns {number}\r\n */ function degr2rad(degr) {\n    return degr * Math.PI / 180;\n}\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {string}\r\n */ function middleGeoPoints(lat1, lng1, lat2, lng2) {\n    // convert to radians\n    lat1 = degr2rad(lat1);\n    lng1 = degr2rad(lng1);\n    var x1 = Math.cos(lat1) * Math.cos(lng1);\n    var y1 = Math.cos(lat1) * Math.sin(lng1);\n    var z1 = Math.sin(lat1);\n    // convert to radians\n    lat2 = degr2rad(lat2);\n    lng2 = degr2rad(lng2);\n    var x2 = Math.cos(lat2) * Math.cos(lng2);\n    var y2 = Math.cos(lat2) * Math.sin(lng2);\n    var z2 = Math.sin(lat2);\n    var x = x1 + x2;\n    var y = y1 + y2;\n    var z = z1 + z2;\n    var Hyp = Math.sqrt(x * x + y * y);\n    var lng3 = Math.atan2(y, x);\n    var lat3 = Math.atan2(z, Hyp);\n    if (lng1 < lng2 || lng1 > lng2 && lng1 > Math.PI && lng2 < -Math.PI) {\n        lat3 = lat3 + Math.PI;\n        lng3 = lng3 + Math.PI;\n    } else {\n        lat3 = rad2degr(lat3);\n        lng3 = rad2degr(lng3);\n    }\n    if (Math.abs(x) < Math.pow(10, -9) && Math.abs(y) < Math.pow(10, -9) && Math.abs(z) < Math.pow(10, -9)) {\n        lat3 = 0;\n        lng3 = 0;\n    }\n    return \"\".concat(lat3, \",\").concat(lng3);\n}\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {number}\r\n */ function getDistanceInMeter(lat1, lng1, lat2, lng2) {\n    // Haversine Algorithm\n    var R = 6371e3; // metres\n    var latRad1 = lat1 * Math.PI / 180;\n    var latRad2 = lat2 * Math.PI / 180;\n    var latCenterRad = (lat2 - lat1) * Math.PI / 180;\n    var lngCenterRad = (lng2 - lng1) * Math.PI / 180;\n    var a = Math.sin(latCenterRad / 2) * Math.sin(latCenterRad / 2) + Math.cos(latRad1) * Math.cos(latRad2) * Math.sin(lngCenterRad / 2) * Math.sin(lngCenterRad / 2);\n    var bearing = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    var distance = R * bearing; // in metres\n    return distance;\n}\nfunction adaptGeoPointsRules(geoSearchContext) {\n    if (!geoSearchContext) {\n        return undefined;\n    }\n    var insideBoundingBox = geoSearchContext.insideBoundingBox, aroundLatLng = geoSearchContext.aroundLatLng, aroundRadius = geoSearchContext.aroundRadius, minimumAroundRadius = geoSearchContext.minimumAroundRadius;\n    var middlePoint;\n    var radius;\n    if (aroundLatLng) {\n        middlePoint = aroundLatLng;\n    }\n    if (aroundRadius != null || minimumAroundRadius != null) {\n        if (aroundRadius != null) radius = aroundRadius;\n        else radius = minimumAroundRadius;\n    }\n    // If insideBoundingBox is provided it takes precedent over all other options\n    if (insideBoundingBox && typeof insideBoundingBox === \"string\") {\n        var _a = insideBoundingBox.split(\",\"), lat1Raw = _a[0], lng1Raw = _a[1], lat2Raw = _a[2], lng2Raw = _a[3];\n        var _b = [\n            parseFloat(lat1Raw),\n            parseFloat(lng1Raw),\n            parseFloat(lat2Raw),\n            parseFloat(lng2Raw)\n        ], lat1 = _b[0], lng1 = _b[1], lat2 = _b[2], lng2 = _b[3];\n        radius = getDistanceInMeter(lat1, lng1, lat2, lng2) / 2;\n        middlePoint = middleGeoPoints(lat1, lng1, lat2, lng2);\n    }\n    if (middlePoint != null && radius != null) {\n        var _c = middlePoint.split(\",\"), lat3 = _c[0], lng3 = _c[1];\n        lat3 = Number.parseFloat(lat3).toFixed(5);\n        lng3 = Number.parseFloat(lng3).toFixed(5);\n        var filter = \"_geoRadius(\".concat(lat3, \", \").concat(lng3, \", \").concat(radius, \")\");\n        return {\n            filter: filter\n        };\n    }\n    return undefined;\n}\nfunction createGeoSearchContext(searchContext) {\n    var geoContext = {};\n    var aroundLatLng = searchContext.aroundLatLng, aroundLatLngViaIP = searchContext.aroundLatLngViaIP, aroundRadius = searchContext.aroundRadius, aroundPrecision = searchContext.aroundPrecision, minimumAroundRadius = searchContext.minimumAroundRadius, insideBoundingBox = searchContext.insideBoundingBox, insidePolygon = searchContext.insidePolygon;\n    if (aroundLatLng) {\n        geoContext.aroundLatLng = aroundLatLng;\n    }\n    if (aroundLatLngViaIP) {\n        console.warn(\"instant-meilisearch: `aroundLatLngViaIP` is not supported.\");\n    }\n    if (aroundRadius) {\n        geoContext.aroundRadius = aroundRadius;\n    }\n    if (aroundPrecision) {\n        console.warn(\"instant-meilisearch: `aroundPrecision` is not supported.\\n    See this discussion to track its implementation https://github.com/meilisearch/product/discussions/264\");\n    }\n    if (minimumAroundRadius) {\n        geoContext.minimumAroundRadius = minimumAroundRadius;\n    }\n    if (insideBoundingBox) {\n        geoContext.insideBoundingBox = insideBoundingBox;\n    }\n    // See related issue: https://github.com/meilisearch/instant-meilisearch/issues/555\n    if (insidePolygon) {\n        console.warn(\"instant-meilisearch: `insidePolygon` is not implented in instant-meilisearch.\");\n    }\n    return geoContext;\n}\n/**\r\n * Transform InstantSearch filter to Meilisearch filter.\r\n * Change sign from `:` to `=` in nested filter object.\r\n * example: [`genres:comedy`] becomes [`genres=comedy`]\r\n *\r\n * @param  {SearchContext['facetFilters']} filters?\r\n * @returns {Filter}\r\n */ function transformFilter(filters) {\n    if (typeof filters === \"string\") {\n        return replaceColonByEqualSign(filters);\n    } else if (Array.isArray(filters)) return filters.map(function(filter) {\n        if (Array.isArray(filter)) return filter.map(function(nestedFilter) {\n            return replaceColonByEqualSign(nestedFilter);\n        }).filter(function(elem) {\n            return elem;\n        });\n        else {\n            return replaceColonByEqualSign(filter);\n        }\n    }).filter(function(elem) {\n        return elem;\n    });\n    return [];\n}\n/**\r\n * Return the filter in an array if it is a string\r\n * If filter is array, return without change.\r\n *\r\n * @param  {Filter} filter\r\n * @returns {Array}\r\n */ function filterToArray(filter) {\n    // Filter is a string\n    if (filter === \"\") return [];\n    else if (typeof filter === \"string\") return [\n        filter\n    ];\n    // Filter is either an array of strings, or an array of array of strings\n    return filter;\n}\n/**\r\n * Merge facetFilters, numericFilters and filters together.\r\n *\r\n * @param  {Filter} facetFilters\r\n * @param  {Filter} numericFilters\r\n * @param  {string} filters\r\n * @returns {Filter}\r\n */ function mergeFilters(facetFilters, numericFilters, filters) {\n    var adaptedFilters = filters.trim();\n    var adaptedFacetFilters = filterToArray(facetFilters);\n    var adaptedNumericFilters = filterToArray(numericFilters);\n    var adaptedFilter = __spreadArray(__spreadArray(__spreadArray([], adaptedFacetFilters, true), adaptedNumericFilters, true), [\n        adaptedFilters\n    ]);\n    var cleanedFilters = adaptedFilter.filter(function(filter) {\n        if (Array.isArray(filter)) {\n            return filter.length;\n        }\n        return filter;\n    });\n    return cleanedFilters;\n}\n/**\r\n * Adapt instantsearch.js filters to Meilisearch filters by\r\n * combining and transforming all provided filters.\r\n *\r\n * @param  {string|undefined} filters\r\n * @param  {SearchContext['numericFilters']} numericFilters\r\n * @param  {SearchContext['facetFilters']} facetFilters\r\n * @returns {Filter}\r\n */ function adaptFilters(filters, numericFilters, facetFilters) {\n    var transformedFilter = transformFilter(facetFilters || []);\n    var transformedNumericFilter = transformFilter(numericFilters || []);\n    return mergeFilters(transformedFilter, transformedNumericFilter, filters || \"\");\n}\n/**\r\n * Adapt search request from instantsearch.js\r\n * to search request compliant with Meilisearch\r\n *\r\n * @param  {SearchContext} searchContext\r\n * @returns {MeiliSearchParams}\r\n */ function adaptSearchParams(searchContext) {\n    // Creates search params object compliant with Meilisearch\n    var meiliSearchParams = {};\n    // Facets\n    var facets = searchContext === null || searchContext === void 0 ? void 0 : searchContext.facets;\n    if (facets === null || facets === void 0 ? void 0 : facets.length) {\n        meiliSearchParams.facetsDistribution = facets;\n    }\n    // Attributes To Crop\n    var attributesToCrop = searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToSnippet;\n    if (attributesToCrop) {\n        meiliSearchParams.attributesToCrop = attributesToCrop;\n    }\n    // Attributes To Crop marker\n    var cropMarker = searchContext === null || searchContext === void 0 ? void 0 : searchContext.snippetEllipsisText;\n    if (cropMarker != null) {\n        meiliSearchParams.cropMarker = cropMarker;\n    }\n    // Attributes To Retrieve\n    var attributesToRetrieve = searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToRetrieve;\n    if (attributesToRetrieve) {\n        meiliSearchParams.attributesToRetrieve = attributesToRetrieve;\n    }\n    // Filter\n    var filter = adaptFilters(searchContext === null || searchContext === void 0 ? void 0 : searchContext.filters, searchContext === null || searchContext === void 0 ? void 0 : searchContext.numericFilters, searchContext === null || searchContext === void 0 ? void 0 : searchContext.facetFilters);\n    if (filter.length) {\n        meiliSearchParams.filter = filter;\n    }\n    // Attributes To Retrieve\n    if (attributesToRetrieve) {\n        meiliSearchParams.attributesToCrop = attributesToRetrieve;\n    }\n    // Attributes To Highlight\n    meiliSearchParams.attributesToHighlight = (searchContext === null || searchContext === void 0 ? void 0 : searchContext.attributesToHighlight) || [\n        \"*\"\n    ];\n    // Highlight pre tag\n    var highlightPreTag = searchContext === null || searchContext === void 0 ? void 0 : searchContext.highlightPreTag;\n    if (highlightPreTag) {\n        meiliSearchParams.highlightPreTag = highlightPreTag;\n    } else {\n        meiliSearchParams.highlightPreTag = \"__ais-highlight__\";\n    }\n    // Highlight post tag\n    var highlightPostTag = searchContext === null || searchContext === void 0 ? void 0 : searchContext.highlightPostTag;\n    if (highlightPostTag) {\n        meiliSearchParams.highlightPostTag = highlightPostTag;\n    } else {\n        meiliSearchParams.highlightPostTag = \"__/ais-highlight__\";\n    }\n    var placeholderSearch = searchContext.placeholderSearch;\n    var query = searchContext.query;\n    // Pagination\n    var pagination = searchContext.pagination;\n    // Limit based on pagination preferences\n    if (!placeholderSearch && query === \"\" || pagination.paginationTotalHits === 0) {\n        meiliSearchParams.limit = 0;\n    } else if (searchContext.finitePagination) {\n        meiliSearchParams.limit = pagination.paginationTotalHits;\n    } else {\n        var limit = (pagination.page + 1) * pagination.hitsPerPage + 1;\n        // If the limit is bigger than the total hits accepted\n        // force the limit to that amount\n        if (limit > pagination.paginationTotalHits) {\n            meiliSearchParams.limit = pagination.paginationTotalHits;\n        } else {\n            meiliSearchParams.limit = limit;\n        }\n    }\n    var sort = searchContext.sort;\n    // Sort\n    if (sort === null || sort === void 0 ? void 0 : sort.length) {\n        meiliSearchParams.sort = [\n            sort\n        ];\n    }\n    var geoSearchContext = createGeoSearchContext(searchContext);\n    var geoRules = adaptGeoPointsRules(geoSearchContext);\n    if (geoRules === null || geoRules === void 0 ? void 0 : geoRules.filter) {\n        if (meiliSearchParams.filter) {\n            meiliSearchParams.filter.unshift(geoRules.filter);\n        } else {\n            meiliSearchParams.filter = [\n                geoRules.filter\n            ];\n        }\n    }\n    return meiliSearchParams;\n}\n/**\r\n * Slice the requested hits based on the pagination position.\r\n *\r\n * @param  {Record<string} hits\r\n * @param  {number} page\r\n * @param  {number} hitsPerPage\r\n * @returns {Array}\r\n */ function adaptPagination(hits, page, hitsPerPage) {\n    if (hitsPerPage < 0) {\n        throw new TypeError('Value too small for \"hitsPerPage\" parameter, expected integer between 0 and 9223372036854775807');\n    }\n    var start = page * hitsPerPage;\n    return hits.slice(start, start + hitsPerPage);\n}\n/**\r\n * Stringify values following instantsearch practices.\r\n *\r\n * @param  {any} value - value that needs to be stringified\r\n */ function stringifyValue(value) {\n    if (typeof value === \"string\") {\n        // String\n        return value;\n    } else if (value === undefined) {\n        // undefined\n        return JSON.stringify(null);\n    } else {\n        return JSON.stringify(value);\n    }\n}\n/**\r\n * Recursif function wrap the deepest possible value\r\n * the following way: { value: \"xx\" }.\r\n *\r\n * For example:\r\n *\r\n * {\r\n * \"rootField\": { \"value\": \"x\" }\r\n * \"nestedField\": { child: { value: \"y\" } }\r\n * }\r\n *\r\n * recursivity continues until the value is not an array or an object.\r\n *\r\n * @param  {any} value - value of a field\r\n *\r\n * @returns Record<string, any>\r\n */ function wrapValue(value) {\n    if (Array.isArray(value)) {\n        // Array\n        return value.map(function(elem) {\n            return wrapValue(elem);\n        });\n    } else if (isPureObject(value)) {\n        // Object\n        return Object.keys(value).reduce(function(nested, key) {\n            nested[key] = wrapValue(value[key]);\n            return nested;\n        }, {});\n    } else {\n        return {\n            value: stringifyValue(value)\n        };\n    }\n}\n/**\r\n * Adapt Meilisearch formatted fields to a format compliant to instantsearch.js.\r\n *\r\n * @param  {Record<string} formattedHit\r\n * @param  {SearchContext} searchContext\r\n * @returns {Record}\r\n */ function adaptFormattedFields(hit) {\n    if (!hit) return {};\n    var _formattedResult = wrapValue(hit);\n    var highlightedHit = {\n        // We could not determine what the differences are between those two fields.\n        _highlightResult: _formattedResult,\n        _snippetResult: _formattedResult\n    };\n    return highlightedHit;\n}\n/**\r\n * @param  {any[]} hits\r\n * @returns {Array<Record<string, any>>}\r\n */ function adaptGeoResponse(hits) {\n    for(var i = 0; i < hits.length; i++){\n        if (hits[i]._geo) {\n            hits[i]._geoloc = {\n                lat: hits[i]._geo.lat,\n                lng: hits[i]._geo.lng\n            };\n            hits[i].objectID = \"\".concat(i + Math.random() * 1000000);\n            delete hits[i]._geo;\n        }\n    }\n    return hits;\n}\n/**\r\n * @param  {Array<Record<string} hits\r\n * @param  {SearchContext} searchContext\r\n * @param  {PaginationContext} paginationContext\r\n * @returns {any}\r\n */ function adaptHits(hits, searchContext, paginationContext) {\n    var primaryKey = searchContext.primaryKey;\n    var hitsPerPage = paginationContext.hitsPerPage, page = paginationContext.page;\n    var paginatedHits = adaptPagination(hits, page, hitsPerPage);\n    var adaptedHits = paginatedHits.map(function(hit) {\n        // Creates Hit object compliant with InstantSearch\n        if (Object.keys(hit).length > 0) {\n            var formattedHit = hit._formatted;\n            hit._matchesInfo;\n            var documentFields = __rest(hit, [\n                \"_formatted\",\n                \"_matchesInfo\"\n            ]);\n            var adaptedHit = Object.assign(documentFields, adaptFormattedFields(formattedHit));\n            if (primaryKey) {\n                adaptedHit.objectID = hit[primaryKey];\n            }\n            return adaptedHit;\n        }\n        return hit;\n    });\n    adaptedHits = adaptGeoResponse(adaptedHits);\n    return adaptedHits;\n}\n/**\r\n * Adapt search response from Meilisearch\r\n * to search response compliant with instantsearch.js\r\n *\r\n * @param  {MeiliSearchResponse<Record<string} searchResponse\r\n * @param  {SearchContext} searchContext\r\n * @param  {PaginationContext} paginationContext\r\n * @returns {{ results: Array<AlgoliaSearchResponse<T>> }}\r\n */ function adaptSearchResponse(searchResponse, searchContext) {\n    var searchResponseOptionals = {};\n    var facets = searchResponse.facetsDistribution;\n    var pagination = searchContext.pagination;\n    var exhaustiveFacetsCount = searchResponse === null || searchResponse === void 0 ? void 0 : searchResponse.exhaustiveFacetsCount;\n    if (exhaustiveFacetsCount) {\n        searchResponseOptionals.exhaustiveFacetsCount = exhaustiveFacetsCount;\n    }\n    var nbPages = ceiledDivision(searchResponse.hits.length, pagination.hitsPerPage);\n    var hits = adaptHits(searchResponse.hits, searchContext, pagination);\n    var exhaustiveNbHits = searchResponse.exhaustiveNbHits;\n    var nbHits = searchResponse.nbHits;\n    var processingTimeMs = searchResponse.processingTimeMs;\n    var query = searchResponse.query;\n    var hitsPerPage = pagination.hitsPerPage, page = pagination.page;\n    // Create response object compliant with InstantSearch\n    var adaptedSearchResponse = __assign({\n        index: searchContext.indexUid,\n        hitsPerPage: hitsPerPage,\n        page: page,\n        facets: facets,\n        nbPages: nbPages,\n        exhaustiveNbHits: exhaustiveNbHits,\n        nbHits: nbHits,\n        processingTimeMS: processingTimeMs,\n        query: query,\n        hits: hits,\n        params: \"\"\n    }, searchResponseOptionals);\n    return {\n        results: [\n            adaptedSearchResponse\n        ]\n    };\n}\n/**\r\n * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n * @param  {Context} options\r\n * @returns {SearchContext}\r\n */ function createPaginationContext(_a) {\n    var paginationTotalHits = _a.paginationTotalHits, hitsPerPage = _a.hitsPerPage, page = _a.page;\n    return {\n        paginationTotalHits: paginationTotalHits != null ? paginationTotalHits : 200,\n        hitsPerPage: hitsPerPage === undefined ? 20 : hitsPerPage,\n        page: page || 0\n    };\n}\n/**\r\n * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n * @param  {Context} options\r\n * @returns {SearchContext}\r\n */ function createSearchContext(searchRequest, options, defaultFacetDistribution) {\n    // Split index name and possible sorting rules\n    var _a = searchRequest.indexName.split(\":\"), indexUid = _a[0], sortByArray = _a.slice(1);\n    var instantSearchParams = searchRequest.params;\n    var pagination = createPaginationContext({\n        paginationTotalHits: options.paginationTotalHits,\n        hitsPerPage: instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.hitsPerPage,\n        page: instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.page\n    });\n    var searchContext = __assign(__assign(__assign({}, options), instantSearchParams), {\n        sort: sortByArray.join(\":\") || \"\",\n        indexUid: indexUid,\n        pagination: pagination,\n        defaultFacetDistribution: defaultFacetDistribution,\n        placeholderSearch: options.placeholderSearch !== false,\n        keepZeroFacets: !!options.keepZeroFacets,\n        finitePagination: !!options.finitePagination\n    });\n    return searchContext;\n}\n/**\r\n * @param  {Record<string} cache\r\n * @returns {SearchCache}\r\n */ function SearchCache(cache) {\n    if (cache === void 0) {\n        cache = {};\n    }\n    var searchCache = cache;\n    return {\n        getEntry: function(key) {\n            if (searchCache[key]) {\n                try {\n                    return JSON.parse(searchCache[key]);\n                } catch (_) {\n                    return searchCache[key];\n                }\n            }\n            return undefined;\n        },\n        formatKey: function(components) {\n            return stringifyArray(components);\n        },\n        setEntry: function(key, searchResponse) {\n            searchCache[key] = JSON.stringify(searchResponse);\n        }\n    };\n}\nfunction cacheFirstFacetsDistribution(defaultFacetDistribution, searchResponse) {\n    if (searchResponse.query === \"\" && Object.keys(defaultFacetDistribution).length === 0) {\n        return searchResponse.facetsDistribution;\n    }\n    return defaultFacetDistribution;\n}\n/**\r\n * Instanciate SearchClient required by instantsearch.js.\r\n *\r\n * @param  {string} hostUrl\r\n * @param  {string} apiKey\r\n * @param  {InstantMeiliSearchOptions={}} meiliSearchOptions\r\n * @returns {InstantMeiliSearchInstance}\r\n */ function instantMeiliSearch(hostUrl, apiKey, instantMeiliSearchOptions) {\n    if (apiKey === void 0) {\n        apiKey = \"\";\n    }\n    if (instantMeiliSearchOptions === void 0) {\n        instantMeiliSearchOptions = {};\n    }\n    // create search resolver with included cache\n    var searchResolver = SearchResolver(SearchCache());\n    // paginationTotalHits can be 0 as it is a valid number\n    var defaultFacetDistribution = {};\n    var meilisearchClient = new meilisearch__WEBPACK_IMPORTED_MODULE_0__.MeiliSearch({\n        host: hostUrl,\n        apiKey: apiKey\n    });\n    return {\n        /**\r\n         * @param  {readonlyAlgoliaMultipleQueriesQuery[]} instantSearchRequests\r\n         * @returns {Array}\r\n         */ search: function(instantSearchRequests) {\n            return __awaiter(this, void 0, void 0, function() {\n                var searchRequest, searchContext, adaptedSearchRequest, searchResponse, adaptedSearchResponse, e_1;\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            _a.trys.push([\n                                0,\n                                2,\n                                ,\n                                3\n                            ]);\n                            searchRequest = instantSearchRequests[0];\n                            searchContext = createSearchContext(searchRequest, instantMeiliSearchOptions, defaultFacetDistribution);\n                            adaptedSearchRequest = adaptSearchParams(searchContext);\n                            return [\n                                4 /*yield*/ ,\n                                searchResolver.searchResponse(searchContext, adaptedSearchRequest, meilisearchClient)\n                            ];\n                        case 1:\n                            searchResponse = _a.sent();\n                            // Cache first facets distribution of the instantMeilisearch instance\n                            // Needed to add in the facetsDistribution the fields that were not returned\n                            // When the user sets `keepZeroFacets` to true.\n                            defaultFacetDistribution = cacheFirstFacetsDistribution(defaultFacetDistribution, searchResponse);\n                            adaptedSearchResponse = adaptSearchResponse(searchResponse, searchContext);\n                            return [\n                                2 /*return*/ ,\n                                adaptedSearchResponse\n                            ];\n                        case 2:\n                            e_1 = _a.sent();\n                            console.error(e_1);\n                            throw new Error(e_1);\n                        case 3:\n                            return [\n                                2 /*return*/ \n                            ];\n                    }\n                });\n            });\n        },\n        searchForFacetValues: function(_) {\n            return __awaiter(this, void 0, void 0, function() {\n                return __generator(this, function(_a) {\n                    switch(_a.label){\n                        case 0:\n                            return [\n                                4 /*yield*/ ,\n                                new Promise(function(resolve, reject) {\n                                    reject(new Error(\"SearchForFacetValues is not compatible with Meilisearch\"));\n                                    resolve([]); // added here to avoid compilation error\n                                })\n                            ];\n                        case 1:\n                            return [\n                                2 /*return*/ ,\n                                _a.sent()\n                            ];\n                    }\n                });\n            });\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvZGlzdC9pbnN0YW50LW1laWxpc2VhcmNoLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUUxQzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsSUFBSUMsV0FBVztJQUNYQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBU0YsU0FBU0csQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJSSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFDaEY7UUFDQSxPQUFPTjtJQUNYO0lBQ0EsT0FBT0gsU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRU47QUFDaEM7QUFFQSxTQUFTTyxPQUFPVixDQUFDLEVBQUVXLENBQUM7SUFDaEIsSUFBSVosSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJTSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLE1BQU1NLEVBQUVDLE9BQU8sQ0FBQ1AsS0FBSyxHQUM5RU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUNmLElBQUlMLEtBQUssUUFBUSxPQUFPSCxPQUFPZ0IscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJWixJQUFJLEdBQUdJLElBQUlSLE9BQU9nQixxQkFBcUIsQ0FBQ2IsSUFBSUMsSUFBSUksRUFBRUQsTUFBTSxFQUFFSCxJQUFLO1FBQ3BFLElBQUlVLEVBQUVDLE9BQU8sQ0FBQ1AsQ0FBQyxDQUFDSixFQUFFLElBQUks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QUFJc0wsZUFBZWxLLGNBQWMsQ0FBQ3BCLGVBQWUwTCxzQkFBc0JIOzZCQUl2Rjt3QkFDTCxLQUFLOzRCQUNEbkssaUJBQWlCNUIsR0FBR3hELElBQUk7NEJBQ3hCLHFFQUFxRTs0QkFDckUsNEVBQTRFOzRCQUM1RSwrQ0FBK0M7NEJBQy9DbUUsMkJBQTJCOEssNkJBQTZCOUssMEJBQTBCaUI7NEJBQ2xGNkksd0JBQXdCSixvQkFBb0J6SSxnQkFBZ0JwQjs0QkFDNUQsT0FBTztnQ0FBQyxFQUFFLFFBQVE7Z0NBQUlpSzs2QkFBc0I7d0JBQ2hELEtBQUs7NEJBQ0QwQixNQUFNbk0sR0FBR3hELElBQUk7NEJBQ2I4SixRQUFROEYsS0FBSyxDQUFDRDs0QkFDZCxNQUFNLElBQUlFLE1BQU1GO3dCQUNwQixLQUFLOzRCQUFHLE9BQU87Z0NBQUMsRUFBRSxRQUFROzZCQUFHO29CQUNqQztnQkFDSjtZQUNKO1FBQ0o7UUFDQUcsc0JBQXNCLFNBQVVoUSxDQUFDO1lBQzdCLE9BQU9uQixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO2dCQUNuQyxPQUFPaUIsWUFBWSxJQUFJLEVBQUUsU0FBVTRELEVBQUU7b0JBQ2pDLE9BQVFBLEdBQUd6RCxLQUFLO3dCQUNaLEtBQUs7NEJBQUcsT0FBTztnQ0FBQyxFQUFFLE9BQU87Z0NBQUksSUFBSVosUUFBUSxTQUFVRCxPQUFPLEVBQUVFLE1BQU07b0NBQzFEQSxPQUFPLElBQUl5USxNQUFNO29DQUNqQjNRLFFBQVEsRUFBRSxHQUFHLHdDQUF3QztnQ0FDekQ7NkJBQUc7d0JBQ1AsS0FBSzs0QkFBRyxPQUFPO2dDQUFDLEVBQUUsUUFBUTtnQ0FBSXNFLEdBQUd4RCxJQUFJOzZCQUFHO29CQUM1QztnQkFDSjtZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWVkdXNhLW5leHQvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvZGlzdC9pbnN0YW50LW1laWxpc2VhcmNoLmVzbS5qcz9kMzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1laWxpU2VhcmNoIH0gZnJvbSAnbWVpbGlzZWFyY2gnO1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGZyb20ubGVuZ3RoLCBqID0gdG8ubGVuZ3RoOyBpIDwgaWw7IGkrKywgaisrKVxyXG4gICAgICAgIHRvW2pdID0gZnJvbVtpXTtcclxuICAgIHJldHVybiB0bztcclxufVxuXG52YXIgcmVtb3ZlVW5kZWZpbmVkID0gZnVuY3Rpb24gKGFycikge1xyXG4gICAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IHVuZGVmaW5lZDsgfSk7XHJcbn07XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHthbnl9IHN0clxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbHRlclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gcmVwbGFjZUNvbG9uQnlFcXVhbFNpZ24oZmlsdGVyKSB7XHJcbiAgICAvLyB3aWxsIG9ubHkgY2hhbmdlIGZpcnN0IG9jY3VyZW5jZSBvZiBgOmBcclxuICAgIHJldHVybiBmaWx0ZXIucmVwbGFjZSgvOiguKikvaSwgJz1cIiQxXCInKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtICB7YW55W119IGFyclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkoYXJyKSB7XHJcbiAgICByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIChhY2MgKz0gSlNPTi5zdHJpbmdpZnkoY3VycikpO1xyXG4gICAgfSwgJycpO1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRpdmlkZW5kXHJcbiAqIEBwYXJhbSAge251bWJlcn0gZGl2aXNvclxyXG4gKiBAcmV0dXJucyBudW1iZXJcclxuICovXHJcbmZ1bmN0aW9uIGNlaWxlZERpdmlzaW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XHJcbiAgICBpZiAoZGl2aXNvciA+IDApIHtcclxuICAgICAgICB2YXIgTnVtYmVyUGFnZXMgPSBNYXRoLmNlaWwoZGl2aWRlbmQgLyBkaXZpc29yKTsgLy8gdG90YWwgbnVtYmVyIG9mIHBhZ2VzIHJvdW5kZWQgdXAgdG8gdGhlIG5leHQgbGFyZ2VzdCBpbnRlZ2VyLlxyXG4gICAgICAgIHJldHVybiBOdW1iZXJQYWdlcztcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XG5cbmZ1bmN0aW9uIGlzUHVyZU9iamVjdChkYXRhKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGRhdGEpICYmIGRhdGEgIT09IG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsdGVyXHJcbiAqL1xyXG52YXIgYWRhcHRGaWx0ZXJTeW50YXggPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICB2YXIgbWF0Y2hlcyA9IGZpbHRlci5tYXRjaCgvKFtePV0qKT1cIj8oW15cXFxcXCJdKilcIj8kLyk7XHJcbiAgICBpZiAobWF0Y2hlcykge1xyXG4gICAgICAgIG1hdGNoZXNbMF07IHZhciBmaWx0ZXJOYW1lID0gbWF0Y2hlc1sxXSwgdmFsdWUgPSBtYXRjaGVzWzJdO1xyXG4gICAgICAgIHJldHVybiBbeyBmaWx0ZXJOYW1lOiBmaWx0ZXJOYW1lLCB2YWx1ZTogdmFsdWUgfV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn07XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlcnM/XHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RGaWx0ZXJzKGZpbHRlcnMpIHtcclxuICAgIGlmICh0eXBlb2YgZmlsdGVycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gYWRhcHRGaWx0ZXJTeW50YXgoZmlsdGVycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobmVzdGVkRmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5lc3RlZEZpbHRlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXN0ZWRGaWx0ZXIubWFwKGZ1bmN0aW9uIChmaWx0ZXIpIHsgcmV0dXJuIGFkYXB0RmlsdGVyU3ludGF4KGZpbHRlcik7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdEZpbHRlclN5bnRheChuZXN0ZWRGaWx0ZXIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5mbGF0KDIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtdO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlcnM/XHJcbiAqIEByZXR1cm5zIHtGYWNldHNDYWNoZX1cclxuICovXHJcbmZ1bmN0aW9uIGdldEZhY2V0c0Zyb21GaWx0ZXIoZmlsdGVycykge1xyXG4gICAgdmFyIGV4dHJhY3RlZEZpbHRlcnMgPSBleHRyYWN0RmlsdGVycyhmaWx0ZXJzKTtcclxuICAgIHZhciBjbGVhbkZpbHRlcnMgPSByZW1vdmVVbmRlZmluZWQoZXh0cmFjdGVkRmlsdGVycyk7XHJcbiAgICByZXR1cm4gY2xlYW5GaWx0ZXJzLnJlZHVjZShmdW5jdGlvbiAoY2FjaGUsIHBhcnNlZEZpbHRlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgZmlsdGVyTmFtZSA9IHBhcnNlZEZpbHRlci5maWx0ZXJOYW1lLCB2YWx1ZSA9IHBhcnNlZEZpbHRlci52YWx1ZTtcclxuICAgICAgICB2YXIgcHJldkZpZWxkcyA9IGNhY2hlW2ZpbHRlck5hbWVdIHx8IFtdO1xyXG4gICAgICAgIGNhY2hlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGNhY2hlKSwgKF9hID0ge30sIF9hW2ZpbHRlck5hbWVdID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2RmllbGRzLCB0cnVlKSwgW3ZhbHVlXSksIF9hKSk7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgfSwge30pO1xyXG59XHJcbmZ1bmN0aW9uIGdldEZhY2V0c0Zyb21EZWZhdWx0RGlzdHJpYnV0aW9uKGZhY2V0c0Rpc3RyaWJ1dGlvbikge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGZhY2V0c0Rpc3RyaWJ1dGlvbikucmVkdWNlKGZ1bmN0aW9uIChjYWNoZSwgZmFjZXQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIGZhY2V0VmFsdWVzID0gT2JqZWN0LmtleXMoZmFjZXRzRGlzdHJpYnV0aW9uW2ZhY2V0XSk7XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjYWNoZSksIChfYSA9IHt9LCBfYVtmYWNldF0gPSBmYWNldFZhbHVlcywgX2EpKTtcclxuICAgIH0sIHt9KTtcclxufVxyXG4vKipcclxuICogQHBhcmFtICB7RmlsdGVyfSBmaWx0ZXJzP1xyXG4gKiBAcmV0dXJucyB7RmFjZXRzQ2FjaGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0RmFjZXRzKHNlYXJjaENvbnRleHQsIHNlYXJjaFBhcmFtcykge1xyXG4gICAgaWYgKHNlYXJjaENvbnRleHQua2VlcFplcm9GYWNldHMpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RmFjZXRzRnJvbURlZmF1bHREaXN0cmlidXRpb24oc2VhcmNoQ29udGV4dC5kZWZhdWx0RmFjZXREaXN0cmlidXRpb24pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEZhY2V0c0Zyb21GaWx0ZXIoc2VhcmNoUGFyYW1zID09PSBudWxsIHx8IHNlYXJjaFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoUGFyYW1zLmZpbHRlcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFzc2lnbiBtaXNzaW5nIGZpbHRlcnMgdG8gZmFjZXRzRGlzdHJpYnV0aW9uLlxyXG4gKiBBbGwgZmFjZXQgcGFzc2VkIGFzIGZpbHRlciBzaG91bGQgYXBwZWFyIGluIHRoZSBmYWNldHNEaXN0cmlidXRpb24uXHJcbiAqIElmIG5vdCBwcmVzZW50LCB0aGUgZmFjZXQgaXMgYWRkZWQgd2l0aCAwIGFzIHZhbHVlLlxyXG4gKlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtGYWNldHNDYWNoZX0gY2FjaGU/XHJcbiAqIEBwYXJhbSAge0ZhY2V0c0Rpc3RyaWJ1dGlvbn0gZGlzdHJpYnV0aW9uP1xyXG4gKiBAcmV0dXJucyB7RmFjZXRzRGlzdHJpYnV0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gYWRkTWlzc2luZ0ZhY2V0cyhjYWNoZWRGYWNldHMsIGRpc3RyaWJ1dGlvbikge1xyXG4gICAgZGlzdHJpYnV0aW9uID0gZGlzdHJpYnV0aW9uIHx8IHt9O1xyXG4gICAgLy8gSWYgY2FjaGVkRmFjZXRzIGNvbnRhaW5zIHNvbWV0aGluZ1xyXG4gICAgaWYgKGNhY2hlZEZhY2V0cyAmJiBPYmplY3Qua2V5cyhjYWNoZWRGYWNldHMpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyBmb3IgYWxsIGZpbHRlcnMgaW4gY2FjaGVkIGZpbHRlcnNcclxuICAgICAgICBmb3IgKHZhciBjYWNoZWRGYWNldCBpbiBjYWNoZWRGYWNldHMpIHtcclxuICAgICAgICAgICAgLy8gaWYgZmFjZXQgZG9lcyBub3QgZXhpc3Qgb24gcmV0dXJuZWQgZGlzdHJpYnV0aW9uLCBhZGQgYW4gZW1wdHkgb2JqZWN0XHJcbiAgICAgICAgICAgIGlmICghZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XSlcclxuICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGlvbltjYWNoZWRGYWNldF0gPSB7fTtcclxuICAgICAgICAgICAgLy8gZm9yIGFsbCBmaWVsZHMgaW4gZXZlcnkgZmlsdGVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjYWNoZWRGYWNldHNbY2FjaGVkRmFjZXRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZEZpZWxkID0gX2FbX2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoZSByZXR1cm5lZCBkaXN0cmlidXRpb25cclxuICAgICAgICAgICAgICAgIC8vIHNldCBpdCBhdCAwXHJcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGRpc3RyaWJ1dGlvbltjYWNoZWRGYWNldF0pLmluY2x1ZGVzKGNhY2hlZEZpZWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCAwIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdHJpYnV0aW9uW2NhY2hlZEZhY2V0XVtjYWNoZWRGaWVsZF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpc3RyaWJ1dGlvbjtcclxufVxuXG52YXIgZW1wdHlTZWFyY2ggPSB7XHJcbiAgICBoaXRzOiBbXSxcclxuICAgIHF1ZXJ5OiAnJyxcclxuICAgIGZhY2V0c0Rpc3RyaWJ1dGlvbjoge30sXHJcbiAgICBsaW1pdDogMCxcclxuICAgIG9mZnNldDogMCxcclxuICAgIGV4aGF1c3RpdmVOYkhpdHM6IGZhbHNlLFxyXG4gICAgbmJIaXRzOiAwLFxyXG4gICAgcHJvY2Vzc2luZ1RpbWVNczogMFxyXG59O1xyXG4vKipcclxuICogQHBhcmFtICB7UmVzcG9uc2VDYWNoZXJ9IGNhY2hlXHJcbiAqL1xyXG5mdW5jdGlvbiBTZWFyY2hSZXNvbHZlcihjYWNoZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtICB7TWVpbGlTZWFyY2hQYXJhbXN9IHNlYXJjaFBhcmFtc1xyXG4gICAgICAgICAqIEBwYXJhbSAge01laWxpU2VhcmNofSBjbGllbnRcclxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWFyY2hSZXNwb25zZTogZnVuY3Rpb24gKHNlYXJjaENvbnRleHQsIHNlYXJjaFBhcmFtcywgY2xpZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlclNlYXJjaCwgcXVlcnksIHBhZ2luYXRpb24sIHBhZ2luYXRpb25DYWNoZSwga2V5LCBjYWNoZWRSZXNwb25zZSwgZmFjZXRzQ2FjaGUsIHNlYXJjaFJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJTZWFyY2ggPSBzZWFyY2hDb250ZXh0LnBsYWNlaG9sZGVyU2VhcmNoLCBxdWVyeSA9IHNlYXJjaENvbnRleHQucXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBxdWVyeSBjYW4gYmU6IGVtcHR5IHN0cmluZywgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGVtIGFyZSBmYWxzeSdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBsYWNlaG9sZGVyU2VhcmNoICYmICFxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBlbXB0eVNlYXJjaF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uID0gc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbkNhY2hlID0gc2VhcmNoQ29udGV4dC5maW5pdGVQYWdpbmF0aW9uID8ge30gOiBwYWdpbmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FjaGUuZm9ybWF0S2V5KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoQ29udGV4dC5pbmRleFVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb25DYWNoZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBjYWNoZS5nZXRFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3BlY2lmaWMgcmVxdWVzdCBpcyBhbHJlYWR5IGNhY2hlZCB3aXRoIGl0cyBhc3NvY2lhdGVkIHNlYXJjaCByZXNwb25zZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkUmVzcG9uc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXRzQ2FjaGUgPSBleHRyYWN0RmFjZXRzKHNlYXJjaENvbnRleHQsIHNlYXJjaFBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4KHNlYXJjaENvbnRleHQuaW5kZXhVaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWFyY2goc2VhcmNoQ29udGV4dC5xdWVyeSwgc2VhcmNoUGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIGZhY2V0cyBiYWNrIGludG8gZmFjZXRzRGlzdHJpYnV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtaXNzaW5nIGZhY2V0cyBiYWNrIGludG8gZmFjZXRzRGlzdHJpYnV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZS5mYWNldHNEaXN0cmlidXRpb24gPSBhZGRNaXNzaW5nRmFjZXRzKGZhY2V0c0NhY2hlLCBzZWFyY2hSZXNwb25zZS5mYWNldHNEaXN0cmlidXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNldEVudHJ5KGtleSwgc2VhcmNoUmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNlYXJjaFJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7bnVtYmVyfSByYWRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIHJhZDJkZWdyKHJhZCkge1xyXG4gICAgcmV0dXJuIChyYWQgKiAxODApIC8gTWF0aC5QSTtcclxufVxyXG4vKipcclxuICogQHBhcmFtICB7bnVtYmVyfSBkZWdyXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBkZWdyMnJhZChkZWdyKSB7XHJcbiAgICByZXR1cm4gKGRlZ3IgKiBNYXRoLlBJKSAvIDE4MDtcclxufVxyXG4vKipcclxuICogQHBhcmFtICB7bnVtYmVyfSBsYXQxXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbG5nMVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDJcclxuICogQHBhcmFtICB7bnVtYmVyfSBsbmcyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiBtaWRkbGVHZW9Qb2ludHMobGF0MSwgbG5nMSwgbGF0MiwgbG5nMikge1xyXG4gICAgLy8gY29udmVydCB0byByYWRpYW5zXHJcbiAgICBsYXQxID0gZGVncjJyYWQobGF0MSk7XHJcbiAgICBsbmcxID0gZGVncjJyYWQobG5nMSk7XHJcbiAgICB2YXIgeDEgPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxuZzEpO1xyXG4gICAgdmFyIHkxID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsbmcxKTtcclxuICAgIHZhciB6MSA9IE1hdGguc2luKGxhdDEpO1xyXG4gICAgLy8gY29udmVydCB0byByYWRpYW5zXHJcbiAgICBsYXQyID0gZGVncjJyYWQobGF0Mik7XHJcbiAgICBsbmcyID0gZGVncjJyYWQobG5nMik7XHJcbiAgICB2YXIgeDIgPSBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxuZzIpO1xyXG4gICAgdmFyIHkyID0gTWF0aC5jb3MobGF0MikgKiBNYXRoLnNpbihsbmcyKTtcclxuICAgIHZhciB6MiA9IE1hdGguc2luKGxhdDIpO1xyXG4gICAgdmFyIHggPSB4MSArIHgyO1xyXG4gICAgdmFyIHkgPSB5MSArIHkyO1xyXG4gICAgdmFyIHogPSB6MSArIHoyO1xyXG4gICAgdmFyIEh5cCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcclxuICAgIHZhciBsbmczID0gTWF0aC5hdGFuMih5LCB4KTtcclxuICAgIHZhciBsYXQzID0gTWF0aC5hdGFuMih6LCBIeXApO1xyXG4gICAgaWYgKGxuZzEgPCBsbmcyIHx8IChsbmcxID4gbG5nMiAmJiBsbmcxID4gTWF0aC5QSSAmJiBsbmcyIDwgLU1hdGguUEkpKSB7XHJcbiAgICAgICAgbGF0MyA9IGxhdDMgKyBNYXRoLlBJO1xyXG4gICAgICAgIGxuZzMgPSBsbmczICsgTWF0aC5QSTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhdDMgPSByYWQyZGVncihsYXQzKTtcclxuICAgICAgICBsbmczID0gcmFkMmRlZ3IobG5nMyk7XHJcbiAgICB9XHJcbiAgICBpZiAoTWF0aC5hYnMoeCkgPCBNYXRoLnBvdygxMCwgLTkpICYmXHJcbiAgICAgICAgTWF0aC5hYnMoeSkgPCBNYXRoLnBvdygxMCwgLTkpICYmXHJcbiAgICAgICAgTWF0aC5hYnMoeikgPCBNYXRoLnBvdygxMCwgLTkpKSB7XHJcbiAgICAgICAgbGF0MyA9IDA7XHJcbiAgICAgICAgbG5nMyA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJcIi5jb25jYXQobGF0MywgXCIsXCIpLmNvbmNhdChsbmczKTtcclxufVxyXG4vKipcclxuICogQHBhcmFtICB7bnVtYmVyfSBsYXQxXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbG5nMVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxhdDJcclxuICogQHBhcmFtICB7bnVtYmVyfSBsbmcyXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREaXN0YW5jZUluTWV0ZXIobGF0MSwgbG5nMSwgbGF0MiwgbG5nMikge1xyXG4gICAgLy8gSGF2ZXJzaW5lIEFsZ29yaXRobVxyXG4gICAgdmFyIFIgPSA2MzcxZTM7IC8vIG1ldHJlc1xyXG4gICAgdmFyIGxhdFJhZDEgPSAobGF0MSAqIE1hdGguUEkpIC8gMTgwO1xyXG4gICAgdmFyIGxhdFJhZDIgPSAobGF0MiAqIE1hdGguUEkpIC8gMTgwO1xyXG4gICAgdmFyIGxhdENlbnRlclJhZCA9ICgobGF0MiAtIGxhdDEpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICB2YXIgbG5nQ2VudGVyUmFkID0gKChsbmcyIC0gbG5nMSkgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgIHZhciBhID0gTWF0aC5zaW4obGF0Q2VudGVyUmFkIC8gMikgKiBNYXRoLnNpbihsYXRDZW50ZXJSYWQgLyAyKSArXHJcbiAgICAgICAgTWF0aC5jb3MobGF0UmFkMSkgKlxyXG4gICAgICAgICAgICBNYXRoLmNvcyhsYXRSYWQyKSAqXHJcbiAgICAgICAgICAgIE1hdGguc2luKGxuZ0NlbnRlclJhZCAvIDIpICpcclxuICAgICAgICAgICAgTWF0aC5zaW4obG5nQ2VudGVyUmFkIC8gMik7XHJcbiAgICB2YXIgYmVhcmluZyA9IDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSk7XHJcbiAgICB2YXIgZGlzdGFuY2UgPSBSICogYmVhcmluZzsgLy8gaW4gbWV0cmVzXHJcbiAgICByZXR1cm4gZGlzdGFuY2U7XHJcbn1cblxuZnVuY3Rpb24gYWRhcHRHZW9Qb2ludHNSdWxlcyhnZW9TZWFyY2hDb250ZXh0KSB7XHJcbiAgICBpZiAoIWdlb1NlYXJjaENvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgdmFyIGluc2lkZUJvdW5kaW5nQm94ID0gZ2VvU2VhcmNoQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCwgYXJvdW5kTGF0TG5nID0gZ2VvU2VhcmNoQ29udGV4dC5hcm91bmRMYXRMbmcsIGFyb3VuZFJhZGl1cyA9IGdlb1NlYXJjaENvbnRleHQuYXJvdW5kUmFkaXVzLCBtaW5pbXVtQXJvdW5kUmFkaXVzID0gZ2VvU2VhcmNoQ29udGV4dC5taW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgdmFyIG1pZGRsZVBvaW50O1xyXG4gICAgdmFyIHJhZGl1cztcclxuICAgIGlmIChhcm91bmRMYXRMbmcpIHtcclxuICAgICAgICBtaWRkbGVQb2ludCA9IGFyb3VuZExhdExuZztcclxuICAgIH1cclxuICAgIGlmIChhcm91bmRSYWRpdXMgIT0gbnVsbCB8fCBtaW5pbXVtQXJvdW5kUmFkaXVzICE9IG51bGwpIHtcclxuICAgICAgICBpZiAoYXJvdW5kUmFkaXVzICE9IG51bGwpXHJcbiAgICAgICAgICAgIHJhZGl1cyA9IGFyb3VuZFJhZGl1cztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJhZGl1cyA9IG1pbmltdW1Bcm91bmRSYWRpdXM7XHJcbiAgICB9XHJcbiAgICAvLyBJZiBpbnNpZGVCb3VuZGluZ0JveCBpcyBwcm92aWRlZCBpdCB0YWtlcyBwcmVjZWRlbnQgb3ZlciBhbGwgb3RoZXIgb3B0aW9uc1xyXG4gICAgaWYgKGluc2lkZUJvdW5kaW5nQm94ICYmIHR5cGVvZiBpbnNpZGVCb3VuZGluZ0JveCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgX2EgPSBpbnNpZGVCb3VuZGluZ0JveC5zcGxpdCgnLCcpLCBsYXQxUmF3ID0gX2FbMF0sIGxuZzFSYXcgPSBfYVsxXSwgbGF0MlJhdyA9IF9hWzJdLCBsbmcyUmF3ID0gX2FbM107XHJcbiAgICAgICAgdmFyIF9iID0gW1xyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxhdDFSYXcpLFxyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxuZzFSYXcpLFxyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxhdDJSYXcpLFxyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KGxuZzJSYXcpLFxyXG4gICAgICAgIF0sIGxhdDEgPSBfYlswXSwgbG5nMSA9IF9iWzFdLCBsYXQyID0gX2JbMl0sIGxuZzIgPSBfYlszXTtcclxuICAgICAgICByYWRpdXMgPSBnZXREaXN0YW5jZUluTWV0ZXIobGF0MSwgbG5nMSwgbGF0MiwgbG5nMikgLyAyO1xyXG4gICAgICAgIG1pZGRsZVBvaW50ID0gbWlkZGxlR2VvUG9pbnRzKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pZGRsZVBvaW50ICE9IG51bGwgJiYgcmFkaXVzICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgX2MgPSBtaWRkbGVQb2ludC5zcGxpdCgnLCcpLCBsYXQzID0gX2NbMF0sIGxuZzMgPSBfY1sxXTtcclxuICAgICAgICBsYXQzID0gTnVtYmVyLnBhcnNlRmxvYXQobGF0MykudG9GaXhlZCg1KTtcclxuICAgICAgICBsbmczID0gTnVtYmVyLnBhcnNlRmxvYXQobG5nMykudG9GaXhlZCg1KTtcclxuICAgICAgICB2YXIgZmlsdGVyID0gXCJfZ2VvUmFkaXVzKFwiLmNvbmNhdChsYXQzLCBcIiwgXCIpLmNvbmNhdChsbmczLCBcIiwgXCIpLmNvbmNhdChyYWRpdXMsIFwiKVwiKTtcclxuICAgICAgICByZXR1cm4geyBmaWx0ZXI6IGZpbHRlciB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVHZW9TZWFyY2hDb250ZXh0KHNlYXJjaENvbnRleHQpIHtcclxuICAgIHZhciBnZW9Db250ZXh0ID0ge307XHJcbiAgICB2YXIgYXJvdW5kTGF0TG5nID0gc2VhcmNoQ29udGV4dC5hcm91bmRMYXRMbmcsIGFyb3VuZExhdExuZ1ZpYUlQID0gc2VhcmNoQ29udGV4dC5hcm91bmRMYXRMbmdWaWFJUCwgYXJvdW5kUmFkaXVzID0gc2VhcmNoQ29udGV4dC5hcm91bmRSYWRpdXMsIGFyb3VuZFByZWNpc2lvbiA9IHNlYXJjaENvbnRleHQuYXJvdW5kUHJlY2lzaW9uLCBtaW5pbXVtQXJvdW5kUmFkaXVzID0gc2VhcmNoQ29udGV4dC5taW5pbXVtQXJvdW5kUmFkaXVzLCBpbnNpZGVCb3VuZGluZ0JveCA9IHNlYXJjaENvbnRleHQuaW5zaWRlQm91bmRpbmdCb3gsIGluc2lkZVBvbHlnb24gPSBzZWFyY2hDb250ZXh0Lmluc2lkZVBvbHlnb247XHJcbiAgICBpZiAoYXJvdW5kTGF0TG5nKSB7XHJcbiAgICAgICAgZ2VvQ29udGV4dC5hcm91bmRMYXRMbmcgPSBhcm91bmRMYXRMbmc7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJvdW5kTGF0TG5nVmlhSVApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ2luc3RhbnQtbWVpbGlzZWFyY2g6IGBhcm91bmRMYXRMbmdWaWFJUGAgaXMgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgIH1cclxuICAgIGlmIChhcm91bmRSYWRpdXMpIHtcclxuICAgICAgICBnZW9Db250ZXh0LmFyb3VuZFJhZGl1cyA9IGFyb3VuZFJhZGl1cztcclxuICAgIH1cclxuICAgIGlmIChhcm91bmRQcmVjaXNpb24pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJpbnN0YW50LW1laWxpc2VhcmNoOiBgYXJvdW5kUHJlY2lzaW9uYCBpcyBub3Qgc3VwcG9ydGVkLlxcbiAgICBTZWUgdGhpcyBkaXNjdXNzaW9uIHRvIHRyYWNrIGl0cyBpbXBsZW1lbnRhdGlvbiBodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2gvcHJvZHVjdC9kaXNjdXNzaW9ucy8yNjRcIik7XHJcbiAgICB9XHJcbiAgICBpZiAobWluaW11bUFyb3VuZFJhZGl1cykge1xyXG4gICAgICAgIGdlb0NvbnRleHQubWluaW11bUFyb3VuZFJhZGl1cyA9IG1pbmltdW1Bcm91bmRSYWRpdXM7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5zaWRlQm91bmRpbmdCb3gpIHtcclxuICAgICAgICBnZW9Db250ZXh0Lmluc2lkZUJvdW5kaW5nQm94ID0gaW5zaWRlQm91bmRpbmdCb3g7XHJcbiAgICB9XHJcbiAgICAvLyBTZWUgcmVsYXRlZCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvaXNzdWVzLzU1NVxyXG4gICAgaWYgKGluc2lkZVBvbHlnb24pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXCJpbnN0YW50LW1laWxpc2VhcmNoOiBgaW5zaWRlUG9seWdvbmAgaXMgbm90IGltcGxlbnRlZCBpbiBpbnN0YW50LW1laWxpc2VhcmNoLlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZW9Db250ZXh0O1xyXG59XG5cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gSW5zdGFudFNlYXJjaCBmaWx0ZXIgdG8gTWVpbGlzZWFyY2ggZmlsdGVyLlxyXG4gKiBDaGFuZ2Ugc2lnbiBmcm9tIGA6YCB0byBgPWAgaW4gbmVzdGVkIGZpbHRlciBvYmplY3QuXHJcbiAqIGV4YW1wbGU6IFtgZ2VucmVzOmNvbWVkeWBdIGJlY29tZXMgW2BnZW5yZXM9Y29tZWR5YF1cclxuICpcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dFsnZmFjZXRGaWx0ZXJzJ119IGZpbHRlcnM/XHJcbiAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1GaWx0ZXIoZmlsdGVycykge1xyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobmVzdGVkRmlsdGVyKSB7IHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihuZXN0ZWRGaWx0ZXIpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW07IH0pO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbTsgfSk7XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgZmlsdGVyIGluIGFuIGFycmF5IGlmIGl0IGlzIGEgc3RyaW5nXHJcbiAqIElmIGZpbHRlciBpcyBhcnJheSwgcmV0dXJuIHdpdGhvdXQgY2hhbmdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlclxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJUb0FycmF5KGZpbHRlcikge1xyXG4gICAgLy8gRmlsdGVyIGlzIGEgc3RyaW5nXHJcbiAgICBpZiAoZmlsdGVyID09PSAnJylcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gW2ZpbHRlcl07XHJcbiAgICAvLyBGaWx0ZXIgaXMgZWl0aGVyIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9yIGFuIGFycmF5IG9mIGFycmF5IG9mIHN0cmluZ3NcclxuICAgIHJldHVybiBmaWx0ZXI7XHJcbn1cclxuLyoqXHJcbiAqIE1lcmdlIGZhY2V0RmlsdGVycywgbnVtZXJpY0ZpbHRlcnMgYW5kIGZpbHRlcnMgdG9nZXRoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gZmFjZXRGaWx0ZXJzXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gbnVtZXJpY0ZpbHRlcnNcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJzXHJcbiAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmFjZXRGaWx0ZXJzLCBudW1lcmljRmlsdGVycywgZmlsdGVycykge1xyXG4gICAgdmFyIGFkYXB0ZWRGaWx0ZXJzID0gZmlsdGVycy50cmltKCk7XHJcbiAgICB2YXIgYWRhcHRlZEZhY2V0RmlsdGVycyA9IGZpbHRlclRvQXJyYXkoZmFjZXRGaWx0ZXJzKTtcclxuICAgIHZhciBhZGFwdGVkTnVtZXJpY0ZpbHRlcnMgPSBmaWx0ZXJUb0FycmF5KG51bWVyaWNGaWx0ZXJzKTtcclxuICAgIHZhciBhZGFwdGVkRmlsdGVyID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFkYXB0ZWRGYWNldEZpbHRlcnMsIHRydWUpLCBhZGFwdGVkTnVtZXJpY0ZpbHRlcnMsIHRydWUpLCBbXHJcbiAgICAgICAgYWRhcHRlZEZpbHRlcnMsXHJcbiAgICBdKTtcclxuICAgIHZhciBjbGVhbmVkRmlsdGVycyA9IGFkYXB0ZWRGaWx0ZXIuZmlsdGVyKGZ1bmN0aW9uIChmaWx0ZXIpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlsdGVyO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY2xlYW5lZEZpbHRlcnM7XHJcbn1cclxuLyoqXHJcbiAqIEFkYXB0IGluc3RhbnRzZWFyY2guanMgZmlsdGVycyB0byBNZWlsaXNlYXJjaCBmaWx0ZXJzIGJ5XHJcbiAqIGNvbWJpbmluZyBhbmQgdHJhbnNmb3JtaW5nIGFsbCBwcm92aWRlZCBmaWx0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd8dW5kZWZpbmVkfSBmaWx0ZXJzXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHRbJ251bWVyaWNGaWx0ZXJzJ119IG51bWVyaWNGaWx0ZXJzXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHRbJ2ZhY2V0RmlsdGVycyddfSBmYWNldEZpbHRlcnNcclxuICogQHJldHVybnMge0ZpbHRlcn1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0RmlsdGVycyhmaWx0ZXJzLCBudW1lcmljRmlsdGVycywgZmFjZXRGaWx0ZXJzKSB7XHJcbiAgICB2YXIgdHJhbnNmb3JtZWRGaWx0ZXIgPSB0cmFuc2Zvcm1GaWx0ZXIoZmFjZXRGaWx0ZXJzIHx8IFtdKTtcclxuICAgIHZhciB0cmFuc2Zvcm1lZE51bWVyaWNGaWx0ZXIgPSB0cmFuc2Zvcm1GaWx0ZXIobnVtZXJpY0ZpbHRlcnMgfHwgW10pO1xyXG4gICAgcmV0dXJuIG1lcmdlRmlsdGVycyh0cmFuc2Zvcm1lZEZpbHRlciwgdHJhbnNmb3JtZWROdW1lcmljRmlsdGVyLCBmaWx0ZXJzIHx8ICcnKTtcclxufVxuXG4vKipcclxuICogQWRhcHQgc2VhcmNoIHJlcXVlc3QgZnJvbSBpbnN0YW50c2VhcmNoLmpzXHJcbiAqIHRvIHNlYXJjaCByZXF1ZXN0IGNvbXBsaWFudCB3aXRoIE1laWxpc2VhcmNoXHJcbiAqXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICogQHJldHVybnMge01laWxpU2VhcmNoUGFyYW1zfVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRTZWFyY2hQYXJhbXMoc2VhcmNoQ29udGV4dCkge1xyXG4gICAgLy8gQ3JlYXRlcyBzZWFyY2ggcGFyYW1zIG9iamVjdCBjb21wbGlhbnQgd2l0aCBNZWlsaXNlYXJjaFxyXG4gICAgdmFyIG1laWxpU2VhcmNoUGFyYW1zID0ge307XHJcbiAgICAvLyBGYWNldHNcclxuICAgIHZhciBmYWNldHMgPSBzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuZmFjZXRzO1xyXG4gICAgaWYgKGZhY2V0cyA9PT0gbnVsbCB8fCBmYWNldHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhY2V0cy5sZW5ndGgpIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5mYWNldHNEaXN0cmlidXRpb24gPSBmYWNldHM7XHJcbiAgICB9XHJcbiAgICAvLyBBdHRyaWJ1dGVzIFRvIENyb3BcclxuICAgIHZhciBhdHRyaWJ1dGVzVG9Dcm9wID0gc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb1NuaXBwZXQ7XHJcbiAgICBpZiAoYXR0cmlidXRlc1RvQ3JvcCkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb0Nyb3AgPSBhdHRyaWJ1dGVzVG9Dcm9wO1xyXG4gICAgfVxyXG4gICAgLy8gQXR0cmlidXRlcyBUbyBDcm9wIG1hcmtlclxyXG4gICAgdmFyIGNyb3BNYXJrZXIgPSBzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuc25pcHBldEVsbGlwc2lzVGV4dDtcclxuICAgIGlmIChjcm9wTWFya2VyICE9IG51bGwpIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5jcm9wTWFya2VyID0gY3JvcE1hcmtlcjtcclxuICAgIH1cclxuICAgIC8vIEF0dHJpYnV0ZXMgVG8gUmV0cmlldmVcclxuICAgIHZhciBhdHRyaWJ1dGVzVG9SZXRyaWV2ZSA9IHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5hdHRyaWJ1dGVzVG9SZXRyaWV2ZTtcclxuICAgIGlmIChhdHRyaWJ1dGVzVG9SZXRyaWV2ZSkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gYXR0cmlidXRlc1RvUmV0cmlldmU7XHJcbiAgICB9XHJcbiAgICAvLyBGaWx0ZXJcclxuICAgIHZhciBmaWx0ZXIgPSBhZGFwdEZpbHRlcnMoc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmZpbHRlcnMsIHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5udW1lcmljRmlsdGVycywgc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmZhY2V0RmlsdGVycyk7XHJcbiAgICBpZiAoZmlsdGVyLmxlbmd0aCkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZpbHRlciA9IGZpbHRlcjtcclxuICAgIH1cclxuICAgIC8vIEF0dHJpYnV0ZXMgVG8gUmV0cmlldmVcclxuICAgIGlmIChhdHRyaWJ1dGVzVG9SZXRyaWV2ZSkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb0Nyb3AgPSBhdHRyaWJ1dGVzVG9SZXRyaWV2ZTtcclxuICAgIH1cclxuICAgIC8vIEF0dHJpYnV0ZXMgVG8gSGlnaGxpZ2h0XHJcbiAgICBtZWlsaVNlYXJjaFBhcmFtcy5hdHRyaWJ1dGVzVG9IaWdobGlnaHQgPSAoc2VhcmNoQ29udGV4dCA9PT0gbnVsbCB8fCBzZWFyY2hDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb0hpZ2hsaWdodCkgfHwgW1xyXG4gICAgICAgICcqJyxcclxuICAgIF07XHJcbiAgICAvLyBIaWdobGlnaHQgcHJlIHRhZ1xyXG4gICAgdmFyIGhpZ2hsaWdodFByZVRhZyA9IHNlYXJjaENvbnRleHQgPT09IG51bGwgfHwgc2VhcmNoQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoQ29udGV4dC5oaWdobGlnaHRQcmVUYWc7XHJcbiAgICBpZiAoaGlnaGxpZ2h0UHJlVGFnKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuaGlnaGxpZ2h0UHJlVGFnID0gaGlnaGxpZ2h0UHJlVGFnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuaGlnaGxpZ2h0UHJlVGFnID0gJ19fYWlzLWhpZ2hsaWdodF9fJztcclxuICAgIH1cclxuICAgIC8vIEhpZ2hsaWdodCBwb3N0IHRhZ1xyXG4gICAgdmFyIGhpZ2hsaWdodFBvc3RUYWcgPSBzZWFyY2hDb250ZXh0ID09PSBudWxsIHx8IHNlYXJjaENvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlYXJjaENvbnRleHQuaGlnaGxpZ2h0UG9zdFRhZztcclxuICAgIGlmIChoaWdobGlnaHRQb3N0VGFnKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuaGlnaGxpZ2h0UG9zdFRhZyA9IGhpZ2hsaWdodFBvc3RUYWc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQb3N0VGFnID0gJ19fL2Fpcy1oaWdobGlnaHRfXyc7XHJcbiAgICB9XHJcbiAgICB2YXIgcGxhY2Vob2xkZXJTZWFyY2ggPSBzZWFyY2hDb250ZXh0LnBsYWNlaG9sZGVyU2VhcmNoO1xyXG4gICAgdmFyIHF1ZXJ5ID0gc2VhcmNoQ29udGV4dC5xdWVyeTtcclxuICAgIC8vIFBhZ2luYXRpb25cclxuICAgIHZhciBwYWdpbmF0aW9uID0gc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uO1xyXG4gICAgLy8gTGltaXQgYmFzZWQgb24gcGFnaW5hdGlvbiBwcmVmZXJlbmNlc1xyXG4gICAgaWYgKCghcGxhY2Vob2xkZXJTZWFyY2ggJiYgcXVlcnkgPT09ICcnKSB8fFxyXG4gICAgICAgIHBhZ2luYXRpb24ucGFnaW5hdGlvblRvdGFsSGl0cyA9PT0gMCkge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmxpbWl0ID0gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlYXJjaENvbnRleHQuZmluaXRlUGFnaW5hdGlvbikge1xyXG4gICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmxpbWl0ID0gcGFnaW5hdGlvbi5wYWdpbmF0aW9uVG90YWxIaXRzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGxpbWl0ID0gKHBhZ2luYXRpb24ucGFnZSArIDEpICogcGFnaW5hdGlvbi5oaXRzUGVyUGFnZSArIDE7XHJcbiAgICAgICAgLy8gSWYgdGhlIGxpbWl0IGlzIGJpZ2dlciB0aGFuIHRoZSB0b3RhbCBoaXRzIGFjY2VwdGVkXHJcbiAgICAgICAgLy8gZm9yY2UgdGhlIGxpbWl0IHRvIHRoYXQgYW1vdW50XHJcbiAgICAgICAgaWYgKGxpbWl0ID4gcGFnaW5hdGlvbi5wYWdpbmF0aW9uVG90YWxIaXRzKSB7XHJcbiAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmxpbWl0ID0gcGFnaW5hdGlvbi5wYWdpbmF0aW9uVG90YWxIaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMubGltaXQgPSBsaW1pdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgc29ydCA9IHNlYXJjaENvbnRleHQuc29ydDtcclxuICAgIC8vIFNvcnRcclxuICAgIGlmIChzb3J0ID09PSBudWxsIHx8IHNvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvcnQubGVuZ3RoKSB7XHJcbiAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuc29ydCA9IFtzb3J0XTtcclxuICAgIH1cclxuICAgIHZhciBnZW9TZWFyY2hDb250ZXh0ID0gY3JlYXRlR2VvU2VhcmNoQ29udGV4dChzZWFyY2hDb250ZXh0KTtcclxuICAgIHZhciBnZW9SdWxlcyA9IGFkYXB0R2VvUG9pbnRzUnVsZXMoZ2VvU2VhcmNoQ29udGV4dCk7XHJcbiAgICBpZiAoZ2VvUnVsZXMgPT09IG51bGwgfHwgZ2VvUnVsZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlb1J1bGVzLmZpbHRlcikge1xyXG4gICAgICAgIGlmIChtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmlsdGVyLnVuc2hpZnQoZ2VvUnVsZXMuZmlsdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZpbHRlciA9IFtnZW9SdWxlcy5maWx0ZXJdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtZWlsaVNlYXJjaFBhcmFtcztcclxufVxuXG4vKipcclxuICogU2xpY2UgdGhlIHJlcXVlc3RlZCBoaXRzIGJhc2VkIG9uIHRoZSBwYWdpbmF0aW9uIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtSZWNvcmQ8c3RyaW5nfSBoaXRzXHJcbiAqIEBwYXJhbSAge251bWJlcn0gcGFnZVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGhpdHNQZXJQYWdlXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0UGFnaW5hdGlvbihoaXRzLCBwYWdlLCBoaXRzUGVyUGFnZSkge1xyXG4gICAgaWYgKGhpdHNQZXJQYWdlIDwgMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIHRvbyBzbWFsbCBmb3IgXCJoaXRzUGVyUGFnZVwiIHBhcmFtZXRlciwgZXhwZWN0ZWQgaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDkyMjMzNzIwMzY4NTQ3NzU4MDcnKTtcclxuICAgIH1cclxuICAgIHZhciBzdGFydCA9IHBhZ2UgKiBoaXRzUGVyUGFnZTtcclxuICAgIHJldHVybiBoaXRzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGhpdHNQZXJQYWdlKTtcclxufVxuXG4vKipcclxuICogU3RyaW5naWZ5IHZhbHVlcyBmb2xsb3dpbmcgaW5zdGFudHNlYXJjaCBwcmFjdGljZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSAge2FueX0gdmFsdWUgLSB2YWx1ZSB0aGF0IG5lZWRzIHRvIGJlIHN0cmluZ2lmaWVkXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBTdHJpbmdcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gdW5kZWZpbmVkXHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjdXJzaWYgZnVuY3Rpb24gd3JhcCB0aGUgZGVlcGVzdCBwb3NzaWJsZSB2YWx1ZVxyXG4gKiB0aGUgZm9sbG93aW5nIHdheTogeyB2YWx1ZTogXCJ4eFwiIH0uXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiB7XHJcbiAqIFwicm9vdEZpZWxkXCI6IHsgXCJ2YWx1ZVwiOiBcInhcIiB9XHJcbiAqIFwibmVzdGVkRmllbGRcIjogeyBjaGlsZDogeyB2YWx1ZTogXCJ5XCIgfSB9XHJcbiAqIH1cclxuICpcclxuICogcmVjdXJzaXZpdHkgY29udGludWVzIHVudGlsIHRoZSB2YWx1ZSBpcyBub3QgYW4gYXJyYXkgb3IgYW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gIHthbnl9IHZhbHVlIC0gdmFsdWUgb2YgYSBmaWVsZFxyXG4gKlxyXG4gKiBAcmV0dXJucyBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbiAqL1xyXG5mdW5jdGlvbiB3cmFwVmFsdWUodmFsdWUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIC8vIEFycmF5XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gd3JhcFZhbHVlKGVsZW0pOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzUHVyZU9iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAvLyBPYmplY3RcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAobmVzdGVkLCBrZXkpIHtcclxuICAgICAgICAgICAgbmVzdGVkW2tleV0gPSB3cmFwVmFsdWUodmFsdWVba2V5XSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXN0ZWQ7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0cmluZ2lmeVZhbHVlKHZhbHVlKSB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGFwdCBNZWlsaXNlYXJjaCBmb3JtYXR0ZWQgZmllbGRzIHRvIGEgZm9ybWF0IGNvbXBsaWFudCB0byBpbnN0YW50c2VhcmNoLmpzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtSZWNvcmQ8c3RyaW5nfSBmb3JtYXR0ZWRIaXRcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gKiBAcmV0dXJucyB7UmVjb3JkfVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRGb3JtYXR0ZWRGaWVsZHMoaGl0KSB7XHJcbiAgICBpZiAoIWhpdClcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB2YXIgX2Zvcm1hdHRlZFJlc3VsdCA9IHdyYXBWYWx1ZShoaXQpO1xyXG4gICAgdmFyIGhpZ2hsaWdodGVkSGl0ID0ge1xyXG4gICAgICAgIC8vIFdlIGNvdWxkIG5vdCBkZXRlcm1pbmUgd2hhdCB0aGUgZGlmZmVyZW5jZXMgYXJlIGJldHdlZW4gdGhvc2UgdHdvIGZpZWxkcy5cclxuICAgICAgICBfaGlnaGxpZ2h0UmVzdWx0OiBfZm9ybWF0dGVkUmVzdWx0LFxyXG4gICAgICAgIF9zbmlwcGV0UmVzdWx0OiBfZm9ybWF0dGVkUmVzdWx0XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhpZ2hsaWdodGVkSGl0O1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHthbnlbXX0gaGl0c1xyXG4gKiBAcmV0dXJucyB7QXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj59XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdEdlb1Jlc3BvbnNlKGhpdHMpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChoaXRzW2ldLl9nZW8pIHtcclxuICAgICAgICAgICAgaGl0c1tpXS5fZ2VvbG9jID0ge1xyXG4gICAgICAgICAgICAgICAgbGF0OiBoaXRzW2ldLl9nZW8ubGF0LFxyXG4gICAgICAgICAgICAgICAgbG5nOiBoaXRzW2ldLl9nZW8ubG5nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhpdHNbaV0ub2JqZWN0SUQgPSBcIlwiLmNvbmNhdChpICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xyXG4gICAgICAgICAgICBkZWxldGUgaGl0c1tpXS5fZ2VvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoaXRzO1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtBcnJheTxSZWNvcmQ8c3RyaW5nfSBoaXRzXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICogQHBhcmFtICB7UGFnaW5hdGlvbkNvbnRleHR9IHBhZ2luYXRpb25Db250ZXh0XHJcbiAqIEByZXR1cm5zIHthbnl9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdEhpdHMoaGl0cywgc2VhcmNoQ29udGV4dCwgcGFnaW5hdGlvbkNvbnRleHQpIHtcclxuICAgIHZhciBwcmltYXJ5S2V5ID0gc2VhcmNoQ29udGV4dC5wcmltYXJ5S2V5O1xyXG4gICAgdmFyIGhpdHNQZXJQYWdlID0gcGFnaW5hdGlvbkNvbnRleHQuaGl0c1BlclBhZ2UsIHBhZ2UgPSBwYWdpbmF0aW9uQ29udGV4dC5wYWdlO1xyXG4gICAgdmFyIHBhZ2luYXRlZEhpdHMgPSBhZGFwdFBhZ2luYXRpb24oaGl0cywgcGFnZSwgaGl0c1BlclBhZ2UpO1xyXG4gICAgdmFyIGFkYXB0ZWRIaXRzID0gcGFnaW5hdGVkSGl0cy5tYXAoZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIENyZWF0ZXMgSGl0IG9iamVjdCBjb21wbGlhbnQgd2l0aCBJbnN0YW50U2VhcmNoXHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGhpdCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkSGl0ID0gaGl0Ll9mb3JtYXR0ZWQ7IGhpdC5fbWF0Y2hlc0luZm87IHZhciBkb2N1bWVudEZpZWxkcyA9IF9fcmVzdChoaXQsIFtcIl9mb3JtYXR0ZWRcIiwgXCJfbWF0Y2hlc0luZm9cIl0pO1xyXG4gICAgICAgICAgICB2YXIgYWRhcHRlZEhpdCA9IE9iamVjdC5hc3NpZ24oZG9jdW1lbnRGaWVsZHMsIGFkYXB0Rm9ybWF0dGVkRmllbGRzKGZvcm1hdHRlZEhpdCkpO1xyXG4gICAgICAgICAgICBpZiAocHJpbWFyeUtleSkge1xyXG4gICAgICAgICAgICAgICAgYWRhcHRlZEhpdC5vYmplY3RJRCA9IGhpdFtwcmltYXJ5S2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlZEhpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgIH0pO1xyXG4gICAgYWRhcHRlZEhpdHMgPSBhZGFwdEdlb1Jlc3BvbnNlKGFkYXB0ZWRIaXRzKTtcclxuICAgIHJldHVybiBhZGFwdGVkSGl0cztcclxufVxuXG4vKipcclxuICogQWRhcHQgc2VhcmNoIHJlc3BvbnNlIGZyb20gTWVpbGlzZWFyY2hcclxuICogdG8gc2VhcmNoIHJlc3BvbnNlIGNvbXBsaWFudCB3aXRoIGluc3RhbnRzZWFyY2guanNcclxuICpcclxuICogQHBhcmFtICB7TWVpbGlTZWFyY2hSZXNwb25zZTxSZWNvcmQ8c3RyaW5nfSBzZWFyY2hSZXNwb25zZVxyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAqIEBwYXJhbSAge1BhZ2luYXRpb25Db250ZXh0fSBwYWdpbmF0aW9uQ29udGV4dFxyXG4gKiBAcmV0dXJucyB7eyByZXN1bHRzOiBBcnJheTxBbGdvbGlhU2VhcmNoUmVzcG9uc2U8VD4+IH19XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdFNlYXJjaFJlc3BvbnNlKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0KSB7XHJcbiAgICB2YXIgc2VhcmNoUmVzcG9uc2VPcHRpb25hbHMgPSB7fTtcclxuICAgIHZhciBmYWNldHMgPSBzZWFyY2hSZXNwb25zZS5mYWNldHNEaXN0cmlidXRpb247XHJcbiAgICB2YXIgcGFnaW5hdGlvbiA9IHNlYXJjaENvbnRleHQucGFnaW5hdGlvbjtcclxuICAgIHZhciBleGhhdXN0aXZlRmFjZXRzQ291bnQgPSBzZWFyY2hSZXNwb25zZSA9PT0gbnVsbCB8fCBzZWFyY2hSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VhcmNoUmVzcG9uc2UuZXhoYXVzdGl2ZUZhY2V0c0NvdW50O1xyXG4gICAgaWYgKGV4aGF1c3RpdmVGYWNldHNDb3VudCkge1xyXG4gICAgICAgIHNlYXJjaFJlc3BvbnNlT3B0aW9uYWxzLmV4aGF1c3RpdmVGYWNldHNDb3VudCA9IGV4aGF1c3RpdmVGYWNldHNDb3VudDtcclxuICAgIH1cclxuICAgIHZhciBuYlBhZ2VzID0gY2VpbGVkRGl2aXNpb24oc2VhcmNoUmVzcG9uc2UuaGl0cy5sZW5ndGgsIHBhZ2luYXRpb24uaGl0c1BlclBhZ2UpO1xyXG4gICAgdmFyIGhpdHMgPSBhZGFwdEhpdHMoc2VhcmNoUmVzcG9uc2UuaGl0cywgc2VhcmNoQ29udGV4dCwgcGFnaW5hdGlvbik7XHJcbiAgICB2YXIgZXhoYXVzdGl2ZU5iSGl0cyA9IHNlYXJjaFJlc3BvbnNlLmV4aGF1c3RpdmVOYkhpdHM7XHJcbiAgICB2YXIgbmJIaXRzID0gc2VhcmNoUmVzcG9uc2UubmJIaXRzO1xyXG4gICAgdmFyIHByb2Nlc3NpbmdUaW1lTXMgPSBzZWFyY2hSZXNwb25zZS5wcm9jZXNzaW5nVGltZU1zO1xyXG4gICAgdmFyIHF1ZXJ5ID0gc2VhcmNoUmVzcG9uc2UucXVlcnk7XHJcbiAgICB2YXIgaGl0c1BlclBhZ2UgPSBwYWdpbmF0aW9uLmhpdHNQZXJQYWdlLCBwYWdlID0gcGFnaW5hdGlvbi5wYWdlO1xyXG4gICAgLy8gQ3JlYXRlIHJlc3BvbnNlIG9iamVjdCBjb21wbGlhbnQgd2l0aCBJbnN0YW50U2VhcmNoXHJcbiAgICB2YXIgYWRhcHRlZFNlYXJjaFJlc3BvbnNlID0gX19hc3NpZ24oeyBpbmRleDogc2VhcmNoQ29udGV4dC5pbmRleFVpZCwgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlLCBwYWdlOiBwYWdlLCBmYWNldHM6IGZhY2V0cywgbmJQYWdlczogbmJQYWdlcywgZXhoYXVzdGl2ZU5iSGl0czogZXhoYXVzdGl2ZU5iSGl0cywgbmJIaXRzOiBuYkhpdHMsIHByb2Nlc3NpbmdUaW1lTVM6IHByb2Nlc3NpbmdUaW1lTXMsIHF1ZXJ5OiBxdWVyeSwgaGl0czogaGl0cywgcGFyYW1zOiAnJyB9LCBzZWFyY2hSZXNwb25zZU9wdGlvbmFscyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlc3VsdHM6IFthZGFwdGVkU2VhcmNoUmVzcG9uc2VdXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtBbGdvbGlhTXVsdGlwbGVRdWVyaWVzUXVlcnl9IHNlYXJjaFJlcXVlc3RcclxuICogQHBhcmFtICB7Q29udGV4dH0gb3B0aW9uc1xyXG4gKiBAcmV0dXJucyB7U2VhcmNoQ29udGV4dH1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVBhZ2luYXRpb25Db250ZXh0KF9hKSB7XHJcbiAgICB2YXIgcGFnaW5hdGlvblRvdGFsSGl0cyA9IF9hLnBhZ2luYXRpb25Ub3RhbEhpdHMsIGhpdHNQZXJQYWdlID0gX2EuaGl0c1BlclBhZ2UsIHBhZ2UgPSBfYS5wYWdlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYWdpbmF0aW9uVG90YWxIaXRzOiBwYWdpbmF0aW9uVG90YWxIaXRzICE9IG51bGwgPyBwYWdpbmF0aW9uVG90YWxIaXRzIDogMjAwLFxyXG4gICAgICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSA9PT0gdW5kZWZpbmVkID8gMjAgOiBoaXRzUGVyUGFnZSxcclxuICAgICAgICBwYWdlOiBwYWdlIHx8IDBcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge0FsZ29saWFNdWx0aXBsZVF1ZXJpZXNRdWVyeX0gc2VhcmNoUmVxdWVzdFxyXG4gKiBAcGFyYW0gIHtDb250ZXh0fSBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtTZWFyY2hDb250ZXh0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoQ29udGV4dChzZWFyY2hSZXF1ZXN0LCBvcHRpb25zLCBkZWZhdWx0RmFjZXREaXN0cmlidXRpb24pIHtcclxuICAgIC8vIFNwbGl0IGluZGV4IG5hbWUgYW5kIHBvc3NpYmxlIHNvcnRpbmcgcnVsZXNcclxuICAgIHZhciBfYSA9IHNlYXJjaFJlcXVlc3QuaW5kZXhOYW1lLnNwbGl0KCc6JyksIGluZGV4VWlkID0gX2FbMF0sIHNvcnRCeUFycmF5ID0gX2Euc2xpY2UoMSk7XHJcbiAgICB2YXIgaW5zdGFudFNlYXJjaFBhcmFtcyA9IHNlYXJjaFJlcXVlc3QucGFyYW1zO1xyXG4gICAgdmFyIHBhZ2luYXRpb24gPSBjcmVhdGVQYWdpbmF0aW9uQ29udGV4dCh7XHJcbiAgICAgICAgcGFnaW5hdGlvblRvdGFsSGl0czogb3B0aW9ucy5wYWdpbmF0aW9uVG90YWxIaXRzLFxyXG4gICAgICAgIGhpdHNQZXJQYWdlOiBpbnN0YW50U2VhcmNoUGFyYW1zID09PSBudWxsIHx8IGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbnRTZWFyY2hQYXJhbXMuaGl0c1BlclBhZ2UsXHJcbiAgICAgICAgcGFnZTogaW5zdGFudFNlYXJjaFBhcmFtcyA9PT0gbnVsbCB8fCBpbnN0YW50U2VhcmNoUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnN0YW50U2VhcmNoUGFyYW1zLnBhZ2VcclxuICAgIH0pO1xyXG4gICAgdmFyIHNlYXJjaENvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIGluc3RhbnRTZWFyY2hQYXJhbXMpLCB7IHNvcnQ6IHNvcnRCeUFycmF5LmpvaW4oJzonKSB8fCAnJywgaW5kZXhVaWQ6IGluZGV4VWlkLCBwYWdpbmF0aW9uOiBwYWdpbmF0aW9uLCBkZWZhdWx0RmFjZXREaXN0cmlidXRpb246IGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbiwgcGxhY2Vob2xkZXJTZWFyY2g6IG9wdGlvbnMucGxhY2Vob2xkZXJTZWFyY2ggIT09IGZhbHNlLCBrZWVwWmVyb0ZhY2V0czogISFvcHRpb25zLmtlZXBaZXJvRmFjZXRzLCBmaW5pdGVQYWdpbmF0aW9uOiAhIW9wdGlvbnMuZmluaXRlUGFnaW5hdGlvbiB9KTtcclxuICAgIHJldHVybiBzZWFyY2hDb250ZXh0O1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtSZWNvcmQ8c3RyaW5nfSBjYWNoZVxyXG4gKiBAcmV0dXJucyB7U2VhcmNoQ2FjaGV9XHJcbiAqL1xyXG5mdW5jdGlvbiBTZWFyY2hDYWNoZShjYWNoZSkge1xyXG4gICAgaWYgKGNhY2hlID09PSB2b2lkIDApIHsgY2FjaGUgPSB7fTsgfVxyXG4gICAgdmFyIHNlYXJjaENhY2hlID0gY2FjaGU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEVudHJ5OiBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hDYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlYXJjaENhY2hlW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoQ2FjaGVba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZm9ybWF0S2V5OiBmdW5jdGlvbiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkoY29tcG9uZW50cyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRFbnRyeTogZnVuY3Rpb24gKGtleSwgc2VhcmNoUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgc2VhcmNoQ2FjaGVba2V5XSA9IEpTT04uc3RyaW5naWZ5KHNlYXJjaFJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNhY2hlRmlyc3RGYWNldHNEaXN0cmlidXRpb24oZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uLCBzZWFyY2hSZXNwb25zZSkge1xyXG4gICAgaWYgKHNlYXJjaFJlc3BvbnNlLnF1ZXJ5ID09PSAnJyAmJlxyXG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaFJlc3BvbnNlLmZhY2V0c0Rpc3RyaWJ1dGlvbjtcclxuICAgIH1cclxuICAgIHJldHVybiBkZWZhdWx0RmFjZXREaXN0cmlidXRpb247XHJcbn1cblxuLyoqXHJcbiAqIEluc3RhbmNpYXRlIFNlYXJjaENsaWVudCByZXF1aXJlZCBieSBpbnN0YW50c2VhcmNoLmpzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGhvc3RVcmxcclxuICogQHBhcmFtICB7c3RyaW5nfSBhcGlLZXlcclxuICogQHBhcmFtICB7SW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucz17fX0gbWVpbGlTZWFyY2hPcHRpb25zXHJcbiAqIEByZXR1cm5zIHtJbnN0YW50TWVpbGlTZWFyY2hJbnN0YW5jZX1cclxuICovXHJcbmZ1bmN0aW9uIGluc3RhbnRNZWlsaVNlYXJjaChob3N0VXJsLCBhcGlLZXksIGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMpIHtcclxuICAgIGlmIChhcGlLZXkgPT09IHZvaWQgMCkgeyBhcGlLZXkgPSAnJzsgfVxyXG4gICAgaWYgKGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zID0ge307IH1cclxuICAgIC8vIGNyZWF0ZSBzZWFyY2ggcmVzb2x2ZXIgd2l0aCBpbmNsdWRlZCBjYWNoZVxyXG4gICAgdmFyIHNlYXJjaFJlc29sdmVyID0gU2VhcmNoUmVzb2x2ZXIoU2VhcmNoQ2FjaGUoKSk7XHJcbiAgICAvLyBwYWdpbmF0aW9uVG90YWxIaXRzIGNhbiBiZSAwIGFzIGl0IGlzIGEgdmFsaWQgbnVtYmVyXHJcbiAgICB2YXIgZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uID0ge307XHJcbiAgICB2YXIgbWVpbGlzZWFyY2hDbGllbnQgPSBuZXcgTWVpbGlTZWFyY2goeyBob3N0OiBob3N0VXJsLCBhcGlLZXk6IGFwaUtleSB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtICB7cmVhZG9ubHlBbGdvbGlhTXVsdGlwbGVRdWVyaWVzUXVlcnlbXX0gaW5zdGFudFNlYXJjaFJlcXVlc3RzXHJcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNlYXJjaDogZnVuY3Rpb24gKGluc3RhbnRTZWFyY2hSZXF1ZXN0cykge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VhcmNoUmVxdWVzdCwgc2VhcmNoQ29udGV4dCwgYWRhcHRlZFNlYXJjaFJlcXVlc3QsIHNlYXJjaFJlc3BvbnNlLCBhZGFwdGVkU2VhcmNoUmVzcG9uc2UsIGVfMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXF1ZXN0ID0gaW5zdGFudFNlYXJjaFJlcXVlc3RzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoQ29udGV4dCA9IGNyZWF0ZVNlYXJjaENvbnRleHQoc2VhcmNoUmVxdWVzdCwgaW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucywgZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0ZWRTZWFyY2hSZXF1ZXN0ID0gYWRhcHRTZWFyY2hQYXJhbXMoc2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZWFyY2hSZXNvbHZlci5zZWFyY2hSZXNwb25zZShzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdCwgbWVpbGlzZWFyY2hDbGllbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgZmlyc3QgZmFjZXRzIGRpc3RyaWJ1dGlvbiBvZiB0aGUgaW5zdGFudE1laWxpc2VhcmNoIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZGVkIHRvIGFkZCBpbiB0aGUgZmFjZXRzRGlzdHJpYnV0aW9uIHRoZSBmaWVsZHMgdGhhdCB3ZXJlIG5vdCByZXR1cm5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHVzZXIgc2V0cyBga2VlcFplcm9GYWNldHNgIHRvIHRydWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGZpcnN0IGZhY2V0cyBkaXN0cmlidXRpb24gb2YgdGhlIGluc3RhbnRNZWlsaXNlYXJjaCBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZGVkIHRvIGFkZCBpbiB0aGUgZmFjZXRzRGlzdHJpYnV0aW9uIHRoZSBmaWVsZHMgdGhhdCB3ZXJlIG5vdCByZXR1cm5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgdXNlciBzZXRzIGBrZWVwWmVyb0ZhY2V0c2AgdG8gdHJ1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbiA9IGNhY2hlRmlyc3RGYWNldHNEaXN0cmlidXRpb24oZGVmYXVsdEZhY2V0RGlzdHJpYnV0aW9uLCBzZWFyY2hSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGFwdGVkU2VhcmNoUmVzcG9uc2UgPSBhZGFwdFNlYXJjaFJlc3BvbnNlKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhZGFwdGVkU2VhcmNoUmVzcG9uc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VhcmNoRm9yRmFjZXRWYWx1ZXM6IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NlYXJjaEZvckZhY2V0VmFsdWVzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggTWVpbGlzZWFyY2gnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7IC8vIGFkZGVkIGhlcmUgdG8gYXZvaWQgY29tcGlsYXRpb24gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5leHBvcnQgeyBpbnN0YW50TWVpbGlTZWFyY2ggfTtcbiJdLCJuYW1lcyI6WyJNZWlsaVNlYXJjaCIsIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJfX2dlbmVyYXRvciIsImJvZHkiLCJfIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsInYiLCJvcCIsIlR5cGVFcnJvciIsInBvcCIsInB1c2giLCJfX3NwcmVhZEFycmF5IiwidG8iLCJmcm9tIiwiaWwiLCJqIiwicmVtb3ZlVW5kZWZpbmVkIiwiYXJyIiwiZmlsdGVyIiwieCIsInVuZGVmaW5lZCIsInJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduIiwicmVwbGFjZSIsInN0cmluZ2lmeUFycmF5IiwicmVkdWNlIiwiYWNjIiwiY3VyciIsIkpTT04iLCJzdHJpbmdpZnkiLCJjZWlsZWREaXZpc2lvbiIsImRpdmlkZW5kIiwiZGl2aXNvciIsIk51bWJlclBhZ2VzIiwiTWF0aCIsImNlaWwiLCJpc1B1cmVPYmplY3QiLCJkYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiYWRhcHRGaWx0ZXJTeW50YXgiLCJtYXRjaGVzIiwibWF0Y2giLCJmaWx0ZXJOYW1lIiwiZXh0cmFjdEZpbHRlcnMiLCJmaWx0ZXJzIiwibWFwIiwibmVzdGVkRmlsdGVyIiwiZmxhdCIsImdldEZhY2V0c0Zyb21GaWx0ZXIiLCJleHRyYWN0ZWRGaWx0ZXJzIiwiY2xlYW5GaWx0ZXJzIiwiY2FjaGUiLCJwYXJzZWRGaWx0ZXIiLCJfYSIsInByZXZGaWVsZHMiLCJnZXRGYWNldHNGcm9tRGVmYXVsdERpc3RyaWJ1dGlvbiIsImZhY2V0c0Rpc3RyaWJ1dGlvbiIsImtleXMiLCJmYWNldCIsImZhY2V0VmFsdWVzIiwiZXh0cmFjdEZhY2V0cyIsInNlYXJjaENvbnRleHQiLCJzZWFyY2hQYXJhbXMiLCJrZWVwWmVyb0ZhY2V0cyIsImRlZmF1bHRGYWNldERpc3RyaWJ1dGlvbiIsImFkZE1pc3NpbmdGYWNldHMiLCJjYWNoZWRGYWNldHMiLCJkaXN0cmlidXRpb24iLCJjYWNoZWRGYWNldCIsIl9pIiwiY2FjaGVkRmllbGQiLCJpbmNsdWRlcyIsImVtcHR5U2VhcmNoIiwiaGl0cyIsInF1ZXJ5IiwibGltaXQiLCJvZmZzZXQiLCJleGhhdXN0aXZlTmJIaXRzIiwibmJIaXRzIiwicHJvY2Vzc2luZ1RpbWVNcyIsIlNlYXJjaFJlc29sdmVyIiwic2VhcmNoUmVzcG9uc2UiLCJjbGllbnQiLCJwbGFjZWhvbGRlclNlYXJjaCIsInBhZ2luYXRpb24iLCJwYWdpbmF0aW9uQ2FjaGUiLCJrZXkiLCJjYWNoZWRSZXNwb25zZSIsImZhY2V0c0NhY2hlIiwiZmluaXRlUGFnaW5hdGlvbiIsImZvcm1hdEtleSIsImluZGV4VWlkIiwiZ2V0RW50cnkiLCJpbmRleCIsInNlYXJjaCIsInNldEVudHJ5IiwicmFkMmRlZ3IiLCJyYWQiLCJQSSIsImRlZ3IycmFkIiwiZGVnciIsIm1pZGRsZUdlb1BvaW50cyIsImxhdDEiLCJsbmcxIiwibGF0MiIsImxuZzIiLCJ4MSIsImNvcyIsInkxIiwic2luIiwiejEiLCJ4MiIsInkyIiwiejIiLCJ6IiwiSHlwIiwic3FydCIsImxuZzMiLCJhdGFuMiIsImxhdDMiLCJhYnMiLCJwb3ciLCJjb25jYXQiLCJnZXREaXN0YW5jZUluTWV0ZXIiLCJSIiwibGF0UmFkMSIsImxhdFJhZDIiLCJsYXRDZW50ZXJSYWQiLCJsbmdDZW50ZXJSYWQiLCJhIiwiYmVhcmluZyIsImRpc3RhbmNlIiwiYWRhcHRHZW9Qb2ludHNSdWxlcyIsImdlb1NlYXJjaENvbnRleHQiLCJpbnNpZGVCb3VuZGluZ0JveCIsImFyb3VuZExhdExuZyIsImFyb3VuZFJhZGl1cyIsIm1pbmltdW1Bcm91bmRSYWRpdXMiLCJtaWRkbGVQb2ludCIsInJhZGl1cyIsInNwbGl0IiwibGF0MVJhdyIsImxuZzFSYXciLCJsYXQyUmF3IiwibG5nMlJhdyIsIl9iIiwicGFyc2VGbG9hdCIsIl9jIiwiTnVtYmVyIiwidG9GaXhlZCIsImNyZWF0ZUdlb1NlYXJjaENvbnRleHQiLCJnZW9Db250ZXh0IiwiYXJvdW5kTGF0TG5nVmlhSVAiLCJhcm91bmRQcmVjaXNpb24iLCJpbnNpZGVQb2x5Z29uIiwiY29uc29sZSIsIndhcm4iLCJ0cmFuc2Zvcm1GaWx0ZXIiLCJlbGVtIiwiZmlsdGVyVG9BcnJheSIsIm1lcmdlRmlsdGVycyIsImZhY2V0RmlsdGVycyIsIm51bWVyaWNGaWx0ZXJzIiwiYWRhcHRlZEZpbHRlcnMiLCJ0cmltIiwiYWRhcHRlZEZhY2V0RmlsdGVycyIsImFkYXB0ZWROdW1lcmljRmlsdGVycyIsImFkYXB0ZWRGaWx0ZXIiLCJjbGVhbmVkRmlsdGVycyIsImFkYXB0RmlsdGVycyIsInRyYW5zZm9ybWVkRmlsdGVyIiwidHJhbnNmb3JtZWROdW1lcmljRmlsdGVyIiwiYWRhcHRTZWFyY2hQYXJhbXMiLCJtZWlsaVNlYXJjaFBhcmFtcyIsImZhY2V0cyIsImF0dHJpYnV0ZXNUb0Nyb3AiLCJhdHRyaWJ1dGVzVG9TbmlwcGV0IiwiY3JvcE1hcmtlciIsInNuaXBwZXRFbGxpcHNpc1RleHQiLCJhdHRyaWJ1dGVzVG9SZXRyaWV2ZSIsImF0dHJpYnV0ZXNUb0hpZ2hsaWdodCIsImhpZ2hsaWdodFByZVRhZyIsImhpZ2hsaWdodFBvc3RUYWciLCJwYWdpbmF0aW9uVG90YWxIaXRzIiwicGFnZSIsImhpdHNQZXJQYWdlIiwic29ydCIsImdlb1J1bGVzIiwidW5zaGlmdCIsImFkYXB0UGFnaW5hdGlvbiIsInN0YXJ0Iiwic2xpY2UiLCJzdHJpbmdpZnlWYWx1ZSIsIndyYXBWYWx1ZSIsIm5lc3RlZCIsImFkYXB0Rm9ybWF0dGVkRmllbGRzIiwiaGl0IiwiX2Zvcm1hdHRlZFJlc3VsdCIsImhpZ2hsaWdodGVkSGl0IiwiX2hpZ2hsaWdodFJlc3VsdCIsIl9zbmlwcGV0UmVzdWx0IiwiYWRhcHRHZW9SZXNwb25zZSIsIl9nZW8iLCJfZ2VvbG9jIiwibGF0IiwibG5nIiwib2JqZWN0SUQiLCJyYW5kb20iLCJhZGFwdEhpdHMiLCJwYWdpbmF0aW9uQ29udGV4dCIsInByaW1hcnlLZXkiLCJwYWdpbmF0ZWRIaXRzIiwiYWRhcHRlZEhpdHMiLCJmb3JtYXR0ZWRIaXQiLCJfZm9ybWF0dGVkIiwiX21hdGNoZXNJbmZvIiwiZG9jdW1lbnRGaWVsZHMiLCJhZGFwdGVkSGl0IiwiYWRhcHRTZWFyY2hSZXNwb25zZSIsInNlYXJjaFJlc3BvbnNlT3B0aW9uYWxzIiwiZXhoYXVzdGl2ZUZhY2V0c0NvdW50IiwibmJQYWdlcyIsImFkYXB0ZWRTZWFyY2hSZXNwb25zZSIsInByb2Nlc3NpbmdUaW1lTVMiLCJwYXJhbXMiLCJyZXN1bHRzIiwiY3JlYXRlUGFnaW5hdGlvbkNvbnRleHQiLCJjcmVhdGVTZWFyY2hDb250ZXh0Iiwic2VhcmNoUmVxdWVzdCIsIm9wdGlvbnMiLCJpbmRleE5hbWUiLCJzb3J0QnlBcnJheSIsImluc3RhbnRTZWFyY2hQYXJhbXMiLCJqb2luIiwiU2VhcmNoQ2FjaGUiLCJzZWFyY2hDYWNoZSIsInBhcnNlIiwiY29tcG9uZW50cyIsImNhY2hlRmlyc3RGYWNldHNEaXN0cmlidXRpb24iLCJpbnN0YW50TWVpbGlTZWFyY2giLCJob3N0VXJsIiwiYXBpS2V5IiwiaW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucyIsInNlYXJjaFJlc29sdmVyIiwibWVpbGlzZWFyY2hDbGllbnQiLCJob3N0IiwiaW5zdGFudFNlYXJjaFJlcXVlc3RzIiwiYWRhcHRlZFNlYXJjaFJlcXVlc3QiLCJlXzEiLCJlcnJvciIsIkVycm9yIiwic2VhcmNoRm9yRmFjZXRWYWx1ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js\n");

/***/ })

};
;